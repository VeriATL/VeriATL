implementation driver(){
call init_tar_model();
call CopyAbstraction_matchAll();
call CopyAcceptCallAction_matchAll();
call CopyAcceptEventAction_matchAll();
call CopyActionExecutionSpecification_matchAll();
call CopyActionInputPin_matchAll();
call CopyActivity_matchAll();
call CopyActivityFinalNode_matchAll();
call CopyActivityParameterNode_matchAll();
call CopyActivityPartition_matchAll();
call CopyActor_matchAll();
call CopyAddStructuralFeatureValueAction_matchAll();
call CopyAddVariableValueAction_matchAll();
call CopyAnyReceiveEvent_matchAll();
call CopyArtifact_matchAll();
call CopyAssociation_matchAll();
call CopyAssociationClass_matchAll();
call CopyBehaviorExecutionSpecification_matchAll();
call CopyBroadcastSignalAction_matchAll();
call CopyCallBehaviorAction_matchAll();
call CopyCallEvent_matchAll();
call CopyCallOperationAction_matchAll();
call CopyCentralBufferNode_matchAll();
call CopyChangeEvent_matchAll();
call CopyClass_matchAll();
call CopyClassifierTemplateParameter_matchAll();
call CopyClause_matchAll();
call CopyClearAssociationAction_matchAll();
call CopyClearStructuralFeatureAction_matchAll();
call CopyClearVariableAction_matchAll();
call CopyCollaboration_matchAll();
call CopyCollaborationUse_matchAll();
call CopyCombinedFragment_matchAll();
call CopyComment_matchAll();
call CopyCommunicationPath_matchAll();
call CopyComponent_matchAll();
call CopyComponentRealization_matchAll();
call CopyConditionalNode_matchAll();
call CopyConnectableElementTemplateParameter_matchAll();
call CopyConnectionPointReference_matchAll();
call CopyConnector_matchAll();
call CopyConnectorEnd_matchAll();
call CopyConsiderIgnoreFragment_matchAll();
call CopyConstraint_matchAll();
call CopyContinuation_matchAll();
call CopyControlFlow_matchAll();
call CopyCreateLinkAction_matchAll();
call CopyCreateLinkObjectAction_matchAll();
call CopyCreateObjectAction_matchAll();
call CopyDataStoreNode_matchAll();
call CopyDataType_matchAll();
call CopyDecisionNode_matchAll();
call CopyDependency_matchAll();
call CopyDeployment_matchAll();
call CopyDeploymentSpecification_matchAll();
call CopyDestroyLinkAction_matchAll();
call CopyDestroyObjectAction_matchAll();
call CopyDestructionOccurrenceSpecification_matchAll();
call CopyDevice_matchAll();
call CopyDuration_matchAll();
call CopyDurationConstraint_matchAll();
call CopyDurationInterval_matchAll();
call CopyDurationObservation_matchAll();
call CopyElementImport_matchAll();
call CopyEnumeration_matchAll();
call CopyEnumerationLiteral_matchAll();
call CopyExceptionHandler_matchAll();
call CopyExecutionEnvironment_matchAll();
call CopyExecutionOccurrenceSpecification_matchAll();
call CopyExpansionNode_matchAll();
call CopyExpansionRegion_matchAll();
call CopyExpression_matchAll();
call CopyExtend_matchAll();
call CopyExtension_matchAll();
call CopyExtensionEnd_matchAll();
call CopyExtensionPoint_matchAll();
call CopyFinalState_matchAll();
call CopyFlowFinalNode_matchAll();
call CopyForkNode_matchAll();
call CopyFunctionBehavior_matchAll();
call CopyGate_matchAll();
call CopyGeneralOrdering_matchAll();
call CopyGeneralization_matchAll();
call CopyGeneralizationSet_matchAll();
call CopyImage_matchAll();
call CopyInclude_matchAll();
call CopyInformationFlow_matchAll();
call CopyInformationItem_matchAll();
call CopyInitialNode_matchAll();
call CopyInputPin_matchAll();
call CopyInstanceSpecification_matchAll();
call CopyInstanceValue_matchAll();
call CopyInteraction_matchAll();
call CopyInteractionConstraint_matchAll();
call CopyInteractionOperand_matchAll();
call CopyInteractionUse_matchAll();
call CopyInterface_matchAll();
call CopyInterfaceRealization_matchAll();
call CopyInterruptibleActivityRegion_matchAll();
call CopyInterval_matchAll();
call CopyIntervalConstraint_matchAll();
call CopyJoinNode_matchAll();
call CopyLifeline_matchAll();
call CopyLinkEndCreationData_matchAll();
call CopyLinkEndData_matchAll();
call CopyLinkEndDestructionData_matchAll();
call CopyLiteralBoolean_matchAll();
call CopyLiteralInteger_matchAll();
call CopyLiteralNull_matchAll();
call CopyLiteralReal_matchAll();
call CopyLiteralString_matchAll();
call CopyLiteralUnlimitedNatural_matchAll();
call CopyLoopNode_matchAll();
call CopyManifestation_matchAll();
call CopyMergeNode_matchAll();
call CopyMessage_matchAll();
call CopyMessageOccurrenceSpecification_matchAll();
call CopyModel_matchAll();
call CopyNode_matchAll();
call CopyObjectFlow_matchAll();
call CopyOccurrenceSpecification_matchAll();
call CopyOpaqueAction_matchAll();
call CopyOpaqueBehavior_matchAll();
call CopyOpaqueExpression_matchAll();
call CopyOperation_matchAll();
call CopyOperationTemplateParameter_matchAll();
call CopyOutputPin_matchAll();
call CopyPackage_matchAll();
call CopyPackageImport_matchAll();
call CopyPackageMerge_matchAll();
call CopyParameter_matchAll();
call CopyParameterSet_matchAll();
call CopyPartDecomposition_matchAll();
call CopyPort_matchAll();
call CopyPrimitiveType_matchAll();
call CopyProfile_matchAll();
call CopyProfileApplication_matchAll();
call CopyProperty_matchAll();
call CopyProtocolConformance_matchAll();
call CopyProtocolStateMachine_matchAll();
call CopyProtocolTransition_matchAll();
call CopyPseudostate_matchAll();
call CopyQualifierValue_matchAll();
call CopyRaiseExceptionAction_matchAll();
call CopyReadExtentAction_matchAll();
call CopyReadIsClassifiedObjectAction_matchAll();
call CopyReadLinkAction_matchAll();
call CopyReadLinkObjectEndAction_matchAll();
call CopyReadLinkObjectEndQualifierAction_matchAll();
call CopyReadSelfAction_matchAll();
call CopyReadStructuralFeatureAction_matchAll();
call CopyReadVariableAction_matchAll();
call CopyRealization_matchAll();
call CopyReception_matchAll();
call CopyReclassifyObjectAction_matchAll();
call CopyRedefinableTemplateSignature_matchAll();
call CopyReduceAction_matchAll();
call CopyRegion_matchAll();
call CopyRemoveStructuralFeatureValueAction_matchAll();
call CopyRemoveVariableValueAction_matchAll();
call CopyReplyAction_matchAll();
call CopySendObjectAction_matchAll();
call CopySendSignalAction_matchAll();
call CopySequenceNode_matchAll();
call CopySignal_matchAll();
call CopySignalEvent_matchAll();
call CopySlot_matchAll();
call CopyStartClassifierBehaviorAction_matchAll();
call CopyStartObjectBehaviorAction_matchAll();
call CopyState_matchAll();
call CopyStateInvariant_matchAll();
call CopyStateMachine_matchAll();
call CopyStereotype_matchAll();
call CopyStringExpression_matchAll();
call CopyStructuredActivityNode_matchAll();
call CopySubstitution_matchAll();
call CopyTemplateBinding_matchAll();
call CopyTemplateParameter_matchAll();
call CopyTemplateParameterSubstitution_matchAll();
call CopyTemplateSignature_matchAll();
call CopyTestIdentityAction_matchAll();
call CopyTimeConstraint_matchAll();
call CopyTimeEvent_matchAll();
call CopyTimeExpression_matchAll();
call CopyTimeInterval_matchAll();
call CopyTimeObservation_matchAll();
call CopyTransition_matchAll();
call CopyTrigger_matchAll();
call CopyUnmarshallAction_matchAll();
call CopyUsage_matchAll();
call CopyUseCase_matchAll();
call CopyValuePin_matchAll();
call CopyValueSpecificationAction_matchAll();
call CopyVariable_matchAll();
call CopyAbstraction_applyAll();
call CopyAcceptCallAction_applyAll();
call CopyAcceptEventAction_applyAll();
call CopyActionExecutionSpecification_applyAll();
call CopyActionInputPin_applyAll();
call CopyActivity_applyAll();
call CopyActivityFinalNode_applyAll();
call CopyActivityParameterNode_applyAll();
call CopyActivityPartition_applyAll();
call CopyActor_applyAll();
call CopyAddStructuralFeatureValueAction_applyAll();
call CopyAddVariableValueAction_applyAll();
call CopyAnyReceiveEvent_applyAll();
call CopyArtifact_applyAll();
call CopyAssociation_applyAll();
call CopyAssociationClass_applyAll();
call CopyBehaviorExecutionSpecification_applyAll();
call CopyBroadcastSignalAction_applyAll();
call CopyCallBehaviorAction_applyAll();
call CopyCallEvent_applyAll();
call CopyCallOperationAction_applyAll();
call CopyCentralBufferNode_applyAll();
call CopyChangeEvent_applyAll();
call CopyClass_applyAll();
call CopyClassifierTemplateParameter_applyAll();
call CopyClause_applyAll();
call CopyClearAssociationAction_applyAll();
call CopyClearStructuralFeatureAction_applyAll();
call CopyClearVariableAction_applyAll();
call CopyCollaboration_applyAll();
call CopyCollaborationUse_applyAll();
call CopyCombinedFragment_applyAll();
call CopyComment_applyAll();
call CopyCommunicationPath_applyAll();
call CopyComponent_applyAll();
call CopyComponentRealization_applyAll();
call CopyConditionalNode_applyAll();
call CopyConnectableElementTemplateParameter_applyAll();
call CopyConnectionPointReference_applyAll();
call CopyConnector_applyAll();
call CopyConnectorEnd_applyAll();
call CopyConsiderIgnoreFragment_applyAll();
call CopyConstraint_applyAll();
call CopyContinuation_applyAll();
call CopyControlFlow_applyAll();
call CopyCreateLinkAction_applyAll();
call CopyCreateLinkObjectAction_applyAll();
call CopyCreateObjectAction_applyAll();
call CopyDataStoreNode_applyAll();
call CopyDataType_applyAll();
call CopyDecisionNode_applyAll();
call CopyDependency_applyAll();
call CopyDeployment_applyAll();
call CopyDeploymentSpecification_applyAll();
call CopyDestroyLinkAction_applyAll();
call CopyDestroyObjectAction_applyAll();
call CopyDestructionOccurrenceSpecification_applyAll();
call CopyDevice_applyAll();
call CopyDuration_applyAll();
call CopyDurationConstraint_applyAll();
call CopyDurationInterval_applyAll();
call CopyDurationObservation_applyAll();
call CopyElementImport_applyAll();
call CopyEnumeration_applyAll();
call CopyEnumerationLiteral_applyAll();
call CopyExceptionHandler_applyAll();
call CopyExecutionEnvironment_applyAll();
call CopyExecutionOccurrenceSpecification_applyAll();
call CopyExpansionNode_applyAll();
call CopyExpansionRegion_applyAll();
call CopyExpression_applyAll();
call CopyExtend_applyAll();
call CopyExtension_applyAll();
call CopyExtensionEnd_applyAll();
call CopyExtensionPoint_applyAll();
call CopyFinalState_applyAll();
call CopyFlowFinalNode_applyAll();
call CopyForkNode_applyAll();
call CopyFunctionBehavior_applyAll();
call CopyGate_applyAll();
call CopyGeneralOrdering_applyAll();
call CopyGeneralization_applyAll();
call CopyGeneralizationSet_applyAll();
call CopyImage_applyAll();
call CopyInclude_applyAll();
call CopyInformationFlow_applyAll();
call CopyInformationItem_applyAll();
call CopyInitialNode_applyAll();
call CopyInputPin_applyAll();
call CopyInstanceSpecification_applyAll();
call CopyInstanceValue_applyAll();
call CopyInteraction_applyAll();
call CopyInteractionConstraint_applyAll();
call CopyInteractionOperand_applyAll();
call CopyInteractionUse_applyAll();
call CopyInterface_applyAll();
call CopyInterfaceRealization_applyAll();
call CopyInterruptibleActivityRegion_applyAll();
call CopyInterval_applyAll();
call CopyIntervalConstraint_applyAll();
call CopyJoinNode_applyAll();
call CopyLifeline_applyAll();
call CopyLinkEndCreationData_applyAll();
call CopyLinkEndData_applyAll();
call CopyLinkEndDestructionData_applyAll();
call CopyLiteralBoolean_applyAll();
call CopyLiteralInteger_applyAll();
call CopyLiteralNull_applyAll();
call CopyLiteralReal_applyAll();
call CopyLiteralString_applyAll();
call CopyLiteralUnlimitedNatural_applyAll();
call CopyLoopNode_applyAll();
call CopyManifestation_applyAll();
call CopyMergeNode_applyAll();
call CopyMessage_applyAll();
call CopyMessageOccurrenceSpecification_applyAll();
call CopyModel_applyAll();
call CopyNode_applyAll();
call CopyObjectFlow_applyAll();
call CopyOccurrenceSpecification_applyAll();
call CopyOpaqueAction_applyAll();
call CopyOpaqueBehavior_applyAll();
call CopyOpaqueExpression_applyAll();
call CopyOperation_applyAll();
call CopyOperationTemplateParameter_applyAll();
call CopyOutputPin_applyAll();
call CopyPackage_applyAll();
call CopyPackageImport_applyAll();
call CopyPackageMerge_applyAll();
call CopyParameter_applyAll();
call CopyParameterSet_applyAll();
call CopyPartDecomposition_applyAll();
call CopyPort_applyAll();
call CopyPrimitiveType_applyAll();
call CopyProfile_applyAll();
call CopyProfileApplication_applyAll();
call CopyProperty_applyAll();
call CopyProtocolConformance_applyAll();
call CopyProtocolStateMachine_applyAll();
call CopyProtocolTransition_applyAll();
call CopyPseudostate_applyAll();
call CopyQualifierValue_applyAll();
call CopyRaiseExceptionAction_applyAll();
call CopyReadExtentAction_applyAll();
call CopyReadIsClassifiedObjectAction_applyAll();
call CopyReadLinkAction_applyAll();
call CopyReadLinkObjectEndAction_applyAll();
call CopyReadLinkObjectEndQualifierAction_applyAll();
call CopyReadSelfAction_applyAll();
call CopyReadStructuralFeatureAction_applyAll();
call CopyReadVariableAction_applyAll();
call CopyRealization_applyAll();
call CopyReception_applyAll();
call CopyReclassifyObjectAction_applyAll();
call CopyRedefinableTemplateSignature_applyAll();
call CopyReduceAction_applyAll();
call CopyRegion_applyAll();
call CopyRemoveStructuralFeatureValueAction_applyAll();
call CopyRemoveVariableValueAction_applyAll();
call CopyReplyAction_applyAll();
call CopySendObjectAction_applyAll();
call CopySendSignalAction_applyAll();
call CopySequenceNode_applyAll();
call CopySignal_applyAll();
call CopySignalEvent_applyAll();
call CopySlot_applyAll();
call CopyStartClassifierBehaviorAction_applyAll();
call CopyStartObjectBehaviorAction_applyAll();
call CopyState_applyAll();
call CopyStateInvariant_applyAll();
call CopyStateMachine_applyAll();
call CopyStereotype_applyAll();
call CopyStringExpression_applyAll();
call CopyStructuredActivityNode_applyAll();
call CopySubstitution_applyAll();
call CopyTemplateBinding_applyAll();
call CopyTemplateParameter_applyAll();
call CopyTemplateParameterSubstitution_applyAll();
call CopyTemplateSignature_applyAll();
call CopyTestIdentityAction_applyAll();
call CopyTimeConstraint_applyAll();
call CopyTimeEvent_applyAll();
call CopyTimeExpression_applyAll();
call CopyTimeInterval_applyAll();
call CopyTimeObservation_applyAll();
call CopyTransition_applyAll();
call CopyTrigger_applyAll();
call CopyUnmarshallAction_applyAll();
call CopyUsage_applyAll();
call CopyUseCase_applyAll();
call CopyValuePin_applyAll();
call CopyValueSpecificationAction_applyAll();
call CopyVariable_applyAll();



// CallAction_synchronous_call 
assert (forall ca:ref :: // [UMLs$CallAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$CallAction), ca) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , ca, UMLs$CallAction.result))) > 0 ==> Seq#NotEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , ca, UMLs$CallAction.result))) ==> read( $tarHeap , ca, UMLs$CallAction.isSynchronous))
;
// Enumeration_immutable 
assert (forall e:ref :: // [UMLs$Enumeration]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Enumeration), e) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , e, UMLs$DataType.ownedAttribute))) > 0 ==> (forall p1_:ref :: // [UMLs$Property]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , e, UMLs$DataType.ownedAttribute)), $Box(p1_)) ==>
	     	     read( $tarHeap , p1_, UMLs$StructuralFeature.isReadOnly))
	     )
;

// AcceptEventAction_no_output_pins 
assert (forall aea:ref :: // [UMLs$AcceptEventAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$AcceptEventAction), aea) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , aea, UMLs$AcceptEventAction.trigger))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , aea, UMLs$Action.output))) > 0 ==> dtype(aea) == UMLs$AcceptEventAction  &&  (forall t1_:ref :: // [UMLs$Trigger]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , aea, UMLs$AcceptEventAction.trigger)), $Box(t1_)) ==>
	     	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Event), read( $tarHeap , t1_, UMLs$Trigger.event)) ==> dtype(read( $tarHeap , t1_, UMLs$Trigger.event)) <: UMLs$ChangeEvent  ||  dtype(read( $tarHeap , t1_, UMLs$Trigger.event)) <: UMLs$CallEvent)
	      ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , aea, UMLs$Action.output))) == 0)
;
// ActionInputPin_one_output_pin 
assert (forall aip:ref :: // [UMLs$ActionInputPin]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ActionInputPin), aip) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Action), read( $tarHeap , aip, UMLs$ActionInputPin.fromAction)) ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , aip, UMLs$ActionInputPin.fromAction), UMLs$Action.output))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , aip, UMLs$ActionInputPin.fromAction), UMLs$Action.output))) == 1)
;
// Behavior_feature_of_context_classifier 
assert (forall b:ref :: // [UMLs$Behavior]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Behavior), b) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$BehavioredClassifier), read( $tarHeap , b, UMLs$Behavior.context)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$BehavioralFeature), read( $tarHeap , b, UMLs$Behavior.specification)) ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , b, UMLs$Behavior.context), UMLs$Classifier.feature))) > 0 ==> Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , b, UMLs$Behavior.context), UMLs$Classifier.feature)), $Box(read( $tarHeap , b, UMLs$Behavior.specification))))
;

// State_composite_states 
assert (forall s:ref :: // [UMLs$State]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$State), s) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , s, UMLs$State.connectionPoint))) > 0 ==> Seq#NotEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , s, UMLs$State.connectionPoint))) ==> read( $tarHeap , s, UMLs$State.isComposite))
;
// BehavioralFeature_abstract_no_method 
assert (forall bf:ref :: // [UMLs$BehavioralFeature]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$BehavioralFeature), bf) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , bf, UMLs$BehavioralFeature.method))) > 0 ==> read( $tarHeap , bf, UMLs$BehavioralFeature.isAbstract) ==> Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , bf, UMLs$BehavioralFeature.method))))
;
// InformationFlow_convey_classifiers 
assert (forall _if:ref :: // [UMLs$InformationFlow]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$InformationFlow), _if) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , _if, UMLs$InformationFlow.conveyed))) > 0 ==> (forall c1_:ref :: // [UMLs$Classifier]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , _if, UMLs$InformationFlow.conveyed)), $Box(c1_)) ==>
	     	     dtype(c1_) <: UMLs$Class  ||  dtype(c1_) <: UMLs$Interface  ||  dtype(c1_) <: UMLs$InformationItem  ||  dtype(c1_) <: UMLs$Signal  ||  dtype(c1_) <: UMLs$Component)
	     )
;
// StringExpression_operands 
assert (forall se:ref :: // [UMLs$StringExpression]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$StringExpression), se) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , se, UMLs$Expression.operand))) > 0 ==> (forall vs1_:ref :: // [UMLs$ValueSpecification]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , se, UMLs$Expression.operand)), $Box(vs1_)) ==>
	     	     dtype(vs1_) <: UMLs$LiteralString)
	     )
;
// Extend_extension_points 
assert (forall e:ref :: // [UMLs$Extend]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Extend), e) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$UseCase), read( $tarHeap , e, UMLs$Extend.extendedCase)) ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , e, UMLs$Extend.extensionLocation))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , e, UMLs$Extend.extendedCase), UMLs$UseCase.extensionPoint))) > 0 ==> (forall epxp:ref :: // [UMLs$ExtensionPoint]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , e, UMLs$Extend.extensionLocation)), $Box(epxp)) ==>
	     	     Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , e, UMLs$Extend.extendedCase), UMLs$UseCase.extensionPoint)), $Box(epxp)))
	     )
;
// ObjectFlow_is_multicast_or_is_multireceive 
assert (forall of:ref :: // [UMLs$ObjectFlow]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ObjectFlow), of) ==>
	     !(read( $tarHeap , of, UMLs$ObjectFlow.isMulticast)  &&  read( $tarHeap , of, UMLs$ObjectFlow.isMultireceive)))
;
// ConditionalNode_no_input_pins 
assert (forall cn:ref :: // [UMLs$ConditionalNode]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ConditionalNode), cn) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , cn, UMLs$Action.input))) > 0 ==> Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , cn, UMLs$Action.input))))
;
// CreateObjectAction_classifier_not_association_class 
assert (forall coa:ref :: // [UMLs$CreateObjectAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$CreateObjectAction), coa) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Classifier), read( $tarHeap , coa, UMLs$CreateObjectAction.classifier)) ==> !(dtype(read( $tarHeap , coa, UMLs$CreateObjectAction.classifier)) <: UMLs$AssociationClass))
;
// ActionInputPin_input_pin 
assert (forall aip:ref :: // [UMLs$ActionInputPin]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ActionInputPin), aip) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , aip, UMLs$ActionInputPin.fromAction), UMLs$Action.input))) > 0 ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Action), read( $tarHeap , aip, UMLs$ActionInputPin.fromAction)) ==> (forall ip1_:ref :: // [UMLs$InputPin]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , aip, UMLs$ActionInputPin.fromAction), UMLs$Action.input)), $Box(ip1_)) ==>
	     	     dtype(ip1_) <: UMLs$ActionInputPin)
	     )
;
// ActivityParameterNode_same_type 
assert (forall apn:ref :: // [UMLs$ActivityParameterNode]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ActivityParameterNode), apn) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Parameter), read( $tarHeap , apn, UMLs$ActivityParameterNode.parameter)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Type), read( $tarHeap , apn, UMLs$TypedElement.type)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Type), read( $tarHeap , read( $tarHeap , apn, UMLs$ActivityParameterNode.parameter), UMLs$TypedElement.type)) ==> read( $tarHeap , apn, UMLs$TypedElement.type) == read( $tarHeap , read( $tarHeap , apn, UMLs$ActivityParameterNode.parameter), UMLs$TypedElement.type))
;
// AcceptCallAction_unmarshall 
assert (forall aca:ref :: // [UMLs$AcceptCallAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$AcceptCallAction), aca) ==>
	     read( $tarHeap , aca, UMLs$AcceptEventAction.isUnmarshall) == true)
;
// ObjectFlow_no_executable_nodes 
assert (forall of:ref :: // [UMLs$ObjectFlow]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ObjectFlow), of) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ActivityNode), read( $tarHeap , of, UMLs$ActivityEdge.target)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ActivityNode), read( $tarHeap , of, UMLs$ActivityEdge.source)) ==> !(dtype(read( $tarHeap , of, UMLs$ActivityEdge.source)) <: UMLs$ExecutableNode  ||  dtype(read( $tarHeap , of, UMLs$ActivityEdge.target)) <: UMLs$ExecutableNode))
;
// StructuralFeatureAction_not_static 
assert (forall sfa:ref :: // [UMLs$StructuralFeatureAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$StructuralFeatureAction), sfa) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$StructuralFeature), read( $tarHeap , sfa, UMLs$StructuralFeatureAction.structuralFeature)) ==> !(read( $tarHeap , read( $tarHeap , sfa, UMLs$StructuralFeatureAction.structuralFeature), UMLs$Feature.isStatic)))
;

// CreateObjectAction_same_type 
assert (forall coa:ref :: // [UMLs$CreateObjectAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$CreateObjectAction), coa) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Type), read( $tarHeap , read( $tarHeap , coa, UMLs$CreateObjectAction.result), UMLs$TypedElement.type)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$OutputPin), read( $tarHeap , coa, UMLs$CreateObjectAction.result)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Classifier), read( $tarHeap , coa, UMLs$CreateObjectAction.classifier)) ==> read( $tarHeap , read( $tarHeap , coa, UMLs$CreateObjectAction.result), UMLs$TypedElement.type) == read( $tarHeap , coa, UMLs$CreateObjectAction.classifier))
;
// JoinNode_one_outgoing_edge 
assert (forall jn:ref :: // [UMLs$JoinNode]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$JoinNode), jn) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , jn, UMLs$ActivityNode.outgoing))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , jn, UMLs$ActivityNode.outgoing))) == 1)
;
// InformationItem_not_instantiable 
assert (forall ii:ref :: // [UMLs$InformationItem]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$InformationItem), ii) ==>
	     read( $tarHeap , ii, UMLs$Classifier.isAbstract))
;
// DecisionNode_decision_input_flow_incoming 
assert (forall dn:ref :: // [UMLs$DecisionNode]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$DecisionNode), dn) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ObjectFlow), read( $tarHeap , dn, UMLs$DecisionNode.decisionInputFlow)) ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , dn, UMLs$ActivityNode.incoming))) > 0 ==> Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , dn, UMLs$ActivityNode.incoming)), $Box(read( $tarHeap , dn, UMLs$DecisionNode.decisionInputFlow))))
;
// ExecutionSpecification_same_lifeline 
assert (forall es:ref :: // [UMLs$ExecutionSpecification]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ExecutionSpecification), es) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$OccurrenceSpecification), read( $tarHeap , es, UMLs$ExecutionSpecification.start)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Lifeline), read( $tarHeap , read( $tarHeap , es, UMLs$ExecutionSpecification.finish), UMLs$InteractionFragment.covered)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Lifeline), read( $tarHeap , read( $tarHeap , es, UMLs$ExecutionSpecification.start), UMLs$InteractionFragment.covered)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$OccurrenceSpecification), read( $tarHeap , es, UMLs$ExecutionSpecification.finish)) ==> read( $tarHeap , read( $tarHeap , es, UMLs$ExecutionSpecification.start), UMLs$InteractionFragment.covered) == read( $tarHeap , read( $tarHeap , es, UMLs$ExecutionSpecification.finish), UMLs$InteractionFragment.covered))
;
// TimeConstraint_has_one_constrainedElement 
assert (forall tc:ref :: // [UMLs$TimeConstraint]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$TimeConstraint), tc) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , tc, UMLs$Constraint.constrainedElement))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , tc, UMLs$Constraint.constrainedElement))) == 1)
;
// LinkAction_not_static 
assert (forall la:ref :: // [UMLs$LinkAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$LinkAction), la) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , la, UMLs$LinkAction.endData))) > 0 ==> (forall led1_:ref :: // [UMLs$LinkEndData]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , la, UMLs$LinkAction.endData)), $Box(led1_)) ==>
	     	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Property), read( $tarHeap , led1_, UMLs$LinkEndData.end)) ==> !(read( $tarHeap , read( $tarHeap , led1_, UMLs$LinkEndData.end), UMLs$Feature.isStatic)))
	     )
;
// ActivityParameterNode_has_parameters 
assert (forall apn:ref :: // [UMLs$ActivityParameterNode]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ActivityParameterNode), apn) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , apn, UMLs$ActivityNode.activity), UMLs$Behavior.ownedParameter))) > 0 ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Activity), read( $tarHeap , apn, UMLs$ActivityNode.activity)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Parameter), read( $tarHeap , apn, UMLs$ActivityParameterNode.parameter)) ==> Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , apn, UMLs$ActivityNode.activity), UMLs$Behavior.ownedParameter)), $Box(read( $tarHeap , apn, UMLs$ActivityParameterNode.parameter))))
;
// Constraint_not_apply_to_self 
assert (forall c:ref :: // [UMLs$Constraint]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Constraint), c) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , c, UMLs$Constraint.constrainedElement))) > 0 ==> !(Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , c, UMLs$Constraint.constrainedElement)), $Box(c))))
;
// Property_subsetted_property_names 
assert (forall p:ref :: // [UMLs$Property]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Property), p) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , p, UMLs$Property.subsettedProperty))) > 0 ==> (forall psp:ref :: // [UMLs$Property]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , p, UMLs$Property.subsettedProperty)), $Box(psp)) ==>
	     	     read( $tarHeap , psp, UMLs$NamedElement.name) != read( $tarHeap , p, UMLs$NamedElement.name)
	     	     )
	     )
;
// CreateObjectAction_classifier_not_abstract 
assert (forall coa:ref :: // [UMLs$CreateObjectAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$CreateObjectAction), coa) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Classifier), read( $tarHeap , coa, UMLs$CreateObjectAction.classifier)) ==> !(read( $tarHeap , read( $tarHeap , coa, UMLs$CreateObjectAction.classifier), UMLs$Classifier.isAbstract)))
;
// Pin_control_pins 
assert (forall p:ref :: // [UMLs$Pin]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Pin), p) ==>
	     read( $tarHeap , p, UMLs$Pin.isControl) ==> read( $tarHeap , p, UMLs$ObjectNode.isControlType))
;
// ReadLinkObjectEndQualifierAction_same_type 
assert (forall rloeqa:ref :: // [UMLs$ReadLinkObjectEndQualifierAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ReadLinkObjectEndQualifierAction), rloeqa) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Type), read( $tarHeap , read( $tarHeap , rloeqa, UMLs$ReadLinkObjectEndQualifierAction.result), UMLs$TypedElement.type)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Property), read( $tarHeap , rloeqa, UMLs$ReadLinkObjectEndQualifierAction.qualifier)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Type), read( $tarHeap , read( $tarHeap , rloeqa, UMLs$ReadLinkObjectEndQualifierAction.qualifier), UMLs$TypedElement.type)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$OutputPin), read( $tarHeap , rloeqa, UMLs$ReadLinkObjectEndQualifierAction.result)) ==> read( $tarHeap , read( $tarHeap , rloeqa, UMLs$ReadLinkObjectEndQualifierAction.result), UMLs$TypedElement.type) == read( $tarHeap , read( $tarHeap , rloeqa, UMLs$ReadLinkObjectEndQualifierAction.qualifier), UMLs$TypedElement.type))
;
// FinalNode_no_outgoing_edges 
assert (forall fn:ref :: // [UMLs$FinalNode]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$FinalNode), fn) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , fn, UMLs$ActivityNode.outgoing))) > 0 ==> Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , fn, UMLs$ActivityNode.outgoing))))
;
// Component_no_nested_classifiers 
assert (forall c:ref :: // [UMLs$Component]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Component), c) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , c, UMLs$Class.nestedClassifier))) > 0 ==> Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , c, UMLs$Class.nestedClassifier))))
;
// ExceptionHandler_handler_body_owner 
assert (forall eh:ref :: // [UMLs$ExceptionHandler]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ExceptionHandler), eh) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ExecutableNode), read( $tarHeap , eh, UMLs$ExceptionHandler.protectedNode)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Element), read( $tarHeap , read( $tarHeap , eh, UMLs$ExceptionHandler.protectedNode), UMLs$Element.owner)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ExecutableNode), read( $tarHeap , eh, UMLs$ExceptionHandler.handlerBody)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Element), read( $tarHeap , read( $tarHeap , eh, UMLs$ExceptionHandler.handlerBody), UMLs$Element.owner)) ==> read( $tarHeap , read( $tarHeap , eh, UMLs$ExceptionHandler.handlerBody), UMLs$Element.owner) == read( $tarHeap , read( $tarHeap , eh, UMLs$ExceptionHandler.protectedNode), UMLs$Element.owner))
;
// ConsiderIgnoreFragment_type 
assert (forall cif:ref :: // [UMLs$ConsiderIgnoreFragment]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ConsiderIgnoreFragment), cif) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , cif, UMLs$ConsiderIgnoreFragment.message))) > 0 ==> (forall nem:ref :: // [UMLs$NamedElement]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , cif, UMLs$ConsiderIgnoreFragment.message)), $Box(nem)) ==>
	     	     dtype(nem) <: UMLs$Operation  ||  dtype(nem) <: UMLs$Signal)
	     )
;
// Extension_is_binary 
assert (forall e:ref :: // [UMLs$Extension]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Extension), e) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , e, UMLs$Association.memberEnd))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , e, UMLs$Association.memberEnd))) == 2)
;
// State_destinations_or_sources_of_transitions 
assert (forall s:ref :: // [UMLs$State]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$State), s) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , s, UMLs$State.connection))) > 0 ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$StateMachine), read( $tarHeap , s, UMLs$State.submachine)) ==> read( $tarHeap , s, UMLs$State.isSubmachineState) ==> (forall cprcp:ref :: // [UMLs$ConnectionPointReference]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , s, UMLs$State.connection)), $Box(cprcp)) ==>
	     	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , cprcp, UMLs$ConnectionPointReference.exit))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , cprcp, UMLs$ConnectionPointReference.entry))) > 0 ==> (forall pps:ref :: // [UMLs$Pseudostate]
	     	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , cprcp, UMLs$ConnectionPointReference.entry)), $Box(pps)) ==>
	     	     	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$StateMachine), read( $tarHeap , pps, UMLs$Pseudostate.stateMachine)) ==> read( $tarHeap , pps, UMLs$Pseudostate.stateMachine) == read( $tarHeap , s, UMLs$State.submachine))
	     	       &&  (forall ppps1750120280:ref :: // [UMLs$Pseudostate]
	     	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , cprcp, UMLs$ConnectionPointReference.exit)), $Box(ppps1750120280)) ==>
	     	     	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$StateMachine), read( $tarHeap , ppps1750120280, UMLs$Pseudostate.stateMachine)) ==> read( $tarHeap , ppps1750120280, UMLs$Pseudostate.stateMachine) == read( $tarHeap , s, UMLs$State.submachine))
	     	     )
	     )
;
// Property_derived_union_is_read_only 
assert (forall p:ref :: // [UMLs$Property]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Property), p) ==>
	     read( $tarHeap , p, UMLs$Property.isDerivedUnion) ==> read( $tarHeap , p, UMLs$StructuralFeature.isReadOnly))
;
// ExceptionHandler_handler_body_edges 
assert (forall eh:ref :: // [UMLs$ExceptionHandler]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ExceptionHandler), eh) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , eh, UMLs$ExceptionHandler.exceptionInput), UMLs$ActivityNode.incoming))) > 0 ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ExecutableNode), read( $tarHeap , eh, UMLs$ExceptionHandler.handlerBody)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ObjectNode), read( $tarHeap , eh, UMLs$ExceptionHandler.exceptionInput)) ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , eh, UMLs$ExceptionHandler.handlerBody), UMLs$ActivityNode.incoming))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , eh, UMLs$ExceptionHandler.handlerBody), UMLs$ActivityNode.outgoing))) > 0 ==> Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , eh, UMLs$ExceptionHandler.handlerBody), UMLs$ActivityNode.incoming)))  &&  Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , eh, UMLs$ExceptionHandler.handlerBody), UMLs$ActivityNode.outgoing)))  &&  Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , eh, UMLs$ExceptionHandler.exceptionInput), UMLs$ActivityNode.incoming))))
;
// State_submachine_states 
assert (forall s:ref :: // [UMLs$State]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$State), s) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , s, UMLs$State.connection))) > 0 ==> read( $tarHeap , s, UMLs$State.isSubmachineState) ==> Seq#NotEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , s, UMLs$State.connection))))
;
}
