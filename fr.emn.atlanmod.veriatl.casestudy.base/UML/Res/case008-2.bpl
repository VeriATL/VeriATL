implementation driver(){
call init_tar_model();
call CopyAbstraction_matchAll();
call CopyAcceptCallAction_matchAll();
call CopyAcceptEventAction_matchAll();
call CopyActionExecutionSpecification_matchAll();
call CopyActionInputPin_matchAll();
call CopyActivity_matchAll();
call CopyActivityFinalNode_matchAll();
call CopyActivityParameterNode_matchAll();
call CopyActivityPartition_matchAll();
call CopyActor_matchAll();
call CopyAddStructuralFeatureValueAction_matchAll();
call CopyAddVariableValueAction_matchAll();
call CopyAnyReceiveEvent_matchAll();
call CopyArtifact_matchAll();
call CopyAssociation_matchAll();
call CopyAssociationClass_matchAll();
call CopyBehaviorExecutionSpecification_matchAll();
call CopyBroadcastSignalAction_matchAll();
call CopyCallBehaviorAction_matchAll();
call CopyCallEvent_matchAll();
call CopyCallOperationAction_matchAll();
call CopyCentralBufferNode_matchAll();
call CopyChangeEvent_matchAll();
call CopyClass_matchAll();
call CopyClassifierTemplateParameter_matchAll();
call CopyClause_matchAll();
call CopyClearAssociationAction_matchAll();
call CopyClearStructuralFeatureAction_matchAll();
call CopyClearVariableAction_matchAll();
call CopyCollaboration_matchAll();
call CopyCollaborationUse_matchAll();
call CopyCombinedFragment_matchAll();
call CopyComment_matchAll();
call CopyCommunicationPath_matchAll();
call CopyComponent_matchAll();
call CopyComponentRealization_matchAll();
call CopyConditionalNode_matchAll();
call CopyConnectableElementTemplateParameter_matchAll();
call CopyConnectionPointReference_matchAll();
call CopyConnector_matchAll();
call CopyConnectorEnd_matchAll();
call CopyConsiderIgnoreFragment_matchAll();
call CopyConstraint_matchAll();
call CopyContinuation_matchAll();
call CopyControlFlow_matchAll();
call CopyCreateLinkAction_matchAll();
call CopyCreateLinkObjectAction_matchAll();
call CopyCreateObjectAction_matchAll();
call CopyDataStoreNode_matchAll();
call CopyDataType_matchAll();
call CopyDecisionNode_matchAll();
call CopyDependency_matchAll();
call CopyDeployment_matchAll();
call CopyDeploymentSpecification_matchAll();
call CopyDestroyLinkAction_matchAll();
call CopyDestroyObjectAction_matchAll();
call CopyDestructionOccurrenceSpecification_matchAll();
call CopyDevice_matchAll();
call CopyDuration_matchAll();
call CopyDurationConstraint_matchAll();
call CopyDurationInterval_matchAll();
call CopyDurationObservation_matchAll();
call CopyElementImport_matchAll();
call CopyEnumeration_matchAll();
call CopyEnumerationLiteral_matchAll();
call CopyExceptionHandler_matchAll();
call CopyExecutionEnvironment_matchAll();
call CopyExecutionOccurrenceSpecification_matchAll();
call CopyExpansionNode_matchAll();
call CopyExpansionRegion_matchAll();
call CopyExpression_matchAll();
call CopyExtend_matchAll();
call CopyExtension_matchAll();
call CopyExtensionEnd_matchAll();
call CopyExtensionPoint_matchAll();
call CopyFinalState_matchAll();
call CopyFlowFinalNode_matchAll();
call CopyForkNode_matchAll();
call CopyFunctionBehavior_matchAll();
call CopyGate_matchAll();
call CopyGeneralOrdering_matchAll();
call CopyGeneralization_matchAll();
call CopyGeneralizationSet_matchAll();
call CopyImage_matchAll();
call CopyInclude_matchAll();
call CopyInformationFlow_matchAll();
call CopyInformationItem_matchAll();
call CopyInitialNode_matchAll();
call CopyInputPin_matchAll();
call CopyInstanceSpecification_matchAll();
call CopyInstanceValue_matchAll();
call CopyInteraction_matchAll();
call CopyInteractionConstraint_matchAll();
call CopyInteractionOperand_matchAll();
call CopyInteractionUse_matchAll();
call CopyInterface_matchAll();
call CopyInterfaceRealization_matchAll();
call CopyInterruptibleActivityRegion_matchAll();
call CopyInterval_matchAll();
call CopyIntervalConstraint_matchAll();
call CopyJoinNode_matchAll();
call CopyLifeline_matchAll();
call CopyLinkEndCreationData_matchAll();
call CopyLinkEndData_matchAll();
call CopyLinkEndDestructionData_matchAll();
call CopyLiteralBoolean_matchAll();
call CopyLiteralInteger_matchAll();
call CopyLiteralNull_matchAll();
call CopyLiteralReal_matchAll();
call CopyLiteralString_matchAll();
call CopyLiteralUnlimitedNatural_matchAll();
call CopyLoopNode_matchAll();
call CopyManifestation_matchAll();
call CopyMergeNode_matchAll();
call CopyMessage_matchAll();
call CopyMessageOccurrenceSpecification_matchAll();
call CopyModel_matchAll();
call CopyNode_matchAll();
call CopyObjectFlow_matchAll();
call CopyOccurrenceSpecification_matchAll();
call CopyOpaqueAction_matchAll();
call CopyOpaqueBehavior_matchAll();
call CopyOpaqueExpression_matchAll();
call CopyOperation_matchAll();
call CopyOperationTemplateParameter_matchAll();
call CopyOutputPin_matchAll();
call CopyPackage_matchAll();
call CopyPackageImport_matchAll();
call CopyPackageMerge_matchAll();
call CopyParameter_matchAll();
call CopyParameterSet_matchAll();
call CopyPartDecomposition_matchAll();
call CopyPort_matchAll();
call CopyPrimitiveType_matchAll();
call CopyProfile_matchAll();
call CopyProfileApplication_matchAll();
call CopyProperty_matchAll();
call CopyProtocolConformance_matchAll();
call CopyProtocolStateMachine_matchAll();
call CopyProtocolTransition_matchAll();
call CopyPseudostate_matchAll();
call CopyQualifierValue_matchAll();
call CopyRaiseExceptionAction_matchAll();
call CopyReadExtentAction_matchAll();
call CopyReadIsClassifiedObjectAction_matchAll();
call CopyReadLinkAction_matchAll();
call CopyReadLinkObjectEndAction_matchAll();
call CopyReadLinkObjectEndQualifierAction_matchAll();
call CopyReadSelfAction_matchAll();
call CopyReadStructuralFeatureAction_matchAll();
call CopyReadVariableAction_matchAll();
call CopyRealization_matchAll();
call CopyReception_matchAll();
call CopyReclassifyObjectAction_matchAll();
call CopyRedefinableTemplateSignature_matchAll();
call CopyReduceAction_matchAll();
call CopyRegion_matchAll();
call CopyRemoveStructuralFeatureValueAction_matchAll();
call CopyRemoveVariableValueAction_matchAll();
call CopyReplyAction_matchAll();
call CopySendObjectAction_matchAll();
call CopySendSignalAction_matchAll();
call CopySequenceNode_matchAll();
call CopySignal_matchAll();
call CopySignalEvent_matchAll();
call CopySlot_matchAll();
call CopyStartClassifierBehaviorAction_matchAll();
call CopyStartObjectBehaviorAction_matchAll();
call CopyState_matchAll();
call CopyStateInvariant_matchAll();
call CopyStateMachine_matchAll();
call CopyStereotype_matchAll();
call CopyStringExpression_matchAll();
call CopyStructuredActivityNode_matchAll();
call CopySubstitution_matchAll();
call CopyTemplateBinding_matchAll();
call CopyTemplateParameter_matchAll();
call CopyTemplateParameterSubstitution_matchAll();
call CopyTemplateSignature_matchAll();
call CopyTestIdentityAction_matchAll();
call CopyTimeConstraint_matchAll();
call CopyTimeEvent_matchAll();
call CopyTimeExpression_matchAll();
call CopyTimeInterval_matchAll();
call CopyTimeObservation_matchAll();
call CopyTransition_matchAll();
call CopyTrigger_matchAll();
call CopyUnmarshallAction_matchAll();
call CopyUsage_matchAll();
call CopyUseCase_matchAll();
call CopyValuePin_matchAll();
call CopyValueSpecificationAction_matchAll();
call CopyVariable_matchAll();
call CopyAbstraction_applyAll();
call CopyAcceptCallAction_applyAll();
call CopyAcceptEventAction_applyAll();
call CopyActionExecutionSpecification_applyAll();
call CopyActionInputPin_applyAll();
call CopyActivity_applyAll();
call CopyActivityFinalNode_applyAll();
call CopyActivityParameterNode_applyAll();
call CopyActivityPartition_applyAll();
call CopyActor_applyAll();
call CopyAddStructuralFeatureValueAction_applyAll();
call CopyAddVariableValueAction_applyAll();
call CopyAnyReceiveEvent_applyAll();
call CopyArtifact_applyAll();
call CopyAssociation_applyAll();
call CopyAssociationClass_applyAll();
call CopyBehaviorExecutionSpecification_applyAll();
call CopyBroadcastSignalAction_applyAll();
call CopyCallBehaviorAction_applyAll();
call CopyCallEvent_applyAll();
call CopyCallOperationAction_applyAll();
call CopyCentralBufferNode_applyAll();
call CopyChangeEvent_applyAll();
call CopyClass_applyAll();
call CopyClassifierTemplateParameter_applyAll();
call CopyClause_applyAll();
call CopyClearAssociationAction_applyAll();
call CopyClearStructuralFeatureAction_applyAll();
call CopyClearVariableAction_applyAll();
call CopyCollaboration_applyAll();
call CopyCollaborationUse_applyAll();
call CopyCombinedFragment_applyAll();
call CopyComment_applyAll();
call CopyCommunicationPath_applyAll();
call CopyComponent_applyAll();
call CopyComponentRealization_applyAll();
call CopyConditionalNode_applyAll();
call CopyConnectableElementTemplateParameter_applyAll();
call CopyConnectionPointReference_applyAll();
call CopyConnector_applyAll();
call CopyConnectorEnd_applyAll();
call CopyConsiderIgnoreFragment_applyAll();
call CopyConstraint_applyAll();
call CopyContinuation_applyAll();
call CopyControlFlow_applyAll();
call CopyCreateLinkAction_applyAll();
call CopyCreateLinkObjectAction_applyAll();
call CopyCreateObjectAction_applyAll();
call CopyDataStoreNode_applyAll();
call CopyDataType_applyAll();
call CopyDecisionNode_applyAll();
call CopyDependency_applyAll();
call CopyDeployment_applyAll();
call CopyDeploymentSpecification_applyAll();
call CopyDestroyLinkAction_applyAll();
call CopyDestroyObjectAction_applyAll();
call CopyDestructionOccurrenceSpecification_applyAll();
call CopyDevice_applyAll();
call CopyDuration_applyAll();
call CopyDurationConstraint_applyAll();
call CopyDurationInterval_applyAll();
call CopyDurationObservation_applyAll();
call CopyElementImport_applyAll();
call CopyEnumeration_applyAll();
call CopyEnumerationLiteral_applyAll();
call CopyExceptionHandler_applyAll();
call CopyExecutionEnvironment_applyAll();
call CopyExecutionOccurrenceSpecification_applyAll();
call CopyExpansionNode_applyAll();
call CopyExpansionRegion_applyAll();
call CopyExpression_applyAll();
call CopyExtend_applyAll();
call CopyExtension_applyAll();
call CopyExtensionEnd_applyAll();
call CopyExtensionPoint_applyAll();
call CopyFinalState_applyAll();
call CopyFlowFinalNode_applyAll();
call CopyForkNode_applyAll();
call CopyFunctionBehavior_applyAll();
call CopyGate_applyAll();
call CopyGeneralOrdering_applyAll();
call CopyGeneralization_applyAll();
call CopyGeneralizationSet_applyAll();
call CopyImage_applyAll();
call CopyInclude_applyAll();
call CopyInformationFlow_applyAll();
call CopyInformationItem_applyAll();
call CopyInitialNode_applyAll();
call CopyInputPin_applyAll();
call CopyInstanceSpecification_applyAll();
call CopyInstanceValue_applyAll();
call CopyInteraction_applyAll();
call CopyInteractionConstraint_applyAll();
call CopyInteractionOperand_applyAll();
call CopyInteractionUse_applyAll();
call CopyInterface_applyAll();
call CopyInterfaceRealization_applyAll();
call CopyInterruptibleActivityRegion_applyAll();
call CopyInterval_applyAll();
call CopyIntervalConstraint_applyAll();
call CopyJoinNode_applyAll();
call CopyLifeline_applyAll();
call CopyLinkEndCreationData_applyAll();
call CopyLinkEndData_applyAll();
call CopyLinkEndDestructionData_applyAll();
call CopyLiteralBoolean_applyAll();
call CopyLiteralInteger_applyAll();
call CopyLiteralNull_applyAll();
call CopyLiteralReal_applyAll();
call CopyLiteralString_applyAll();
call CopyLiteralUnlimitedNatural_applyAll();
call CopyLoopNode_applyAll();
call CopyManifestation_applyAll();
call CopyMergeNode_applyAll();
call CopyMessage_applyAll();
call CopyMessageOccurrenceSpecification_applyAll();
call CopyModel_applyAll();
call CopyNode_applyAll();
call CopyObjectFlow_applyAll();
call CopyOccurrenceSpecification_applyAll();
call CopyOpaqueAction_applyAll();
call CopyOpaqueBehavior_applyAll();
call CopyOpaqueExpression_applyAll();
call CopyOperation_applyAll();
call CopyOperationTemplateParameter_applyAll();
call CopyOutputPin_applyAll();
call CopyPackage_applyAll();
call CopyPackageImport_applyAll();
call CopyPackageMerge_applyAll();
call CopyParameter_applyAll();
call CopyParameterSet_applyAll();
call CopyPartDecomposition_applyAll();
call CopyPort_applyAll();
call CopyPrimitiveType_applyAll();
call CopyProfile_applyAll();
call CopyProfileApplication_applyAll();
call CopyProperty_applyAll();
call CopyProtocolConformance_applyAll();
call CopyProtocolStateMachine_applyAll();
call CopyProtocolTransition_applyAll();
call CopyPseudostate_applyAll();
call CopyQualifierValue_applyAll();
call CopyRaiseExceptionAction_applyAll();
call CopyReadExtentAction_applyAll();
call CopyReadIsClassifiedObjectAction_applyAll();
call CopyReadLinkAction_applyAll();
call CopyReadLinkObjectEndAction_applyAll();
call CopyReadLinkObjectEndQualifierAction_applyAll();
call CopyReadSelfAction_applyAll();
call CopyReadStructuralFeatureAction_applyAll();
call CopyReadVariableAction_applyAll();
call CopyRealization_applyAll();
call CopyReception_applyAll();
call CopyReclassifyObjectAction_applyAll();
call CopyRedefinableTemplateSignature_applyAll();
call CopyReduceAction_applyAll();
call CopyRegion_applyAll();
call CopyRemoveStructuralFeatureValueAction_applyAll();
call CopyRemoveVariableValueAction_applyAll();
call CopyReplyAction_applyAll();
call CopySendObjectAction_applyAll();
call CopySendSignalAction_applyAll();
call CopySequenceNode_applyAll();
call CopySignal_applyAll();
call CopySignalEvent_applyAll();
call CopySlot_applyAll();
call CopyStartClassifierBehaviorAction_applyAll();
call CopyStartObjectBehaviorAction_applyAll();
call CopyState_applyAll();
call CopyStateInvariant_applyAll();
call CopyStateMachine_applyAll();
call CopyStereotype_applyAll();
call CopyStringExpression_applyAll();
call CopyStructuredActivityNode_applyAll();
call CopySubstitution_applyAll();
call CopyTemplateBinding_applyAll();
call CopyTemplateParameter_applyAll();
call CopyTemplateParameterSubstitution_applyAll();
call CopyTemplateSignature_applyAll();
call CopyTestIdentityAction_applyAll();
call CopyTimeConstraint_applyAll();
call CopyTimeEvent_applyAll();
call CopyTimeExpression_applyAll();
call CopyTimeInterval_applyAll();
call CopyTimeObservation_applyAll();
call CopyTransition_applyAll();
call CopyTrigger_applyAll();
call CopyUnmarshallAction_applyAll();
call CopyUsage_applyAll();
call CopyUseCase_applyAll();
call CopyValuePin_applyAll();
call CopyValueSpecificationAction_applyAll();
call CopyVariable_applyAll();


// CommunicationPath_association_ends 
assert (forall cp:ref :: // [UMLs$CommunicationPath]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$CommunicationPath), cp) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , cp, UMLs$Association.endType))) > 0 ==> (forall t1_:ref :: // [UMLs$Type]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , cp, UMLs$Association.endType)), $Box(t1_)) ==>
	     	     dtype(t1_) <: UMLs$DeploymentTarget)
	     )
;
// ClassifierTemplateParameter_has_constraining_classifier 
assert (forall ctp:ref :: // [UMLs$ClassifierTemplateParameter]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ClassifierTemplateParameter), ctp) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , ctp, UMLs$ClassifierTemplateParameter.constrainingClassifier))) > 0 ==> read( $tarHeap , ctp, UMLs$ClassifierTemplateParameter.allowSubstitutable) ==> Seq#NotEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , ctp, UMLs$ClassifierTemplateParameter.constrainingClassifier))))
;
// ActivityParameterNode_no_edges 
assert (forall apn:ref :: // [UMLs$ActivityParameterNode]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ActivityParameterNode), apn) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , apn, UMLs$ActivityNode.incoming))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , apn, UMLs$ActivityNode.outgoing))) > 0 ==> Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , apn, UMLs$ActivityNode.incoming)))  ||  Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , apn, UMLs$ActivityNode.outgoing))))
;
// ReadLinkObjectEndAction_type_of_object 
assert (forall rloea:ref :: // [UMLs$ReadLinkObjectEndAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ReadLinkObjectEndAction), rloea) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Association), read( $tarHeap , read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.end), UMLs$Property.association)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$InputPin), read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.object)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Property), read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.end)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Type), read( $tarHeap , read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.object), UMLs$TypedElement.type)) ==> read( $tarHeap , read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.object), UMLs$TypedElement.type) == read( $tarHeap , read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.end), UMLs$Property.association))
;
// AcceptEventAction_no_input_pins 
assert (forall aea:ref :: // [UMLs$AcceptEventAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$AcceptEventAction), aea) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , aea, UMLs$Action.input))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , aea, UMLs$Action.input))) == 0)
;

// ValuePin_no_incoming_edges 
assert (forall vp:ref :: // [UMLs$ValuePin]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ValuePin), vp) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , vp, UMLs$ActivityNode.incoming))) > 0 ==> Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , vp, UMLs$ActivityNode.incoming))))
;
// Reception_same_name_as_signal 
assert (forall r:ref :: // [UMLs$Reception]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Reception), r) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Signal), read( $tarHeap , r, UMLs$Reception.signal)) ==> read( $tarHeap , r, UMLs$NamedElement.name) == read( $tarHeap , read( $tarHeap , r, UMLs$Reception.signal), UMLs$NamedElement.name)
	     )
;
// Node_internal_structure 
assert (forall n:ref :: // [UMLs$Node]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Node), n) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , n, UMLs$StructuredClassifier.part))) > 0 ==> (forall p1_:ref :: // [UMLs$Property]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , n, UMLs$StructuredClassifier.part)), $Box(p1_)) ==>
	     	     dtype(p1_) <: UMLs$Node)
	     )
;
// ProtocolStateMachine_protocol_transitions 
assert (forall psm:ref :: // [UMLs$ProtocolStateMachine]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ProtocolStateMachine), psm) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , psm, UMLs$StateMachine.region))) > 0 ==> (forall rr:ref :: // [UMLs$Region]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , psm, UMLs$StateMachine.region)), $Box(rr)) ==>
	     	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , rr, UMLs$Region.transition))) > 0 ==> (forall tt:ref :: // [UMLs$Transition]
	     	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , rr, UMLs$Region.transition)), $Box(tt)) ==>
	     	     	     dtype(tt) == UMLs$ProtocolTransition)
	     	     )
	     )
;
// FinalState_no_regions 
assert (forall fs:ref :: // [UMLs$FinalState]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$FinalState), fs) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , fs, UMLs$State.region))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , fs, UMLs$State.region))) == 0)
;
// TemplateBinding_parameter_substitution_formal 
assert (forall tb:ref :: // [UMLs$TemplateBinding]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$TemplateBinding), tb) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$TemplateSignature), read( $tarHeap , tb, UMLs$TemplateBinding.signature)) ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , tb, UMLs$TemplateBinding.signature), UMLs$TemplateSignature.parameter))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , tb, UMLs$TemplateBinding.parameterSubstitution))) > 0 ==> (forall tpsb:ref :: // [UMLs$TemplateParameterSubstitution]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , tb, UMLs$TemplateBinding.parameterSubstitution)), $Box(tpsb)) ==>
	     	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$TemplateParameter), read( $tarHeap , tpsb, UMLs$TemplateParameterSubstitution.formal)) ==> Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , tb, UMLs$TemplateBinding.signature), UMLs$TemplateSignature.parameter)), $Box(read( $tarHeap , tpsb, UMLs$TemplateParameterSubstitution.formal))))
	     )
;
// FinalState_no_outgoing_transitions 
assert (forall fs:ref :: // [UMLs$FinalState]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$FinalState), fs) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , fs, UMLs$Vertex.outgoing))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , fs, UMLs$Vertex.outgoing))) == 0)
;
// ReadLinkObjectEndAction_type_of_result 
assert (forall rloea:ref :: // [UMLs$ReadLinkObjectEndAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ReadLinkObjectEndAction), rloea) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$OutputPin), read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.result)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Property), read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.end)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Type), read( $tarHeap , read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.end), UMLs$TypedElement.type)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Type), read( $tarHeap , read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.result), UMLs$TypedElement.type)) ==> read( $tarHeap , read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.result), UMLs$TypedElement.type) == read( $tarHeap , read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.end), UMLs$TypedElement.type))
;
// Pin_not_unique 
assert (forall p:ref :: // [UMLs$Pin]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Pin), p) ==>
	     !(read( $tarHeap , p, UMLs$MultiplicityElement.isUnique)))
;
// InitialNode_control_edges 
assert (forall _in:ref :: // [UMLs$InitialNode]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$InitialNode), _in) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , _in, UMLs$ActivityNode.outgoing))) > 0 ==> (forall ae1_:ref :: // [UMLs$ActivityEdge]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , _in, UMLs$ActivityNode.outgoing)), $Box(ae1_)) ==>
	     	     dtype(ae1_) <: UMLs$ControlFlow)
	     )
;
// Property_derived_union_is_derived 
assert (forall p:ref :: // [UMLs$Property]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Property), p) ==>
	     read( $tarHeap , p, UMLs$Property.isDerivedUnion) ==> read( $tarHeap , p, UMLs$Property.isDerived))
;
// ReadLinkObjectEndAction_ends_of_association 
assert (forall rloea:ref :: // [UMLs$ReadLinkObjectEndAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ReadLinkObjectEndAction), rloea) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Property), read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.end)) ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.end), UMLs$Property.association), UMLs$Association.memberEnd))) > 0 ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Association), read( $tarHeap , read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.end), UMLs$Property.association)) ==> (forall pe:ref :: // [UMLs$Property]
	     	   Seq#Contains(Seq#FromArray( $tarHeap , read( $tarHeap , read( $tarHeap , read( $tarHeap , rloea, UMLs$ReadLinkObjectEndAction.end), UMLs$Property.association), UMLs$Association.memberEnd)), $Box(pe)) ==>
	     	     !(read( $tarHeap , pe, UMLs$Feature.isStatic)))
	     )
;
// InformationItem_has_no 
assert (forall ii:ref :: // [UMLs$InformationItem]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$InformationItem), ii) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , ii, UMLs$Classifier.generalization))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , ii, UMLs$Classifier.feature))) > 0 ==> Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , ii, UMLs$Classifier.generalization)))  &&  Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , ii, UMLs$Classifier.feature))))
;
// Parameter_stream_and_exception 
assert (forall p:ref :: // [UMLs$Parameter]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Parameter), p) ==>
	     !(read( $tarHeap , p, UMLs$Parameter.isException)  &&  read( $tarHeap , p, UMLs$Parameter.isStream)))
;
// ReadExtentAction_type_is_classifier 
assert (forall rea:ref :: // [UMLs$ReadExtentAction]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ReadExtentAction), rea) ==>
	     Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Classifier), read( $tarHeap , rea, UMLs$ReadExtentAction.classifier)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$OutputPin), read( $tarHeap , rea, UMLs$ReadExtentAction.result)) ==> Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$Type), read( $tarHeap , read( $tarHeap , rea, UMLs$ReadExtentAction.result), UMLs$TypedElement.type)) ==> read( $tarHeap , read( $tarHeap , rea, UMLs$ReadExtentAction.result), UMLs$TypedElement.type) == read( $tarHeap , rea, UMLs$ReadExtentAction.classifier))
;
// InitialNode_no_incoming_edges 
assert (forall _in:ref :: // [UMLs$InitialNode]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$InitialNode), _in) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , _in, UMLs$ActivityNode.incoming))) > 0 ==> Seq#IsEmpty(Seq#FromArray( $tarHeap , read( $tarHeap , _in, UMLs$ActivityNode.incoming))))
;
// MergeNode_one_outgoing_edge 
assert (forall mn:ref :: // [UMLs$MergeNode]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$MergeNode), mn) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , mn, UMLs$ActivityNode.outgoing))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , mn, UMLs$ActivityNode.outgoing))) == 1)
;
// DurationConstraint_has_one_or_two_constrainedElements 
assert (forall dc:ref :: // [UMLs$DurationConstraint]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$DurationConstraint), dc) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , dc, UMLs$Constraint.constrainedElement))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , dc, UMLs$Constraint.constrainedElement))) == 1  ||  Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , dc, UMLs$Constraint.constrainedElement))) == 2)
;
// State_submachine_or_regions 
assert (forall s:ref :: // [UMLs$State]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$State), s) ==>
	     read( $tarHeap , s, UMLs$State.isComposite) ==> !(read( $tarHeap , s, UMLs$State.isSubmachineState)))
;
// ForkNode_one_incoming_edge 
assert (forall fn:ref :: // [UMLs$ForkNode]
	   Seq#Contains(Fun#LIB#AllInstanceFrom( $tarHeap , UMLs$ForkNode), fn) ==>
	     Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , fn, UMLs$ActivityNode.incoming))) > 0 ==> Seq#Length(Seq#FromArray( $tarHeap , read( $tarHeap , fn, UMLs$ActivityNode.incoming))) == 1)
;
}
