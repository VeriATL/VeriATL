=== Case1

a: InformationFlow_convey_classifiers: 28 rules - 10s
b: InformationItem_not_instantiable: 1 rules - 7s
a && b: 28 rules - 13s

Fact: 
- a && b: overlaped on 1 rule, additional 0 rules
- a && b < a+b

=== Case2
a: InformationItem_not_instantiable: 1 rules - 10s
b: Pin_not_unique: 4 rules - 12 s
a && b : 5 rules : 15s

Fact: 
- a && b: overlaped 0 rules, additional 4 rules
- a && b < a + b

=== Case3
a: InformationFlow_convey_classifiers: 28 rules - 10s
b: InformationItem_has_no: 8 rules - 9s
a && b: 35 rules - 14s

Fact: 
- a && b: overlaped on 1 rule, additional 7 rules
- a && b < a + b

=== Case 4
a: Constraint_not_apply_to_self: 193 rules - 53s ~ 61s
b: InformationItem_not_instantiable: 1 rules - 7s ~ 8s
a && b: 193 rules - 69s ~ 76s

Fact: 
- a && b: overlaped 0 rules
- a && b > a + b


=== Case 5
a: InformationItem_not_instantiable: full rules - 55s
b: InformationItem_not_instantiable: 1 rules - 7s

Fact: 
- benefit of slicing

=== Case 6
a: InformationItem_not_instantiable: full rules - 52s
b: InformationItem_not_instantiable+Constraint_not_apply_to_self:  full rules - 62s
c: InformationItem_not_instantiable+ValuePin_no_incoming_edges: full rules - 56s

Fact: 
- Look `a` and `b` 10s is how much it takes to verify another post (not a complex one), under the full rules setting.
- Look `b` and `c`, seems the added post does matter to how to schedule these proofs,

=== Case 7
a: Full post + full rules - 70s - out of memory - inconclusive

Fact: 
- we cannot verify everything together

=== Case 8
a: Half post(40) + full rules - 60s - out of memory - inconclusive
b: the other half post(25) + full rules - 60s - out of memory - inconclusive

Fact: 
- bulk split does not help


=== Case 9
find a case where assertion `A` ==> `B`



=== Conclusion

Assumption: 
- if no. of involved rules is small, we can combine them until we meet a standard.