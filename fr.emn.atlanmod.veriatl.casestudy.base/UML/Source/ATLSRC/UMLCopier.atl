module Copy;
create OUT : UMLs from IN : UML;

rule CopyComment {
 from
  s : UML!Comment
  (
   s.oclIsTypeOf(UML!Comment)
  )
 to
  t : UMLs!Comment (
   body <- s.body,
   annotatedElement <- s.annotatedElement,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment
  )
}

rule CopyPackage {
 from
  s : UML!Package
  (
   s.oclIsTypeOf(UML!Package)
  )
 to
  t : UMLs!Package (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   ownedType <- s.ownedType,
   packageMerge <- s.packageMerge,
   packagedElement <- s.packagedElement,
   nestedPackage <- s.nestedPackage,
   nestingPackage <- s.nestingPackage,
   profileApplication <- s.profileApplication,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyDependency {
 from
  s : UML!Dependency
  (
   s.oclIsTypeOf(UML!Dependency)
  )
 to
  t : UMLs!Dependency (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   supplier <- s.supplier,
   client <- s.client,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyElementImport {
 from
  s : UML!ElementImport
  (
   s.oclIsTypeOf(UML!ElementImport)
  )
 to
  t : UMLs!ElementImport (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   visibility <- s.visibility,
   alias <- s.alias,
   importedElement <- s.importedElement,
   importingNamespace <- s.importingNamespace
  )
}

rule CopyPackageImport {
 from
  s : UML!PackageImport
  (
   s.oclIsTypeOf(UML!PackageImport)
  )
 to
  t : UMLs!PackageImport (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   visibility <- s.visibility,
   importedPackage <- s.importedPackage,
   importingNamespace <- s.importingNamespace
  )
}

rule CopyConstraint {
 from
  s : UML!Constraint
  (
   s.oclIsTypeOf(UML!Constraint)
  )
 to
  t : UMLs!Constraint (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   constrainedElement <- s.constrainedElement,
   specification <- s.specification,
   context <- s.context,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyAssociation {
 from
  s : UML!Association
  (
   s.oclIsTypeOf(UML!Association)
  )
 to
  t : UMLs!Association (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   relatedElement <- s.relatedElement,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   ownedEnd <- s.ownedEnd,
   memberEnd <- s.memberEnd,
   isDerived <- s.isDerived,
   endType <- s.endType,
   navigableOwnedEnd <- s.navigableOwnedEnd,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyTemplateBinding {
 from
  s : UML!TemplateBinding
  (
   s.oclIsTypeOf(UML!TemplateBinding)
  )
 to
  t : UMLs!TemplateBinding (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   signature <- s.signature,
   parameterSubstitution <- s.parameterSubstitution,
   boundElement <- s.boundElement
  )
}

rule CopyTemplateSignature {
 from
  s : UML!TemplateSignature
  (
   s.oclIsTypeOf(UML!TemplateSignature)
  )
 to
  t : UMLs!TemplateSignature (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   parameter <- s.parameter,
   ownedParameter <- s.ownedParameter,
   template <- s.template
  )
}

rule CopyTemplateParameter {
 from
  s : UML!TemplateParameter
  (
   s.oclIsTypeOf(UML!TemplateParameter)
  )
 to
  t : UMLs!TemplateParameter (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   parameteredElement <- s.parameteredElement,
   ownedParameteredElement <- s.ownedParameteredElement,
   default <- s.default,
   ownedDefault <- s.ownedDefault
  )
}

rule CopyTemplateParameterSubstitution {
 from
  s : UML!TemplateParameterSubstitution
  (
   s.oclIsTypeOf(UML!TemplateParameterSubstitution)
  )
 to
  t : UMLs!TemplateParameterSubstitution (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   formal <- s.formal,
   actual <- s.actual,
   ownedActual <- s.ownedActual,
   templateBinding <- s.templateBinding
  )
}

rule CopyGeneralization {
 from
  s : UML!Generalization
  (
   s.oclIsTypeOf(UML!Generalization)
  )
 to
  t : UMLs!Generalization (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   isSubstitutable <- s.isSubstitutable,
   general <- s.general,
   generalizationSet <- s.generalizationSet,
   specific <- s.specific
  )
}

rule CopyGeneralizationSet {
 from
  s : UML!GeneralizationSet
  (
   s.oclIsTypeOf(UML!GeneralizationSet)
  )
 to
  t : UMLs!GeneralizationSet (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isCovering <- s.isCovering,
   isDisjoint <- s.isDisjoint,
   powertype <- s.powertype,
   generalization <- s.generalization
  )
}

rule CopySubstitution {
 from
  s : UML!Substitution
  (
   s.oclIsTypeOf(UML!Substitution)
  )
 to
  t : UMLs!Substitution (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   supplier <- s.supplier,
   client <- s.client,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   contract <- s.contract,
   substitutingClassifier <- s.substitutingClassifier,
   mapping <- s.mapping
  )
}

rule CopyRealization {
 from
  s : UML!Realization
  (
   s.oclIsTypeOf(UML!Realization)
  )
 to
  t : UMLs!Realization (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   supplier <- s.supplier,
   client <- s.client,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   mapping <- s.mapping
  )
}

rule CopyAbstraction {
 from
  s : UML!Abstraction
  (
   s.oclIsTypeOf(UML!Abstraction)
  )
 to
  t : UMLs!Abstraction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   supplier <- s.supplier,
   client <- s.client,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   mapping <- s.mapping
  )
}

rule CopyOpaqueExpression {
 from
  s : UML!OpaqueExpression
  (
   s.oclIsTypeOf(UML!OpaqueExpression)
  )
 to
  t : UMLs!OpaqueExpression (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   body <- s.body,
   language <- s.language,
   result <- s.result,
   behavior <- s.behavior
  )
}

rule CopyParameter {
 from
  s : UML!Parameter
  (
   s.oclIsTypeOf(UML!Parameter)
  )
 to
  t : UMLs!Parameter (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   parameterSet <- s.parameterSet,
   operation <- s.operation,
   direction <- s.direction,
   default <- s.default,
   defaultValue <- s.defaultValue,
   isException <- s.isException,
   isStream <- s.isStream,
   effect <- s.effect,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   upper <- s.upper,
   lower <- s.lower,
   upperValue <- s.upperValue,
   lowerValue <- s.lowerValue,
   end <- s.end
  )
}

rule CopyConnectorEnd {
 from
  s : UML!ConnectorEnd
  (
   s.oclIsTypeOf(UML!ConnectorEnd)
  )
 to
  t : UMLs!ConnectorEnd (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   upper <- s.upper,
   lower <- s.lower,
   upperValue <- s.upperValue,
   lowerValue <- s.lowerValue,
   definingEnd <- s.definingEnd,
   role <- s.role,
   partWithPort <- s.partWithPort
  )
}

rule CopyProperty {
 from
  s : UML!Property
  (
   s.oclIsTypeOf(UML!Property)
  )
 to
  t : UMLs!Property (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isStatic <- s.isStatic,
   featuringClassifier <- s.featuringClassifier,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   upper <- s.upper,
   lower <- s.lower,
   upperValue <- s.upperValue,
   lowerValue <- s.lowerValue,
   end <- s.end,
   class <- s.class,
   isDerived <- s.isDerived,
   isDerivedUnion <- s.isDerivedUnion,
   default <- s.default,
   aggregation <- s.aggregation,
   isComposite <- s.isComposite,
   redefinedProperty <- s.redefinedProperty,
   defaultValue <- s.defaultValue,
   opposite <- s.opposite,
   subsettedProperty <- s.subsettedProperty,
   qualifier <- s.qualifier,
   deployment <- s.deployment,
   deployedElement <- s.deployedElement,
   isReadOnly <- s.isReadOnly
  )
}

rule CopyDeployment {
 from
  s : UML!Deployment
  (
   s.oclIsTypeOf(UML!Deployment)
  )
 to
  t : UMLs!Deployment (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   supplier <- s.supplier,
   client <- s.client,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   deployedArtifact <- s.deployedArtifact,
   configuration <- s.configuration,
   location <- s.location
  )
}

rule CopyDeploymentSpecification {
 from
  s : UML!DeploymentSpecification
  (
   s.oclIsTypeOf(UML!DeploymentSpecification)
  )
 to
  t : UMLs!DeploymentSpecification (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   deploymentLocation <- s.deploymentLocation,
   executionLocation <- s.executionLocation,
   deployment <- s.deployment,
   fileName <- s.fileName,
   nestedArtifact <- s.nestedArtifact,
   manifestation <- s.manifestation,
   ownedOperation <- s.ownedOperation,
   ownedAttribute <- s.ownedAttribute
  )
}

rule CopyArtifact {
 from
  s : UML!Artifact
  (
   s.oclIsTypeOf(UML!Artifact)
  )
 to
  t : UMLs!Artifact (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   fileName <- s.fileName,
   nestedArtifact <- s.nestedArtifact,
   manifestation <- s.manifestation,
   ownedOperation <- s.ownedOperation,
   ownedAttribute <- s.ownedAttribute
  )
}

rule CopyManifestation {
 from
  s : UML!Manifestation
  (
   s.oclIsTypeOf(UML!Manifestation)
  )
 to
  t : UMLs!Manifestation (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   supplier <- s.supplier,
   client <- s.client,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   mapping <- s.mapping,
   utilizedElement <- s.utilizedElement
  )
}

rule CopyOperation {
 from
  s : UML!Operation
  (
   s.oclIsTypeOf(UML!Operation)
  )
 to
  t : UMLs!Operation (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isStatic <- s.isStatic,
   featuringClassifier <- s.featuringClassifier,
   isQuery <- s.isQuery,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   lower <- s.lower,
   upper <- s.upper,
   precondition <- s.precondition,
   postcondition <- s.postcondition,
   redefinedOperation <- s.redefinedOperation,
   bodyCondition <- s.bodyCondition,
   type <- s.type,
   ownedParameter <- s.ownedParameter,
   isAbstract <- s.isAbstract,
   method <- s.method,
   concurrency <- s.concurrency,
   raisedException <- s.raisedException,
   ownedParameterSet <- s.ownedParameterSet
  )
}

rule CopyClass {
 from
  s : UML!Class
  (
   s.oclIsTypeOf(UML!Class)
  )
 to
  t : UMLs!Class (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector
  )
}

rule CopyInterfaceRealization {
 from
  s : UML!InterfaceRealization
  (
   s.oclIsTypeOf(UML!InterfaceRealization)
  )
 to
  t : UMLs!InterfaceRealization (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   supplier <- s.supplier,
   client <- s.client,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   mapping <- s.mapping,
   contract <- s.contract,
   implementingClassifier <- s.implementingClassifier
  )
}

rule CopyInterface {
 from
  s : UML!Interface
  (
   s.oclIsTypeOf(UML!Interface)
  )
 to
  t : UMLs!Interface (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   ownedAttribute <- s.ownedAttribute,
   ownedOperation <- s.ownedOperation,
   nestedClassifier <- s.nestedClassifier,
   redefinedInterface <- s.redefinedInterface,
   ownedReception <- s.ownedReception,
   protocol <- s.protocol
  )
}

rule CopyReception {
 from
  s : UML!Reception
  (
   s.oclIsTypeOf(UML!Reception)
  )
 to
  t : UMLs!Reception (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   isStatic <- s.isStatic,
   featuringClassifier <- s.featuringClassifier,
   ownedParameter <- s.ownedParameter,
   isAbstract <- s.isAbstract,
   method <- s.method,
   concurrency <- s.concurrency,
   raisedException <- s.raisedException,
   ownedParameterSet <- s.ownedParameterSet,
   signal <- s.signal
  )
}

rule CopySignal {
 from
  s : UML!Signal
  (
   s.oclIsTypeOf(UML!Signal)
  )
 to
  t : UMLs!Signal (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   ownedAttribute <- s.ownedAttribute
  )
}

rule CopyProtocolStateMachine {
 from
  s : UML!ProtocolStateMachine
  (
   s.oclIsTypeOf(UML!ProtocolStateMachine)
  )
 to
  t : UMLs!ProtocolStateMachine (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isReentrant <- s.isReentrant,
   redefinedBehavior <- s.redefinedBehavior,
   ownedParameter <- s.ownedParameter,
   context <- s.context,
   precondition <- s.precondition,
   postcondition <- s.postcondition,
   ownedParameterSet <- s.ownedParameterSet,
   specification <- s.specification,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   conformance <- s.conformance,
   region <- s.region,
   submachineState <- s.submachineState,
   connectionPoint <- s.connectionPoint,
   extendedStateMachine <- s.extendedStateMachine,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector
  )
}

rule CopyStateMachine {
 from
  s : UML!StateMachine
  (
   s.oclIsTypeOf(UML!StateMachine)
  )
 to
  t : UMLs!StateMachine (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isReentrant <- s.isReentrant,
   redefinedBehavior <- s.redefinedBehavior,
   ownedParameter <- s.ownedParameter,
   context <- s.context,
   precondition <- s.precondition,
   postcondition <- s.postcondition,
   ownedParameterSet <- s.ownedParameterSet,
   specification <- s.specification,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   region <- s.region,
   submachineState <- s.submachineState,
   connectionPoint <- s.connectionPoint,
   extendedStateMachine <- s.extendedStateMachine,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector
  )
}

rule CopyRegion {
 from
  s : UML!Region
  (
   s.oclIsTypeOf(UML!Region)
  )
 to
  t : UMLs!Region (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   subvertex <- s.subvertex,
   transition <- s.transition,
   state <- s.state,
   extendedRegion <- s.extendedRegion,
   stateMachine <- s.stateMachine
  )
}

rule CopyTransition {
 from
  s : UML!Transition
  (
   s.oclIsTypeOf(UML!Transition)
  )
 to
  t : UMLs!Transition (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   kind <- s.kind,
   container <- s.container,
   source <- s.source,
   target <- s.target,
   redefinedTransition <- s.redefinedTransition,
   guard <- s.guard,
   effect <- s.effect,
   trigger <- s.trigger
  )
}

rule CopyTrigger {
 from
  s : UML!Trigger
  (
   s.oclIsTypeOf(UML!Trigger)
  )
 to
  t : UMLs!Trigger (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   event <- s.event,
   port <- s.port
  )
}

rule CopyPort {
 from
  s : UML!Port
  (
   s.oclIsTypeOf(UML!Port)
  )
 to
  t : UMLs!Port (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isStatic <- s.isStatic,
   featuringClassifier <- s.featuringClassifier,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   upper <- s.upper,
   lower <- s.lower,
   upperValue <- s.upperValue,
   lowerValue <- s.lowerValue,
   end <- s.end,
   class <- s.class,
   isDerived <- s.isDerived,
   isDerivedUnion <- s.isDerivedUnion,
   default <- s.default,
   aggregation <- s.aggregation,
   isComposite <- s.isComposite,
   redefinedProperty <- s.redefinedProperty,
   defaultValue <- s.defaultValue,
   opposite <- s.opposite,
   subsettedProperty <- s.subsettedProperty,
   qualifier <- s.qualifier,
   deployment <- s.deployment,
   deployedElement <- s.deployedElement,
   isBehavior <- s.isBehavior,
   isService <- s.isService,
   required <- s.required,
   redefinedPort <- s.redefinedPort,
   provided <- s.provided,
   protocol <- s.protocol,
   isReadOnly <- s.isReadOnly
  )
}

rule CopyState {
 from
  s : UML!State
  (
   s.oclIsTypeOf(UML!State)
  )
 to
  t : UMLs!State (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   container <- s.container,
   isComposite <- s.isComposite,
   isOrthogonal <- s.isOrthogonal,
   isSimple <- s.isSimple,
   isSubmachineState <- s.isSubmachineState,
   submachine <- s.submachine,
   connection <- s.connection,
   connectionPoint <- s.connectionPoint,
   redefinedState <- s.redefinedState,
   stateInvariant <- s.stateInvariant,
   entry <- s.entry,
   exit <- s.exit,
   doActivity <- s.doActivity,
   deferrableTrigger <- s.deferrableTrigger,
   region <- s.region
  )
}

rule CopyConnectionPointReference {
 from
  s : UML!ConnectionPointReference
  (
   s.oclIsTypeOf(UML!ConnectionPointReference)
  )
 to
  t : UMLs!ConnectionPointReference (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   container <- s.container,
   entry <- s.entry,
   exit <- s.exit,
   state <- s.state
  )
}

rule CopyPseudostate {
 from
  s : UML!Pseudostate
  (
   s.oclIsTypeOf(UML!Pseudostate)
  )
 to
  t : UMLs!Pseudostate (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   container <- s.container,
   kind <- s.kind,
   stateMachine <- s.stateMachine,
   state <- s.state
  )
}

rule CopyProtocolConformance {
 from
  s : UML!ProtocolConformance
  (
   s.oclIsTypeOf(UML!ProtocolConformance)
  )
 to
  t : UMLs!ProtocolConformance (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   generalMachine <- s.generalMachine,
   specificMachine <- s.specificMachine
  )
}

rule CopyConnector {
 from
  s : UML!Connector
  (
   s.oclIsTypeOf(UML!Connector)
  )
 to
  t : UMLs!Connector (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   isStatic <- s.isStatic,
   featuringClassifier <- s.featuringClassifier,
   type <- s.type,
   redefinedConnector <- s.redefinedConnector,
   end <- s.end,
   kind <- s.kind,
   contract <- s.contract
  )
}

rule CopyExtension {
 from
  s : UML!Extension
  (
   s.oclIsTypeOf(UML!Extension)
  )
 to
  t : UMLs!Extension (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   relatedElement <- s.relatedElement,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   ownedEnd <- s.ownedEnd,
   memberEnd <- s.memberEnd,
   isDerived <- s.isDerived,
   endType <- s.endType,
   navigableOwnedEnd <- s.navigableOwnedEnd,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isRequired <- s.isRequired,
   metaclass <- s.metaclass
  )
}

rule CopyExtensionEnd {
 from
  s : UML!ExtensionEnd
  (
   s.oclIsTypeOf(UML!ExtensionEnd)
  )
 to
  t : UMLs!ExtensionEnd (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isStatic <- s.isStatic,
   featuringClassifier <- s.featuringClassifier,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   upper <- s.upper,
   lower <- s.lower,
   upperValue <- s.upperValue,
   lowerValue <- s.lowerValue,
   end <- s.end,
   class <- s.class,
   isDerived <- s.isDerived,
   isDerivedUnion <- s.isDerivedUnion,
   default <- s.default,
   aggregation <- s.aggregation,
   isComposite <- s.isComposite,
   redefinedProperty <- s.redefinedProperty,
   defaultValue <- s.defaultValue,
   opposite <- s.opposite,
   subsettedProperty <- s.subsettedProperty,
   qualifier <- s.qualifier,
   deployment <- s.deployment,
   deployedElement <- s.deployedElement,
   isReadOnly <- s.isReadOnly
  )
}

rule CopyStereotype {
 from
  s : UML!Stereotype
  (
   s.oclIsTypeOf(UML!Stereotype)
  )
 to
  t : UMLs!Stereotype (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector,
   icon <- s.icon
  )
}

rule CopyImage {
 from
  s : UML!Image
  (
   s.oclIsTypeOf(UML!Image)
  )
 to
  t : UMLs!Image (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   content <- s.content,
   location <- s.location,
   format <- s.format
  )
}

rule CopyProfile {
 from
  s : UML!Profile
  (
   s.oclIsTypeOf(UML!Profile)
  )
 to
  t : UMLs!Profile (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   ownedType <- s.ownedType,
   packageMerge <- s.packageMerge,
   packagedElement <- s.packagedElement,
   nestedPackage <- s.nestedPackage,
   nestingPackage <- s.nestingPackage,
   profileApplication <- s.profileApplication,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   ownedStereotype <- s.ownedStereotype,
   metaclassReference <- s.metaclassReference,
   metamodelReference <- s.metamodelReference
  )
}

rule CopyModel {
 from
  s : UML!Model
  (
   s.oclIsTypeOf(UML!Model)
  )
 to
  t : UMLs!Model (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   ownedType <- s.ownedType,
   packageMerge <- s.packageMerge,
   packagedElement <- s.packagedElement,
   nestedPackage <- s.nestedPackage,
   nestingPackage <- s.nestingPackage,
   profileApplication <- s.profileApplication,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   viewpoint <- s.viewpoint
  )
}

rule CopyParameterSet {
 from
  s : UML!ParameterSet
  (
   s.oclIsTypeOf(UML!ParameterSet)
  )
 to
  t : UMLs!ParameterSet (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   parameter <- s.parameter,
   condition <- s.condition
  )
}

rule CopyDataType {
 from
  s : UML!DataType
  (
   s.oclIsTypeOf(UML!DataType)
  )
 to
  t : UMLs!DataType (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   ownedAttribute <- s.ownedAttribute,
   ownedOperation <- s.ownedOperation
  )
}

rule CopyOperationTemplateParameter {
 from
  s : UML!OperationTemplateParameter
  (
   s.oclIsTypeOf(UML!OperationTemplateParameter)
  )
 to
  t : UMLs!OperationTemplateParameter (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   parameteredElement <- s.parameteredElement,
   ownedParameteredElement <- s.ownedParameteredElement,
   default <- s.default,
   ownedDefault <- s.ownedDefault
  )
}

rule CopyConnectableElementTemplateParameter {
 from
  s : UML!ConnectableElementTemplateParameter
  (
   s.oclIsTypeOf(UML!ConnectableElementTemplateParameter)
  )
 to
  t : UMLs!ConnectableElementTemplateParameter (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   parameteredElement <- s.parameteredElement,
   ownedParameteredElement <- s.ownedParameteredElement,
   default <- s.default,
   ownedDefault <- s.ownedDefault
  )
}

rule CopyCollaborationUse {
 from
  s : UML!CollaborationUse
  (
   s.oclIsTypeOf(UML!CollaborationUse)
  )
 to
  t : UMLs!CollaborationUse (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   roleBinding <- s.roleBinding
  )
}

rule CopyCollaboration {
 from
  s : UML!Collaboration
  (
   s.oclIsTypeOf(UML!Collaboration)
  )
 to
  t : UMLs!Collaboration (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector,
   collaborationRole <- s.collaborationRole
  )
}

rule CopyUseCase {
 from
  s : UML!UseCase
  (
   s.oclIsTypeOf(UML!UseCase)
  )
 to
  t : UMLs!UseCase (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   include <- s.include,
   extend <- s.extend,
   extensionPoint <- s.extensionPoint,
   subject <- s.subject
  )
}

rule CopyInclude {
 from
  s : UML!Include
  (
   s.oclIsTypeOf(UML!Include)
  )
 to
  t : UMLs!Include (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   addition <- s.addition,
   includingCase <- s.includingCase
  )
}

rule CopyExtend {
 from
  s : UML!Extend
  (
   s.oclIsTypeOf(UML!Extend)
  )
 to
  t : UMLs!Extend (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   extendedCase <- s.extendedCase,
   condition <- s.condition,
   extensionLocation <- s.extensionLocation,
   extension <- s.extension
  )
}

rule CopyExtensionPoint {
 from
  s : UML!ExtensionPoint
  (
   s.oclIsTypeOf(UML!ExtensionPoint)
  )
 to
  t : UMLs!ExtensionPoint (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   useCase <- s.useCase
  )
}

rule CopyRedefinableTemplateSignature {
 from
  s : UML!RedefinableTemplateSignature
  (
   s.oclIsTypeOf(UML!RedefinableTemplateSignature)
  )
 to
  t : UMLs!RedefinableTemplateSignature (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   parameter <- s.parameter,
   ownedParameter <- s.ownedParameter,
   template <- s.template,
   extendedSignature <- s.extendedSignature,
   inheritedParameter <- s.inheritedParameter,
   classifier <- s.classifier
  )
}

rule CopyClassifierTemplateParameter {
 from
  s : UML!ClassifierTemplateParameter
  (
   s.oclIsTypeOf(UML!ClassifierTemplateParameter)
  )
 to
  t : UMLs!ClassifierTemplateParameter (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   parameteredElement <- s.parameteredElement,
   ownedParameteredElement <- s.ownedParameteredElement,
   default <- s.default,
   ownedDefault <- s.ownedDefault,
   allowSubstitutable <- s.allowSubstitutable,
   constrainingClassifier <- s.constrainingClassifier
  )
}

rule CopyStringExpression {
 from
  s : UML!StringExpression
  (
   s.oclIsTypeOf(UML!StringExpression)
  )
 to
  t : UMLs!StringExpression (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   subExpression <- s.subExpression,
   owningExpression <- s.owningExpression,
   symbol <- s.symbol,
   operand <- s.operand
  )
}

rule CopyExpression {
 from
  s : UML!Expression
  (
   s.oclIsTypeOf(UML!Expression)
  )
 to
  t : UMLs!Expression (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   symbol <- s.symbol,
   operand <- s.operand
  )
}

rule CopyUsage {
 from
  s : UML!Usage
  (
   s.oclIsTypeOf(UML!Usage)
  )
 to
  t : UMLs!Usage (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   supplier <- s.supplier,
   client <- s.client,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyPackageMerge {
 from
  s : UML!PackageMerge
  (
   s.oclIsTypeOf(UML!PackageMerge)
  )
 to
  t : UMLs!PackageMerge (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   mergedPackage <- s.mergedPackage,
   receivingPackage <- s.receivingPackage
  )
}

rule CopyProfileApplication {
 from
  s : UML!ProfileApplication
  (
   s.oclIsTypeOf(UML!ProfileApplication)
  )
 to
  t : UMLs!ProfileApplication (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   appliedProfile <- s.appliedProfile,
   isStrict <- s.isStrict,
   applyingPackage <- s.applyingPackage
  )
}

rule CopyEnumeration {
 from
  s : UML!Enumeration
  (
   s.oclIsTypeOf(UML!Enumeration)
  )
 to
  t : UMLs!Enumeration (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   ownedAttribute <- s.ownedAttribute,
   ownedOperation <- s.ownedOperation,
   ownedLiteral <- s.ownedLiteral
  )
}

rule CopyEnumerationLiteral {
 from
  s : UML!EnumerationLiteral
  (
   s.oclIsTypeOf(UML!EnumerationLiteral)
  )
 to
  t : UMLs!EnumerationLiteral (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   deployment <- s.deployment,
   deployedElement <- s.deployedElement,
   classifier <- s.classifier,
   slot <- s.slot,
   specification <- s.specification
  )
}

rule CopyInstanceSpecification {
 from
  s : UML!InstanceSpecification
  (
   s.oclIsTypeOf(UML!InstanceSpecification)
  )
 to
  t : UMLs!InstanceSpecification (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   deployment <- s.deployment,
   deployedElement <- s.deployedElement,
   classifier <- s.classifier,
   slot <- s.slot,
   specification <- s.specification
  )
}

rule CopySlot {
 from
  s : UML!Slot
  (
   s.oclIsTypeOf(UML!Slot)
  )
 to
  t : UMLs!Slot (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   definingFeature <- s.definingFeature,
   value <- s.value,
   owningInstance <- s.owningInstance
  )
}

rule CopyPrimitiveType {
 from
  s : UML!PrimitiveType
  (
   s.oclIsTypeOf(UML!PrimitiveType)
  )
 to
  t : UMLs!PrimitiveType (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   ownedAttribute <- s.ownedAttribute,
   ownedOperation <- s.ownedOperation
  )
}

rule CopyLiteralInteger {
 from
  s : UML!LiteralInteger
  (
   s.oclIsTypeOf(UML!LiteralInteger)
  )
 to
  t : UMLs!LiteralInteger (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   value <- s.value
  )
}

rule CopyLiteralString {
 from
  s : UML!LiteralString
  (
   s.oclIsTypeOf(UML!LiteralString)
  )
 to
  t : UMLs!LiteralString (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   value <- s.value
  )
}

rule CopyLiteralBoolean {
 from
  s : UML!LiteralBoolean
  (
   s.oclIsTypeOf(UML!LiteralBoolean)
  )
 to
  t : UMLs!LiteralBoolean (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   value <- s.value
  )
}

rule CopyLiteralNull {
 from
  s : UML!LiteralNull
  (
   s.oclIsTypeOf(UML!LiteralNull)
  )
 to
  t : UMLs!LiteralNull (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyInstanceValue {
 from
  s : UML!InstanceValue
  (
   s.oclIsTypeOf(UML!InstanceValue)
  )
 to
  t : UMLs!InstanceValue (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   instance <- s.instance
  )
}

rule CopyLiteralUnlimitedNatural {
 from
  s : UML!LiteralUnlimitedNatural
  (
   s.oclIsTypeOf(UML!LiteralUnlimitedNatural)
  )
 to
  t : UMLs!LiteralUnlimitedNatural (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   value <- s.value
  )
}

rule CopyOpaqueBehavior {
 from
  s : UML!OpaqueBehavior
  (
   s.oclIsTypeOf(UML!OpaqueBehavior)
  )
 to
  t : UMLs!OpaqueBehavior (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isReentrant <- s.isReentrant,
   redefinedBehavior <- s.redefinedBehavior,
   ownedParameter <- s.ownedParameter,
   context <- s.context,
   precondition <- s.precondition,
   postcondition <- s.postcondition,
   ownedParameterSet <- s.ownedParameterSet,
   specification <- s.specification,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector,
   body <- s.body,
   language <- s.language
  )
}

rule CopyFunctionBehavior {
 from
  s : UML!FunctionBehavior
  (
   s.oclIsTypeOf(UML!FunctionBehavior)
  )
 to
  t : UMLs!FunctionBehavior (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isReentrant <- s.isReentrant,
   redefinedBehavior <- s.redefinedBehavior,
   ownedParameter <- s.ownedParameter,
   context <- s.context,
   precondition <- s.precondition,
   postcondition <- s.postcondition,
   ownedParameterSet <- s.ownedParameterSet,
   specification <- s.specification,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector,
   body <- s.body,
   language <- s.language
  )
}

rule CopyOpaqueAction {
 from
  s : UML!OpaqueAction
  (
   s.oclIsTypeOf(UML!OpaqueAction)
  )
 to
  t : UMLs!OpaqueAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   body <- s.body,
   language <- s.language,
   inputValue <- s.inputValue,
   outputValue <- s.outputValue,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode
  )
}

rule CopyStructuredActivityNode {
 from
  s : UML!StructuredActivityNode
  (
   s.oclIsTypeOf(UML!StructuredActivityNode)
  )
 to
  t : UMLs!StructuredActivityNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   variable <- s.variable,
   edge <- s.edge,
   mustIsolate <- s.mustIsolate,
   node <- s.node,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   inActivity <- s.inActivity,
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode
  )
}

rule CopyActivity {
 from
  s : UML!Activity
  (
   s.oclIsTypeOf(UML!Activity)
  )
 to
  t : UMLs!Activity (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isReentrant <- s.isReentrant,
   redefinedBehavior <- s.redefinedBehavior,
   ownedParameter <- s.ownedParameter,
   context <- s.context,
   precondition <- s.precondition,
   postcondition <- s.postcondition,
   ownedParameterSet <- s.ownedParameterSet,
   specification <- s.specification,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector,
   structuredNode <- s.structuredNode,
   variable <- s.variable,
   node <- s.node,
   isReadOnly <- s.isReadOnly,
   edge <- s.edge,
   partition <- s.partition,
   isSingleExecution <- s.isSingleExecution,
   group <- s.group
  )
}

rule CopyVariable {
 from
  s : UML!Variable
  (
   s.oclIsTypeOf(UML!Variable)
  )
 to
  t : UMLs!Variable (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   upper <- s.upper,
   lower <- s.lower,
   upperValue <- s.upperValue,
   lowerValue <- s.lowerValue,
   end <- s.end,
   scope <- s.scope,
   activityScope <- s.activityScope
  )
}

rule CopyActivityPartition {
 from
  s : UML!ActivityPartition
  (
   s.oclIsTypeOf(UML!ActivityPartition)
  )
 to
  t : UMLs!ActivityPartition (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   inActivity <- s.inActivity,
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   isDimension <- s.isDimension,
   isExternal <- s.isExternal,
   node <- s.node,
   subpartition <- s.subpartition,
   superPartition <- s.superPartition,
   represents <- s.represents,
   edge <- s.edge
  )
}

rule CopyInterruptibleActivityRegion {
 from
  s : UML!InterruptibleActivityRegion
  (
   s.oclIsTypeOf(UML!InterruptibleActivityRegion)
  )
 to
  t : UMLs!InterruptibleActivityRegion (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   inActivity <- s.inActivity,
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   node <- s.node,
   interruptingEdge <- s.interruptingEdge
  )
}

rule CopyExceptionHandler {
 from
  s : UML!ExceptionHandler
  (
   s.oclIsTypeOf(UML!ExceptionHandler)
  )
 to
  t : UMLs!ExceptionHandler (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   handlerBody <- s.handlerBody,
   exceptionInput <- s.exceptionInput,
   exceptionType <- s.exceptionType,
   protectedNode <- s.protectedNode
  )
}

rule CopyOutputPin {
 from
  s : UML!OutputPin
  (
   s.oclIsTypeOf(UML!OutputPin)
  )
 to
  t : UMLs!OutputPin (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   upper <- s.upper,
   lower <- s.lower,
   upperValue <- s.upperValue,
   lowerValue <- s.lowerValue,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   ordering <- s.ordering,
   isControlType <- s.isControlType,
   upperBound <- s.upperBound,
   inState <- s.inState,
   selection <- s.selection,
   isControl <- s.isControl
  )
}

rule CopyPin {
 from
  s : UML!Pin
  (
   s.oclIsTypeOf(UML!Pin)
  )
 to
  t : UMLs!Pin (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   upper <- s.upper,
   lower <- s.lower,
   upperValue <- s.upperValue,
   lowerValue <- s.lowerValue,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   ordering <- s.ordering,
   isControlType <- s.isControlType,
   upperBound <- s.upperBound,
   inState <- s.inState,
   selection <- s.selection,
   isControl <- s.isControl
  )
}

rule CopyInputPin {
 from
  s : UML!InputPin
  (
   s.oclIsTypeOf(UML!InputPin)
  )
 to
  t : UMLs!InputPin (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   upper <- s.upper,
   lower <- s.lower,
   upperValue <- s.upperValue,
   lowerValue <- s.lowerValue,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   ordering <- s.ordering,
   isControlType <- s.isControlType,
   upperBound <- s.upperBound,
   inState <- s.inState,
   selection <- s.selection,
   isControl <- s.isControl
  )
}

rule CopySendSignalAction {
 from
  s : UML!SendSignalAction
  (
   s.oclIsTypeOf(UML!SendSignalAction)
  )
 to
  t : UMLs!SendSignalAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   argument <- s.argument,
   onPort <- s.onPort,
   target <- s.target,
   signal <- s.signal
  )
}

rule CopyCallOperationAction {
 from
  s : UML!CallOperationAction
  (
   s.oclIsTypeOf(UML!CallOperationAction)
  )
 to
  t : UMLs!CallOperationAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   isSynchronous <- s.isSynchronous,
   result <- s.result,
   argument <- s.argument,
   onPort <- s.onPort,
   operation <- s.operation,
   target <- s.target
  )
}

rule CopyCallBehaviorAction {
 from
  s : UML!CallBehaviorAction
  (
   s.oclIsTypeOf(UML!CallBehaviorAction)
  )
 to
  t : UMLs!CallBehaviorAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   isSynchronous <- s.isSynchronous,
   result <- s.result,
   argument <- s.argument,
   onPort <- s.onPort,
   behavior <- s.behavior
  )
}

rule CopySequenceNode {
 from
  s : UML!SequenceNode
  (
   s.oclIsTypeOf(UML!SequenceNode)
  )
 to
  t : UMLs!SequenceNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   variable <- s.variable,
   edge <- s.edge,
   mustIsolate <- s.mustIsolate,
   node <- s.node,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   inActivity <- s.inActivity,
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   executableNode <- s.executableNode
  )
}

rule CopyControlFlow {
 from
  s : UML!ControlFlow
  (
   s.oclIsTypeOf(UML!ControlFlow)
  )
 to
  t : UMLs!ControlFlow (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   source <- s.source,
   target <- s.target,
   redefinedEdge <- s.redefinedEdge,
   inPartition <- s.inPartition,
   guard <- s.guard,
   weight <- s.weight,
   interrupts <- s.interrupts,
   inStructuredNode <- s.inStructuredNode,
   inGroup <- s.inGroup,
   activity <- s.activity
  )
}

rule CopyInitialNode {
 from
  s : UML!InitialNode
  (
   s.oclIsTypeOf(UML!InitialNode)
  )
 to
  t : UMLs!InitialNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode
  )
}

rule CopyActivityParameterNode {
 from
  s : UML!ActivityParameterNode
  (
   s.oclIsTypeOf(UML!ActivityParameterNode)
  )
 to
  t : UMLs!ActivityParameterNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   ordering <- s.ordering,
   isControlType <- s.isControlType,
   upperBound <- s.upperBound,
   inState <- s.inState,
   selection <- s.selection,
   parameter <- s.parameter
  )
}

rule CopyValuePin {
 from
  s : UML!ValuePin
  (
   s.oclIsTypeOf(UML!ValuePin)
  )
 to
  t : UMLs!ValuePin (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   upper <- s.upper,
   lower <- s.lower,
   upperValue <- s.upperValue,
   lowerValue <- s.lowerValue,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   ordering <- s.ordering,
   isControlType <- s.isControlType,
   upperBound <- s.upperBound,
   inState <- s.inState,
   selection <- s.selection,
   isControl <- s.isControl,
   value <- s.value
  )
}

rule CopyMessage {
 from
  s : UML!Message
  (
   s.oclIsTypeOf(UML!Message)
  )
 to
  t : UMLs!Message (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   messageKind <- s.messageKind,
   messageSort <- s.messageSort,
   receiveEvent <- s.receiveEvent,
   sendEvent <- s.sendEvent,
   connector <- s.connector,
   interaction <- s.interaction,
   argument <- s.argument,
   signature <- s.signature
  )
}

rule CopyInteraction {
 from
  s : UML!Interaction
  (
   s.oclIsTypeOf(UML!Interaction)
  )
 to
  t : UMLs!Interaction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isReentrant <- s.isReentrant,
   redefinedBehavior <- s.redefinedBehavior,
   ownedParameter <- s.ownedParameter,
   context <- s.context,
   precondition <- s.precondition,
   postcondition <- s.postcondition,
   ownedParameterSet <- s.ownedParameterSet,
   specification <- s.specification,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector,
   lifeline <- s.lifeline,
   fragment <- s.fragment,
   action <- s.action,
   formalGate <- s.formalGate,
   message <- s.message,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering
  )
}

rule CopyLifeline {
 from
  s : UML!Lifeline
  (
   s.oclIsTypeOf(UML!Lifeline)
  )
 to
  t : UMLs!Lifeline (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   represents <- s.represents,
   interaction <- s.interaction,
   selector <- s.selector,
   decomposedAs <- s.decomposedAs,
   coveredBy <- s.coveredBy
  )
}

rule CopyPartDecomposition {
 from
  s : UML!PartDecomposition
  (
   s.oclIsTypeOf(UML!PartDecomposition)
  )
 to
  t : UMLs!PartDecomposition (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   refersTo <- s.refersTo,
   actualGate <- s.actualGate,
   argument <- s.argument
  )
}

rule CopyInteractionUse {
 from
  s : UML!InteractionUse
  (
   s.oclIsTypeOf(UML!InteractionUse)
  )
 to
  t : UMLs!InteractionUse (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   refersTo <- s.refersTo,
   actualGate <- s.actualGate,
   argument <- s.argument
  )
}

rule CopyGate {
 from
  s : UML!Gate
  (
   s.oclIsTypeOf(UML!Gate)
  )
 to
  t : UMLs!Gate (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   message <- s.message
  )
}

rule CopyGeneralOrdering {
 from
  s : UML!GeneralOrdering
  (
   s.oclIsTypeOf(UML!GeneralOrdering)
  )
 to
  t : UMLs!GeneralOrdering (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   before <- s.before,
   after <- s.after
  )
}

rule CopyOccurrenceSpecification {
 from
  s : UML!OccurrenceSpecification
  (
   s.oclIsTypeOf(UML!OccurrenceSpecification)
  )
 to
  t : UMLs!OccurrenceSpecification (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   toBefore <- s.toBefore,
   event <- s.event,
   toAfter <- s.toAfter
  )
}

rule CopyInteractionOperand {
 from
  s : UML!InteractionOperand
  (
   s.oclIsTypeOf(UML!InteractionOperand)
  )
 to
  t : UMLs!InteractionOperand (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   guard <- s.guard,
   fragment <- s.fragment
  )
}

rule CopyInteractionConstraint {
 from
  s : UML!InteractionConstraint
  (
   s.oclIsTypeOf(UML!InteractionConstraint)
  )
 to
  t : UMLs!InteractionConstraint (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   constrainedElement <- s.constrainedElement,
   specification <- s.specification,
   context <- s.context,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   minint <- s.minint,
   maxint <- s.maxint
  )
}

rule CopyStateInvariant {
 from
  s : UML!StateInvariant
  (
   s.oclIsTypeOf(UML!StateInvariant)
  )
 to
  t : UMLs!StateInvariant (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   invariant <- s.invariant
  )
}

rule CopyActionExecutionSpecification {
 from
  s : UML!ActionExecutionSpecification
  (
   s.oclIsTypeOf(UML!ActionExecutionSpecification)
  )
 to
  t : UMLs!ActionExecutionSpecification (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   start <- s.start,
   finish <- s.finish,
   action <- s.action
  )
}

rule CopyBehaviorExecutionSpecification {
 from
  s : UML!BehaviorExecutionSpecification
  (
   s.oclIsTypeOf(UML!BehaviorExecutionSpecification)
  )
 to
  t : UMLs!BehaviorExecutionSpecification (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   start <- s.start,
   finish <- s.finish,
   behavior <- s.behavior
  )
}

rule CopyExecutionEvent {
 from
  s : UML!ExecutionEvent
  (
   s.oclIsTypeOf(UML!ExecutionEvent)
  )
 to
  t : UMLs!ExecutionEvent (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyCreationEvent {
 from
  s : UML!CreationEvent
  (
   s.oclIsTypeOf(UML!CreationEvent)
  )
 to
  t : UMLs!CreationEvent (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyDestructionEvent {
 from
  s : UML!DestructionEvent
  (
   s.oclIsTypeOf(UML!DestructionEvent)
  )
 to
  t : UMLs!DestructionEvent (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopySendOperationEvent {
 from
  s : UML!SendOperationEvent
  (
   s.oclIsTypeOf(UML!SendOperationEvent)
  )
 to
  t : UMLs!SendOperationEvent (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   operation <- s.operation
  )
}

rule CopySendSignalEvent {
 from
  s : UML!SendSignalEvent
  (
   s.oclIsTypeOf(UML!SendSignalEvent)
  )
 to
  t : UMLs!SendSignalEvent (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   signal <- s.signal
  )
}

rule CopyMessageOccurrenceSpecification {
 from
  s : UML!MessageOccurrenceSpecification
  (
   s.oclIsTypeOf(UML!MessageOccurrenceSpecification)
  )
 to
  t : UMLs!MessageOccurrenceSpecification (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   message <- s.message,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   toBefore <- s.toBefore,
   event <- s.event,
   toAfter <- s.toAfter
  )
}

rule CopyExecutionOccurrenceSpecification {
 from
  s : UML!ExecutionOccurrenceSpecification
  (
   s.oclIsTypeOf(UML!ExecutionOccurrenceSpecification)
  )
 to
  t : UMLs!ExecutionOccurrenceSpecification (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   toBefore <- s.toBefore,
   event <- s.event,
   toAfter <- s.toAfter,
   execution <- s.execution
  )
}

rule CopyReceiveOperationEvent {
 from
  s : UML!ReceiveOperationEvent
  (
   s.oclIsTypeOf(UML!ReceiveOperationEvent)
  )
 to
  t : UMLs!ReceiveOperationEvent (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   operation <- s.operation
  )
}

rule CopyReceiveSignalEvent {
 from
  s : UML!ReceiveSignalEvent
  (
   s.oclIsTypeOf(UML!ReceiveSignalEvent)
  )
 to
  t : UMLs!ReceiveSignalEvent (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   signal <- s.signal
  )
}

rule CopyActor {
 from
  s : UML!Actor
  (
   s.oclIsTypeOf(UML!Actor)
  )
 to
  t : UMLs!Actor (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger
  )
}

rule CopyCallEvent {
 from
  s : UML!CallEvent
  (
   s.oclIsTypeOf(UML!CallEvent)
  )
 to
  t : UMLs!CallEvent (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   operation <- s.operation
  )
}

rule CopyChangeEvent {
 from
  s : UML!ChangeEvent
  (
   s.oclIsTypeOf(UML!ChangeEvent)
  )
 to
  t : UMLs!ChangeEvent (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   changeExpression <- s.changeExpression
  )
}

rule CopySignalEvent {
 from
  s : UML!SignalEvent
  (
   s.oclIsTypeOf(UML!SignalEvent)
  )
 to
  t : UMLs!SignalEvent (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   signal <- s.signal
  )
}

rule CopyAnyReceiveEvent {
 from
  s : UML!AnyReceiveEvent
  (
   s.oclIsTypeOf(UML!AnyReceiveEvent)
  )
 to
  t : UMLs!AnyReceiveEvent (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyForkNode {
 from
  s : UML!ForkNode
  (
   s.oclIsTypeOf(UML!ForkNode)
  )
 to
  t : UMLs!ForkNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode
  )
}

rule CopyFlowFinalNode {
 from
  s : UML!FlowFinalNode
  (
   s.oclIsTypeOf(UML!FlowFinalNode)
  )
 to
  t : UMLs!FlowFinalNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode
  )
}

rule CopyCentralBufferNode {
 from
  s : UML!CentralBufferNode
  (
   s.oclIsTypeOf(UML!CentralBufferNode)
  )
 to
  t : UMLs!CentralBufferNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   ordering <- s.ordering,
   isControlType <- s.isControlType,
   upperBound <- s.upperBound,
   inState <- s.inState,
   selection <- s.selection
  )
}

rule CopyMergeNode {
 from
  s : UML!MergeNode
  (
   s.oclIsTypeOf(UML!MergeNode)
  )
 to
  t : UMLs!MergeNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode
  )
}

rule CopyDecisionNode {
 from
  s : UML!DecisionNode
  (
   s.oclIsTypeOf(UML!DecisionNode)
  )
 to
  t : UMLs!DecisionNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   decisionInput <- s.decisionInput,
   decisionInputFlow <- s.decisionInputFlow
  )
}

rule CopyObjectFlow {
 from
  s : UML!ObjectFlow
  (
   s.oclIsTypeOf(UML!ObjectFlow)
  )
 to
  t : UMLs!ObjectFlow (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   source <- s.source,
   target <- s.target,
   redefinedEdge <- s.redefinedEdge,
   inPartition <- s.inPartition,
   guard <- s.guard,
   weight <- s.weight,
   interrupts <- s.interrupts,
   inStructuredNode <- s.inStructuredNode,
   inGroup <- s.inGroup,
   activity <- s.activity,
   isMulticast <- s.isMulticast,
   isMultireceive <- s.isMultireceive,
   transformation <- s.transformation,
   selection <- s.selection
  )
}

rule CopyActivityFinalNode {
 from
  s : UML!ActivityFinalNode
  (
   s.oclIsTypeOf(UML!ActivityFinalNode)
  )
 to
  t : UMLs!ActivityFinalNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode
  )
}

rule CopyComponentRealization {
 from
  s : UML!ComponentRealization
  (
   s.oclIsTypeOf(UML!ComponentRealization)
  )
 to
  t : UMLs!ComponentRealization (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   supplier <- s.supplier,
   client <- s.client,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   mapping <- s.mapping,
   abstraction <- s.abstraction,
   realizingClassifier <- s.realizingClassifier
  )
}

rule CopyComponent {
 from
  s : UML!Component
  (
   s.oclIsTypeOf(UML!Component)
  )
 to
  t : UMLs!Component (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector,
   isIndirectlyInstantiated <- s.isIndirectlyInstantiated,
   required <- s.required,
   provided <- s.provided,
   packagedElement <- s.packagedElement,
   realization <- s.realization
  )
}

rule CopyNode {
 from
  s : UML!Node
  (
   s.oclIsTypeOf(UML!Node)
  )
 to
  t : UMLs!Node (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   deployment <- s.deployment,
   deployedElement <- s.deployedElement,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector,
   nestedNode <- s.nestedNode
  )
}

rule CopyCommunicationPath {
 from
  s : UML!CommunicationPath
  (
   s.oclIsTypeOf(UML!CommunicationPath)
  )
 to
  t : UMLs!CommunicationPath (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   relatedElement <- s.relatedElement,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   ownedEnd <- s.ownedEnd,
   memberEnd <- s.memberEnd,
   isDerived <- s.isDerived,
   endType <- s.endType,
   navigableOwnedEnd <- s.navigableOwnedEnd,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyDevice {
 from
  s : UML!Device
  (
   s.oclIsTypeOf(UML!Device)
  )
 to
  t : UMLs!Device (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   deployment <- s.deployment,
   deployedElement <- s.deployedElement,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector,
   nestedNode <- s.nestedNode
  )
}

rule CopyExecutionEnvironment {
 from
  s : UML!ExecutionEnvironment
  (
   s.oclIsTypeOf(UML!ExecutionEnvironment)
  )
 to
  t : UMLs!ExecutionEnvironment (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   deployment <- s.deployment,
   deployedElement <- s.deployedElement,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector,
   nestedNode <- s.nestedNode
  )
}

rule CopyCombinedFragment {
 from
  s : UML!CombinedFragment
  (
   s.oclIsTypeOf(UML!CombinedFragment)
  )
 to
  t : UMLs!CombinedFragment (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   interactionOperator <- s.interactionOperator,
   operand <- s.operand,
   cfragmentGate <- s.cfragmentGate
  )
}

rule CopyContinuation {
 from
  s : UML!Continuation
  (
   s.oclIsTypeOf(UML!Continuation)
  )
 to
  t : UMLs!Continuation (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   setting <- s.setting
  )
}

rule CopyConsiderIgnoreFragment {
 from
  s : UML!ConsiderIgnoreFragment
  (
   s.oclIsTypeOf(UML!ConsiderIgnoreFragment)
  )
 to
  t : UMLs!ConsiderIgnoreFragment (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   interactionOperator <- s.interactionOperator,
   operand <- s.operand,
   cfragmentGate <- s.cfragmentGate,
   message <- s.message
  )
}

rule CopyCreateObjectAction {
 from
  s : UML!CreateObjectAction
  (
   s.oclIsTypeOf(UML!CreateObjectAction)
  )
 to
  t : UMLs!CreateObjectAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   classifier <- s.classifier,
   result <- s.result
  )
}

rule CopyDestroyObjectAction {
 from
  s : UML!DestroyObjectAction
  (
   s.oclIsTypeOf(UML!DestroyObjectAction)
  )
 to
  t : UMLs!DestroyObjectAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   isDestroyLinks <- s.isDestroyLinks,
   isDestroyOwnedObjects <- s.isDestroyOwnedObjects,
   target <- s.target
  )
}

rule CopyTestIdentityAction {
 from
  s : UML!TestIdentityAction
  (
   s.oclIsTypeOf(UML!TestIdentityAction)
  )
 to
  t : UMLs!TestIdentityAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   first <- s.first,
   second <- s.second,
   result <- s.result
  )
}

rule CopyReadSelfAction {
 from
  s : UML!ReadSelfAction
  (
   s.oclIsTypeOf(UML!ReadSelfAction)
  )
 to
  t : UMLs!ReadSelfAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   result <- s.result
  )
}

rule CopyReadStructuralFeatureAction {
 from
  s : UML!ReadStructuralFeatureAction
  (
   s.oclIsTypeOf(UML!ReadStructuralFeatureAction)
  )
 to
  t : UMLs!ReadStructuralFeatureAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   structuralFeature <- s.structuralFeature,
   object <- s.object,
   result <- s.result
  )
}

rule CopyClearStructuralFeatureAction {
 from
  s : UML!ClearStructuralFeatureAction
  (
   s.oclIsTypeOf(UML!ClearStructuralFeatureAction)
  )
 to
  t : UMLs!ClearStructuralFeatureAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   structuralFeature <- s.structuralFeature,
   object <- s.object,
   result <- s.result
  )
}

rule CopyRemoveStructuralFeatureValueAction {
 from
  s : UML!RemoveStructuralFeatureValueAction
  (
   s.oclIsTypeOf(UML!RemoveStructuralFeatureValueAction)
  )
 to
  t : UMLs!RemoveStructuralFeatureValueAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   structuralFeature <- s.structuralFeature,
   object <- s.object,
   value <- s.value,
   result <- s.result,
   isRemoveDuplicates <- s.isRemoveDuplicates,
   removeAt <- s.removeAt
  )
}

rule CopyAddStructuralFeatureValueAction {
 from
  s : UML!AddStructuralFeatureValueAction
  (
   s.oclIsTypeOf(UML!AddStructuralFeatureValueAction)
  )
 to
  t : UMLs!AddStructuralFeatureValueAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   structuralFeature <- s.structuralFeature,
   object <- s.object,
   value <- s.value,
   result <- s.result,
   isReplaceAll <- s.isReplaceAll,
   insertAt <- s.insertAt
  )
}

rule CopyLinkEndData {
 from
  s : UML!LinkEndData
  (
   s.oclIsTypeOf(UML!LinkEndData)
  )
 to
  t : UMLs!LinkEndData (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   value <- s.value,
   end <- s.end,
   qualifier <- s.qualifier
  )
}

rule CopyQualifierValue {
 from
  s : UML!QualifierValue
  (
   s.oclIsTypeOf(UML!QualifierValue)
  )
 to
  t : UMLs!QualifierValue (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   qualifier <- s.qualifier,
   value <- s.value
  )
}

rule CopyReadLinkAction {
 from
  s : UML!ReadLinkAction
  (
   s.oclIsTypeOf(UML!ReadLinkAction)
  )
 to
  t : UMLs!ReadLinkAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   endData <- s.endData,
   inputValue <- s.inputValue,
   result <- s.result
  )
}

rule CopyLinkEndCreationData {
 from
  s : UML!LinkEndCreationData
  (
   s.oclIsTypeOf(UML!LinkEndCreationData)
  )
 to
  t : UMLs!LinkEndCreationData (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   value <- s.value,
   end <- s.end,
   qualifier <- s.qualifier,
   isReplaceAll <- s.isReplaceAll,
   insertAt <- s.insertAt
  )
}

rule CopyCreateLinkAction {
 from
  s : UML!CreateLinkAction
  (
   s.oclIsTypeOf(UML!CreateLinkAction)
  )
 to
  t : UMLs!CreateLinkAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   endData <- s.endData,
   inputValue <- s.inputValue
  )
}

rule CopyDestroyLinkAction {
 from
  s : UML!DestroyLinkAction
  (
   s.oclIsTypeOf(UML!DestroyLinkAction)
  )
 to
  t : UMLs!DestroyLinkAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   endData <- s.endData,
   inputValue <- s.inputValue
  )
}

rule CopyLinkEndDestructionData {
 from
  s : UML!LinkEndDestructionData
  (
   s.oclIsTypeOf(UML!LinkEndDestructionData)
  )
 to
  t : UMLs!LinkEndDestructionData (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   value <- s.value,
   end <- s.end,
   qualifier <- s.qualifier,
   isDestroyDuplicates <- s.isDestroyDuplicates,
   destroyAt <- s.destroyAt
  )
}

rule CopyClearAssociationAction {
 from
  s : UML!ClearAssociationAction
  (
   s.oclIsTypeOf(UML!ClearAssociationAction)
  )
 to
  t : UMLs!ClearAssociationAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   object <- s.object,
   association <- s.association
  )
}

rule CopyBroadcastSignalAction {
 from
  s : UML!BroadcastSignalAction
  (
   s.oclIsTypeOf(UML!BroadcastSignalAction)
  )
 to
  t : UMLs!BroadcastSignalAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   argument <- s.argument,
   onPort <- s.onPort,
   signal <- s.signal
  )
}

rule CopySendObjectAction {
 from
  s : UML!SendObjectAction
  (
   s.oclIsTypeOf(UML!SendObjectAction)
  )
 to
  t : UMLs!SendObjectAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   argument <- s.argument,
   onPort <- s.onPort,
   target <- s.target,
   request <- s.request
  )
}

rule CopyValueSpecificationAction {
 from
  s : UML!ValueSpecificationAction
  (
   s.oclIsTypeOf(UML!ValueSpecificationAction)
  )
 to
  t : UMLs!ValueSpecificationAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   value <- s.value,
   result <- s.result
  )
}

rule CopyTimeExpression {
 from
  s : UML!TimeExpression
  (
   s.oclIsTypeOf(UML!TimeExpression)
  )
 to
  t : UMLs!TimeExpression (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   expr <- s.expr,
   observation <- s.observation
  )
}

rule CopyDuration {
 from
  s : UML!Duration
  (
   s.oclIsTypeOf(UML!Duration)
  )
 to
  t : UMLs!Duration (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   expr <- s.expr,
   observation <- s.observation
  )
}

rule CopyDurationInterval {
 from
  s : UML!DurationInterval
  (
   s.oclIsTypeOf(UML!DurationInterval)
  )
 to
  t : UMLs!DurationInterval (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   min <- s.min,
   max <- s.max
  )
}

rule CopyInterval {
 from
  s : UML!Interval
  (
   s.oclIsTypeOf(UML!Interval)
  )
 to
  t : UMLs!Interval (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   min <- s.min,
   max <- s.max
  )
}

rule CopyTimeConstraint {
 from
  s : UML!TimeConstraint
  (
   s.oclIsTypeOf(UML!TimeConstraint)
  )
 to
  t : UMLs!TimeConstraint (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   constrainedElement <- s.constrainedElement,
   specification <- s.specification,
   context <- s.context,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   firstEvent <- s.firstEvent
  )
}

rule CopyIntervalConstraint {
 from
  s : UML!IntervalConstraint
  (
   s.oclIsTypeOf(UML!IntervalConstraint)
  )
 to
  t : UMLs!IntervalConstraint (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   constrainedElement <- s.constrainedElement,
   specification <- s.specification,
   context <- s.context,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyTimeInterval {
 from
  s : UML!TimeInterval
  (
   s.oclIsTypeOf(UML!TimeInterval)
  )
 to
  t : UMLs!TimeInterval (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   min <- s.min,
   max <- s.max
  )
}

rule CopyDurationConstraint {
 from
  s : UML!DurationConstraint
  (
   s.oclIsTypeOf(UML!DurationConstraint)
  )
 to
  t : UMLs!DurationConstraint (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   constrainedElement <- s.constrainedElement,
   specification <- s.specification,
   context <- s.context,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   firstEvent <- s.firstEvent
  )
}

rule CopyTimeObservation {
 from
  s : UML!TimeObservation
  (
   s.oclIsTypeOf(UML!TimeObservation)
  )
 to
  t : UMLs!TimeObservation (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   event <- s.event,
   firstEvent <- s.firstEvent
  )
}

rule CopyDurationObservation {
 from
  s : UML!DurationObservation
  (
   s.oclIsTypeOf(UML!DurationObservation)
  )
 to
  t : UMLs!DurationObservation (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   event <- s.event,
   firstEvent <- s.firstEvent
  )
}

rule CopyFinalState {
 from
  s : UML!FinalState
  (
   s.oclIsTypeOf(UML!FinalState)
  )
 to
  t : UMLs!FinalState (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   container <- s.container,
   isComposite <- s.isComposite,
   isOrthogonal <- s.isOrthogonal,
   isSimple <- s.isSimple,
   isSubmachineState <- s.isSubmachineState,
   submachine <- s.submachine,
   connection <- s.connection,
   connectionPoint <- s.connectionPoint,
   redefinedState <- s.redefinedState,
   stateInvariant <- s.stateInvariant,
   entry <- s.entry,
   exit <- s.exit,
   doActivity <- s.doActivity,
   deferrableTrigger <- s.deferrableTrigger,
   region <- s.region
  )
}

rule CopyTimeEvent {
 from
  s : UML!TimeEvent
  (
   s.oclIsTypeOf(UML!TimeEvent)
  )
 to
  t : UMLs!TimeEvent (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isRelative <- s.isRelative,
   when <- s.when
  )
}

rule CopyReadVariableAction {
 from
  s : UML!ReadVariableAction
  (
   s.oclIsTypeOf(UML!ReadVariableAction)
  )
 to
  t : UMLs!ReadVariableAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   variable <- s.variable,
   result <- s.result
  )
}

rule CopyClearVariableAction {
 from
  s : UML!ClearVariableAction
  (
   s.oclIsTypeOf(UML!ClearVariableAction)
  )
 to
  t : UMLs!ClearVariableAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   variable <- s.variable
  )
}

rule CopyAddVariableValueAction {
 from
  s : UML!AddVariableValueAction
  (
   s.oclIsTypeOf(UML!AddVariableValueAction)
  )
 to
  t : UMLs!AddVariableValueAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   variable <- s.variable,
   value <- s.value,
   isReplaceAll <- s.isReplaceAll,
   insertAt <- s.insertAt
  )
}

rule CopyRemoveVariableValueAction {
 from
  s : UML!RemoveVariableValueAction
  (
   s.oclIsTypeOf(UML!RemoveVariableValueAction)
  )
 to
  t : UMLs!RemoveVariableValueAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   variable <- s.variable,
   value <- s.value,
   isRemoveDuplicates <- s.isRemoveDuplicates,
   removeAt <- s.removeAt
  )
}

rule CopyRaiseExceptionAction {
 from
  s : UML!RaiseExceptionAction
  (
   s.oclIsTypeOf(UML!RaiseExceptionAction)
  )
 to
  t : UMLs!RaiseExceptionAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   exception <- s.exception
  )
}

rule CopyActionInputPin {
 from
  s : UML!ActionInputPin
  (
   s.oclIsTypeOf(UML!ActionInputPin)
  )
 to
  t : UMLs!ActionInputPin (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   upper <- s.upper,
   lower <- s.lower,
   upperValue <- s.upperValue,
   lowerValue <- s.lowerValue,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   ordering <- s.ordering,
   isControlType <- s.isControlType,
   upperBound <- s.upperBound,
   inState <- s.inState,
   selection <- s.selection,
   isControl <- s.isControl,
   fromAction <- s.fromAction
  )
}

rule CopyInformationItem {
 from
  s : UML!InformationItem
  (
   s.oclIsTypeOf(UML!InformationItem)
  )
 to
  t : UMLs!InformationItem (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   represented <- s.represented
  )
}

rule CopyInformationFlow {
 from
  s : UML!InformationFlow
  (
   s.oclIsTypeOf(UML!InformationFlow)
  )
 to
  t : UMLs!InformationFlow (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   source <- s.source,
   target <- s.target,
   relatedElement <- s.relatedElement,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   realization <- s.realization,
   conveyed <- s.conveyed,
   informationSource <- s.informationSource,
   informationTarget <- s.informationTarget,
   realizingActivityEdge <- s.realizingActivityEdge,
   realizingConnector <- s.realizingConnector,
   realizingMessage <- s.realizingMessage
  )
}

rule CopyReadExtentAction {
 from
  s : UML!ReadExtentAction
  (
   s.oclIsTypeOf(UML!ReadExtentAction)
  )
 to
  t : UMLs!ReadExtentAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   result <- s.result,
   classifier <- s.classifier
  )
}

rule CopyReclassifyObjectAction {
 from
  s : UML!ReclassifyObjectAction
  (
   s.oclIsTypeOf(UML!ReclassifyObjectAction)
  )
 to
  t : UMLs!ReclassifyObjectAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   isReplaceAll <- s.isReplaceAll,
   oldClassifier <- s.oldClassifier,
   newClassifier <- s.newClassifier,
   object <- s.object
  )
}

rule CopyReadIsClassifiedObjectAction {
 from
  s : UML!ReadIsClassifiedObjectAction
  (
   s.oclIsTypeOf(UML!ReadIsClassifiedObjectAction)
  )
 to
  t : UMLs!ReadIsClassifiedObjectAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   isDirect <- s.isDirect,
   classifier <- s.classifier,
   result <- s.result,
   object <- s.object
  )
}

rule CopyStartClassifierBehaviorAction {
 from
  s : UML!StartClassifierBehaviorAction
  (
   s.oclIsTypeOf(UML!StartClassifierBehaviorAction)
  )
 to
  t : UMLs!StartClassifierBehaviorAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   object <- s.object
  )
}

rule CopyReadLinkObjectEndAction {
 from
  s : UML!ReadLinkObjectEndAction
  (
   s.oclIsTypeOf(UML!ReadLinkObjectEndAction)
  )
 to
  t : UMLs!ReadLinkObjectEndAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   object <- s.object,
   end <- s.end,
   result <- s.result
  )
}

rule CopyReadLinkObjectEndQualifierAction {
 from
  s : UML!ReadLinkObjectEndQualifierAction
  (
   s.oclIsTypeOf(UML!ReadLinkObjectEndQualifierAction)
  )
 to
  t : UMLs!ReadLinkObjectEndQualifierAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   object <- s.object,
   result <- s.result,
   qualifier <- s.qualifier
  )
}

rule CopyCreateLinkObjectAction {
 from
  s : UML!CreateLinkObjectAction
  (
   s.oclIsTypeOf(UML!CreateLinkObjectAction)
  )
 to
  t : UMLs!CreateLinkObjectAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   endData <- s.endData,
   inputValue <- s.inputValue,
   result <- s.result
  )
}

rule CopyAcceptEventAction {
 from
  s : UML!AcceptEventAction
  (
   s.oclIsTypeOf(UML!AcceptEventAction)
  )
 to
  t : UMLs!AcceptEventAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   isUnmarshall <- s.isUnmarshall,
   result <- s.result,
   trigger <- s.trigger
  )
}

rule CopyAcceptCallAction {
 from
  s : UML!AcceptCallAction
  (
   s.oclIsTypeOf(UML!AcceptCallAction)
  )
 to
  t : UMLs!AcceptCallAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   isUnmarshall <- s.isUnmarshall,
   result <- s.result,
   trigger <- s.trigger,
   returnInformation <- s.returnInformation
  )
}

rule CopyReplyAction {
 from
  s : UML!ReplyAction
  (
   s.oclIsTypeOf(UML!ReplyAction)
  )
 to
  t : UMLs!ReplyAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   replyToCall <- s.replyToCall,
   returnInformation <- s.returnInformation,
   replyValue <- s.replyValue
  )
}

rule CopyUnmarshallAction {
 from
  s : UML!UnmarshallAction
  (
   s.oclIsTypeOf(UML!UnmarshallAction)
  )
 to
  t : UMLs!UnmarshallAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   result <- s.result,
   unmarshallType <- s.unmarshallType,
   object <- s.object
  )
}

rule CopyReduceAction {
 from
  s : UML!ReduceAction
  (
   s.oclIsTypeOf(UML!ReduceAction)
  )
 to
  t : UMLs!ReduceAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   reducer <- s.reducer,
   result <- s.result,
   collection <- s.collection,
   isOrdered <- s.isOrdered
  )
}

rule CopyStartObjectBehaviorAction {
 from
  s : UML!StartObjectBehaviorAction
  (
   s.oclIsTypeOf(UML!StartObjectBehaviorAction)
  )
 to
  t : UMLs!StartObjectBehaviorAction (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   isSynchronous <- s.isSynchronous,
   result <- s.result,
   argument <- s.argument,
   onPort <- s.onPort,
   object <- s.object
  )
}

rule CopyJoinNode {
 from
  s : UML!JoinNode
  (
   s.oclIsTypeOf(UML!JoinNode)
  )
 to
  t : UMLs!JoinNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   isCombineDuplicate <- s.isCombineDuplicate,
   joinSpec <- s.joinSpec
  )
}

rule CopyDataStoreNode {
 from
  s : UML!DataStoreNode
  (
   s.oclIsTypeOf(UML!DataStoreNode)
  )
 to
  t : UMLs!DataStoreNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   ordering <- s.ordering,
   isControlType <- s.isControlType,
   upperBound <- s.upperBound,
   inState <- s.inState,
   selection <- s.selection
  )
}

rule CopyConditionalNode {
 from
  s : UML!ConditionalNode
  (
   s.oclIsTypeOf(UML!ConditionalNode)
  )
 to
  t : UMLs!ConditionalNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   variable <- s.variable,
   edge <- s.edge,
   mustIsolate <- s.mustIsolate,
   node <- s.node,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   inActivity <- s.inActivity,
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   isDeterminate <- s.isDeterminate,
   isAssured <- s.isAssured,
   clause <- s.clause,
   result <- s.result
  )
}

rule CopyClause {
 from
  s : UML!Clause
  (
   s.oclIsTypeOf(UML!Clause)
  )
 to
  t : UMLs!Clause (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   test <- s.test,
   body <- s.body,
   predecessorClause <- s.predecessorClause,
   successorClause <- s.successorClause,
   decider <- s.decider,
   bodyOutput <- s.bodyOutput
  )
}

rule CopyLoopNode {
 from
  s : UML!LoopNode
  (
   s.oclIsTypeOf(UML!LoopNode)
  )
 to
  t : UMLs!LoopNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   variable <- s.variable,
   edge <- s.edge,
   mustIsolate <- s.mustIsolate,
   node <- s.node,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   inActivity <- s.inActivity,
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   isTestedFirst <- s.isTestedFirst,
   bodyPart <- s.bodyPart,
   setupPart <- s.setupPart,
   decider <- s.decider,
   test <- s.test,
   result <- s.result,
   loopVariable <- s.loopVariable,
   bodyOutput <- s.bodyOutput,
   loopVariableInput <- s.loopVariableInput
  )
}

rule CopyExpansionNode {
 from
  s : UML!ExpansionNode
  (
   s.oclIsTypeOf(UML!ExpansionNode)
  )
 to
  t : UMLs!ExpansionNode (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   type <- s.type,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   ordering <- s.ordering,
   isControlType <- s.isControlType,
   upperBound <- s.upperBound,
   inState <- s.inState,
   selection <- s.selection,
   regionAsOutput <- s.regionAsOutput,
   regionAsInput <- s.regionAsInput
  )
}

rule CopyExpansionRegion {
 from
  s : UML!ExpansionRegion
  (
   s.oclIsTypeOf(UML!ExpansionRegion)
  )
 to
  t : UMLs!ExpansionRegion (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   output <- s.output,
   input <- s.input,
   context <- s.context,
   localPrecondition <- s.localPrecondition,
   localPostcondition <- s.localPostcondition,
   handler <- s.handler,
   inStructuredNode <- s.inStructuredNode,
   activity <- s.activity,
   outgoing <- s.outgoing,
   incoming <- s.incoming,
   inPartition <- s.inPartition,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inGroup <- s.inGroup,
   redefinedNode <- s.redefinedNode,
   variable <- s.variable,
   edge <- s.edge,
   mustIsolate <- s.mustIsolate,
   node <- s.node,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   inActivity <- s.inActivity,
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   mode <- s.mode,
   inputElement <- s.inputElement,
   outputElement <- s.outputElement
  )
}

rule CopyProtocolTransition {
 from
  s : UML!ProtocolTransition
  (
   s.oclIsTypeOf(UML!ProtocolTransition)
  )
 to
  t : UMLs!ProtocolTransition (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   kind <- s.kind,
   container <- s.container,
   source <- s.source,
   target <- s.target,
   redefinedTransition <- s.redefinedTransition,
   guard <- s.guard,
   effect <- s.effect,
   trigger <- s.trigger,
   postCondition <- s.postCondition,
   referred <- s.referred,
   preCondition <- s.preCondition
  )
}

rule CopyAssociationClass {
 from
  s : UML!AssociationClass
  (
   s.oclIsTypeOf(UML!AssociationClass)
  )
 to
  t : UMLs!AssociationClass (
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedComment <- s.ownedComment,
   name <- s.name,
   visibility <- s.visibility,
   qualifiedName <- s.qualifiedName,
   clientDependency <- s.clientDependency,
   namespace <- s.namespace,
   nameExpression <- s.nameExpression,
   relatedElement <- s.relatedElement,
   elementImport <- s.elementImport,
   packageImport <- s.packageImport,
   ownedRule <- s.ownedRule,
   member <- s.member,
   importedMember <- s.importedMember,
   ownedMember <- s.ownedMember,
   package <- s.package,
   ownedEnd <- s.ownedEnd,
   memberEnd <- s.memberEnd,
   isDerived <- s.isDerived,
   endType <- s.endType,
   navigableOwnedEnd <- s.navigableOwnedEnd,
   isAbstract <- s.isAbstract,
   generalization <- s.generalization,
   powertypeExtent <- s.powertypeExtent,
   feature <- s.feature,
   inheritedMember <- s.inheritedMember,
   redefinedClassifier <- s.redefinedClassifier,
   general <- s.general,
   substitution <- s.substitution,
   attribute <- s.attribute,
   representation <- s.representation,
   collaborationUse <- s.collaborationUse,
   ownedUseCase <- s.ownedUseCase,
   useCase <- s.useCase,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   templateBinding <- s.templateBinding,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   superClass <- s.superClass,
   isActive <- s.isActive,
   ownedReception <- s.ownedReception,
   extension <- s.extension,
   ownedBehavior <- s.ownedBehavior,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedTrigger <- s.ownedTrigger,
   ownedPort <- s.ownedPort,
   ownedAttribute <- s.ownedAttribute,
   part <- s.part,
   role <- s.role,
   ownedConnector <- s.ownedConnector
  )
}
