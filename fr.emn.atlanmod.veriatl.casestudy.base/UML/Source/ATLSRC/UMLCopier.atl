-- @atlcompiler emftvm

module UMLCopier;
create OUT : UMLs from IN : UML;

rule CopyAbstraction {
 from
  s : UML!Abstraction
  (
   s.oclIsTypeOf(MM!Abstraction)
  )
 to
  t : UMLs!Abstraction (
   mapping <- s.mapping,
   client <- s.client,
   supplier <- s.supplier,
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   relatedElement <- s.relatedElement
  )
}

rule CopyAcceptCallAction {
 from
  s : UML!AcceptCallAction
  (
   s.oclIsTypeOf(MM!AcceptCallAction)
  )
 to
  t : UMLs!AcceptCallAction (
   returnInformation <- s.returnInformation,
   isUnmarshall <- s.isUnmarshall,
   result <- s.result,
   trigger <- s.trigger,
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyAcceptEventAction {
 from
  s : UML!AcceptEventAction
  (
   s.oclIsTypeOf(MM!AcceptEventAction)
  )
 to
  t : UMLs!AcceptEventAction (
   isUnmarshall <- s.isUnmarshall,
   result <- s.result,
   trigger <- s.trigger,
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyActionExecutionSpecification {
 from
  s : UML!ActionExecutionSpecification
  (
   s.oclIsTypeOf(MM!ActionExecutionSpecification)
  )
 to
  t : UMLs!ActionExecutionSpecification (
   action <- s.action,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   finish <- s.finish,
   start <- s.start,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyActionInputPin {
 from
  s : UML!ActionInputPin
  (
   s.oclIsTypeOf(MM!ActionInputPin)
  )
 to
  t : UMLs!ActionInputPin (
   fromAction <- s.fromAction,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   lower <- s.lower,
   lowerValue <- s.lowerValue,
   upper <- s.upper,
   upperValue <- s.upperValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   inState <- s.inState,
   isControlType <- s.isControlType,
   ordering <- s.ordering,
   selection <- s.selection,
   upperBound <- s.upperBound,
   isControl <- s.isControl,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   type <- s.type
  )
}

rule CopyActivity {
 from
  s : UML!Activity
  (
   s.oclIsTypeOf(MM!Activity)
  )
 to
  t : UMLs!Activity (
   edge <- s.edge,
   group <- s.group,
   isReadOnly <- s.isReadOnly,
   isSingleExecution <- s.isSingleExecution,
   node <- s.node,
   partition <- s.partition,
   structuredNode <- s.structuredNode,
   variable <- s.variable,
   context <- s.context,
   isReentrant <- s.isReentrant,
   ownedParameter <- s.ownedParameter,
   ownedParameterSet <- s.ownedParameterSet,
   postcondition <- s.postcondition,
   precondition <- s.precondition,
   redefinedBehavior <- s.redefinedBehavior,
   specification <- s.specification,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyActivityFinalNode {
 from
  s : UML!ActivityFinalNode
  (
   s.oclIsTypeOf(MM!ActivityFinalNode)
  )
 to
  t : UMLs!ActivityFinalNode (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyActivityParameterNode {
 from
  s : UML!ActivityParameterNode
  (
   s.oclIsTypeOf(MM!ActivityParameterNode)
  )
 to
  t : UMLs!ActivityParameterNode (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   parameter <- s.parameter,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   inState <- s.inState,
   isControlType <- s.isControlType,
   ordering <- s.ordering,
   selection <- s.selection,
   upperBound <- s.upperBound,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   type <- s.type
  )
}

rule CopyActivityPartition {
 from
  s : UML!ActivityPartition
  (
   s.oclIsTypeOf(MM!ActivityPartition)
  )
 to
  t : UMLs!ActivityPartition (
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   inActivity <- s.inActivity,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   edge <- s.edge,
   isDimension <- s.isDimension,
   isExternal <- s.isExternal,
   node <- s.node,
   represents <- s.represents,
   subpartition <- s.subpartition,
   superPartition <- s.superPartition,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyActor {
 from
  s : UML!Actor
  (
   s.oclIsTypeOf(MM!Actor)
  )
 to
  t : UMLs!Actor (
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyAddStructuralFeatureValueAction {
 from
  s : UML!AddStructuralFeatureValueAction
  (
   s.oclIsTypeOf(MM!AddStructuralFeatureValueAction)
  )
 to
  t : UMLs!AddStructuralFeatureValueAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   insertAt <- s.insertAt,
   isReplaceAll <- s.isReplaceAll,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   object <- s.object,
   structuralFeature <- s.structuralFeature,
   result <- s.result,
   value <- s.value
  )
}

rule CopyAddVariableValueAction {
 from
  s : UML!AddVariableValueAction
  (
   s.oclIsTypeOf(MM!AddVariableValueAction)
  )
 to
  t : UMLs!AddVariableValueAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   insertAt <- s.insertAt,
   isReplaceAll <- s.isReplaceAll,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   variable <- s.variable,
   value <- s.value
  )
}

rule CopyAnyReceiveEvent {
 from
  s : UML!AnyReceiveEvent
  (
   s.oclIsTypeOf(MM!AnyReceiveEvent)
  )
 to
  t : UMLs!AnyReceiveEvent (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyArtifact {
 from
  s : UML!Artifact
  (
   s.oclIsTypeOf(MM!Artifact)
  )
 to
  t : UMLs!Artifact (
   fileName <- s.fileName,
   manifestation <- s.manifestation,
   nestedArtifact <- s.nestedArtifact,
   ownedAttribute <- s.ownedAttribute,
   ownedOperation <- s.ownedOperation,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyAssociation {
 from
  s : UML!Association
  (
   s.oclIsTypeOf(MM!Association)
  )
 to
  t : UMLs!Association (
   endType <- s.endType,
   isDerived <- s.isDerived,
   memberEnd <- s.memberEnd,
   navigableOwnedEnd <- s.navigableOwnedEnd,
   ownedEnd <- s.ownedEnd,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   relatedElement <- s.relatedElement,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyAssociationClass {
 from
  s : UML!AssociationClass
  (
   s.oclIsTypeOf(MM!AssociationClass)
  )
 to
  t : UMLs!AssociationClass (
   endType <- s.endType,
   isDerived <- s.isDerived,
   memberEnd <- s.memberEnd,
   navigableOwnedEnd <- s.navigableOwnedEnd,
   ownedEnd <- s.ownedEnd,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   relatedElement <- s.relatedElement,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyBehaviorExecutionSpecification {
 from
  s : UML!BehaviorExecutionSpecification
  (
   s.oclIsTypeOf(MM!BehaviorExecutionSpecification)
  )
 to
  t : UMLs!BehaviorExecutionSpecification (
   behavior <- s.behavior,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   finish <- s.finish,
   start <- s.start,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyBroadcastSignalAction {
 from
  s : UML!BroadcastSignalAction
  (
   s.oclIsTypeOf(MM!BroadcastSignalAction)
  )
 to
  t : UMLs!BroadcastSignalAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   signal <- s.signal,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   argument <- s.argument,
   onPort <- s.onPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyCallBehaviorAction {
 from
  s : UML!CallBehaviorAction
  (
   s.oclIsTypeOf(MM!CallBehaviorAction)
  )
 to
  t : UMLs!CallBehaviorAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   isSynchronous <- s.isSynchronous,
   result <- s.result,
   behavior <- s.behavior,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   argument <- s.argument,
   onPort <- s.onPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyCallEvent {
 from
  s : UML!CallEvent
  (
   s.oclIsTypeOf(MM!CallEvent)
  )
 to
  t : UMLs!CallEvent (
   operation <- s.operation,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyCallOperationAction {
 from
  s : UML!CallOperationAction
  (
   s.oclIsTypeOf(MM!CallOperationAction)
  )
 to
  t : UMLs!CallOperationAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   isSynchronous <- s.isSynchronous,
   result <- s.result,
   operation <- s.operation,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   argument <- s.argument,
   onPort <- s.onPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyCentralBufferNode {
 from
  s : UML!CentralBufferNode
  (
   s.oclIsTypeOf(MM!CentralBufferNode)
  )
 to
  t : UMLs!CentralBufferNode (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   inState <- s.inState,
   isControlType <- s.isControlType,
   ordering <- s.ordering,
   selection <- s.selection,
   upperBound <- s.upperBound,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   type <- s.type
  )
}

rule CopyChangeEvent {
 from
  s : UML!ChangeEvent
  (
   s.oclIsTypeOf(MM!ChangeEvent)
  )
 to
  t : UMLs!ChangeEvent (
   changeExpression <- s.changeExpression,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyClass {
 from
  s : UML!Class
  (
   s.oclIsTypeOf(MM!Class)
  )
 to
  t : UMLs!Class (
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyClassifierTemplateParameter {
 from
  s : UML!ClassifierTemplateParameter
  (
   s.oclIsTypeOf(MM!ClassifierTemplateParameter)
  )
 to
  t : UMLs!ClassifierTemplateParameter (
   allowSubstitutable <- s.allowSubstitutable,
   constrainingClassifier <- s.constrainingClassifier,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   default <- s.default,
   ownedDefault <- s.ownedDefault,
   ownedParameteredElement <- s.ownedParameteredElement,
   parameteredElement <- s.parameteredElement
  )
}

rule CopyClause {
 from
  s : UML!Clause
  (
   s.oclIsTypeOf(MM!Clause)
  )
 to
  t : UMLs!Clause (
   body <- s.body,
   bodyOutput <- s.bodyOutput,
   decider <- s.decider,
   predecessorClause <- s.predecessorClause,
   successorClause <- s.successorClause,
   test <- s.test,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner
  )
}

rule CopyClearAssociationAction {
 from
  s : UML!ClearAssociationAction
  (
   s.oclIsTypeOf(MM!ClearAssociationAction)
  )
 to
  t : UMLs!ClearAssociationAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   association <- s.association,
   object <- s.object,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyClearStructuralFeatureAction {
 from
  s : UML!ClearStructuralFeatureAction
  (
   s.oclIsTypeOf(MM!ClearStructuralFeatureAction)
  )
 to
  t : UMLs!ClearStructuralFeatureAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   result <- s.result,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   object <- s.object,
   structuralFeature <- s.structuralFeature
  )
}

rule CopyClearVariableAction {
 from
  s : UML!ClearVariableAction
  (
   s.oclIsTypeOf(MM!ClearVariableAction)
  )
 to
  t : UMLs!ClearVariableAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   variable <- s.variable
  )
}

rule CopyCollaboration {
 from
  s : UML!Collaboration
  (
   s.oclIsTypeOf(MM!Collaboration)
  )
 to
  t : UMLs!Collaboration (
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   collaborationRole <- s.collaborationRole,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyCollaborationUse {
 from
  s : UML!CollaborationUse
  (
   s.oclIsTypeOf(MM!CollaborationUse)
  )
 to
  t : UMLs!CollaborationUse (
   roleBinding <- s.roleBinding,
   type <- s.type,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyCombinedFragment {
 from
  s : UML!CombinedFragment
  (
   s.oclIsTypeOf(MM!CombinedFragment)
  )
 to
  t : UMLs!CombinedFragment (
   cfragmentGate <- s.cfragmentGate,
   interactionOperator <- s.interactionOperator,
   operand <- s.operand,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyComment {
 from
  s : UML!Comment
  (
   s.oclIsTypeOf(MM!Comment)
  )
 to
  t : UMLs!Comment (
   annotatedElement <- s.annotatedElement,
   body <- s.body,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner
  )
}

rule CopyCommunicationPath {
 from
  s : UML!CommunicationPath
  (
   s.oclIsTypeOf(MM!CommunicationPath)
  )
 to
  t : UMLs!CommunicationPath (
   endType <- s.endType,
   isDerived <- s.isDerived,
   memberEnd <- s.memberEnd,
   navigableOwnedEnd <- s.navigableOwnedEnd,
   ownedEnd <- s.ownedEnd,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   relatedElement <- s.relatedElement,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyComponent {
 from
  s : UML!Component
  (
   s.oclIsTypeOf(MM!Component)
  )
 to
  t : UMLs!Component (
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   isIndirectlyInstantiated <- s.isIndirectlyInstantiated,
   packagedElement <- s.packagedElement,
   provided <- s.provided,
   realization <- s.realization,
   required <- s.required,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyComponentRealization {
 from
  s : UML!ComponentRealization
  (
   s.oclIsTypeOf(MM!ComponentRealization)
  )
 to
  t : UMLs!ComponentRealization (
   mapping <- s.mapping,
   abstraction <- s.abstraction,
   realizingClassifier <- s.realizingClassifier,
   client <- s.client,
   supplier <- s.supplier,
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   relatedElement <- s.relatedElement
  )
}

rule CopyConditionalNode {
 from
  s : UML!ConditionalNode
  (
   s.oclIsTypeOf(MM!ConditionalNode)
  )
 to
  t : UMLs!ConditionalNode (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   inActivity <- s.inActivity,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   clause <- s.clause,
   isAssured <- s.isAssured,
   isDeterminate <- s.isDeterminate,
   result <- s.result,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   edge <- s.edge,
   mustIsolate <- s.mustIsolate,
   node <- s.node,
   structuredNodeInput <- s.structuredNodeInput,
   structuredNodeOutput <- s.structuredNodeOutput,
   variable <- s.variable
  )
}

rule CopyConnectableElementTemplateParameter {
 from
  s : UML!ConnectableElementTemplateParameter
  (
   s.oclIsTypeOf(MM!ConnectableElementTemplateParameter)
  )
 to
  t : UMLs!ConnectableElementTemplateParameter (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   default <- s.default,
   ownedDefault <- s.ownedDefault,
   ownedParameteredElement <- s.ownedParameteredElement,
   parameteredElement <- s.parameteredElement
  )
}

rule CopyConnectionPointReference {
 from
  s : UML!ConnectionPointReference
  (
   s.oclIsTypeOf(MM!ConnectionPointReference)
  )
 to
  t : UMLs!ConnectionPointReference (
   entry <- s.entry,
   exit <- s.exit,
   state <- s.state,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   container <- s.container,
   incoming <- s.incoming,
   outgoing <- s.outgoing
  )
}

rule CopyConnector {
 from
  s : UML!Connector
  (
   s.oclIsTypeOf(MM!Connector)
  )
 to
  t : UMLs!Connector (
   contract <- s.contract,
   end <- s.end,
   kind <- s.kind,
   redefinedConnector <- s.redefinedConnector,
   type <- s.type,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   featuringClassifier <- s.featuringClassifier,
   isStatic <- s.isStatic,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyConnectorEnd {
 from
  s : UML!ConnectorEnd
  (
   s.oclIsTypeOf(MM!ConnectorEnd)
  )
 to
  t : UMLs!ConnectorEnd (
   definingEnd <- s.definingEnd,
   partWithPort <- s.partWithPort,
   role <- s.role,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   lower <- s.lower,
   lowerValue <- s.lowerValue,
   upper <- s.upper,
   upperValue <- s.upperValue
  )
}

rule CopyConsiderIgnoreFragment {
 from
  s : UML!ConsiderIgnoreFragment
  (
   s.oclIsTypeOf(MM!ConsiderIgnoreFragment)
  )
 to
  t : UMLs!ConsiderIgnoreFragment (
   cfragmentGate <- s.cfragmentGate,
   interactionOperator <- s.interactionOperator,
   operand <- s.operand,
   message <- s.message,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyConstraint {
 from
  s : UML!Constraint
  (
   s.oclIsTypeOf(MM!Constraint)
  )
 to
  t : UMLs!Constraint (
   constrainedElement <- s.constrainedElement,
   context <- s.context,
   specification <- s.specification,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyContinuation {
 from
  s : UML!Continuation
  (
   s.oclIsTypeOf(MM!Continuation)
  )
 to
  t : UMLs!Continuation (
   setting <- s.setting,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyControlFlow {
 from
  s : UML!ControlFlow
  (
   s.oclIsTypeOf(MM!ControlFlow)
  )
 to
  t : UMLs!ControlFlow (
   activity <- s.activity,
   guard <- s.guard,
   inGroup <- s.inGroup,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   interrupts <- s.interrupts,
   redefinedEdge <- s.redefinedEdge,
   source <- s.source,
   target <- s.target,
   weight <- s.weight,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyCreateLinkAction {
 from
  s : UML!CreateLinkAction
  (
   s.oclIsTypeOf(MM!CreateLinkAction)
  )
 to
  t : UMLs!CreateLinkAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   endData <- s.endData,
   inputValue <- s.inputValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyCreateLinkObjectAction {
 from
  s : UML!CreateLinkObjectAction
  (
   s.oclIsTypeOf(MM!CreateLinkObjectAction)
  )
 to
  t : UMLs!CreateLinkObjectAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   result <- s.result,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   endData <- s.endData,
   inputValue <- s.inputValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyCreateObjectAction {
 from
  s : UML!CreateObjectAction
  (
   s.oclIsTypeOf(MM!CreateObjectAction)
  )
 to
  t : UMLs!CreateObjectAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   classifier <- s.classifier,
   result <- s.result,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyDataStoreNode {
 from
  s : UML!DataStoreNode
  (
   s.oclIsTypeOf(MM!DataStoreNode)
  )
 to
  t : UMLs!DataStoreNode (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   inState <- s.inState,
   isControlType <- s.isControlType,
   ordering <- s.ordering,
   selection <- s.selection,
   upperBound <- s.upperBound,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   type <- s.type
  )
}

rule CopyDataType {
 from
  s : UML!DataType
  (
   s.oclIsTypeOf(MM!DataType)
  )
 to
  t : UMLs!DataType (
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedAttribute <- s.ownedAttribute,
   ownedOperation <- s.ownedOperation,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyDecisionNode {
 from
  s : UML!DecisionNode
  (
   s.oclIsTypeOf(MM!DecisionNode)
  )
 to
  t : UMLs!DecisionNode (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   decisionInput <- s.decisionInput,
   decisionInputFlow <- s.decisionInputFlow,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyDependency {
 from
  s : UML!Dependency
  (
   s.oclIsTypeOf(MM!Dependency)
  )
 to
  t : UMLs!Dependency (
   client <- s.client,
   supplier <- s.supplier,
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   relatedElement <- s.relatedElement
  )
}

rule CopyDeployment {
 from
  s : UML!Deployment
  (
   s.oclIsTypeOf(MM!Deployment)
  )
 to
  t : UMLs!Deployment (
   client <- s.client,
   supplier <- s.supplier,
   configuration <- s.configuration,
   deployedArtifact <- s.deployedArtifact,
   location <- s.location,
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   relatedElement <- s.relatedElement
  )
}

rule CopyDeploymentSpecification {
 from
  s : UML!DeploymentSpecification
  (
   s.oclIsTypeOf(MM!DeploymentSpecification)
  )
 to
  t : UMLs!DeploymentSpecification (
   fileName <- s.fileName,
   manifestation <- s.manifestation,
   nestedArtifact <- s.nestedArtifact,
   ownedAttribute <- s.ownedAttribute,
   ownedOperation <- s.ownedOperation,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   deployment <- s.deployment,
   deploymentLocation <- s.deploymentLocation,
   executionLocation <- s.executionLocation,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyDestroyLinkAction {
 from
  s : UML!DestroyLinkAction
  (
   s.oclIsTypeOf(MM!DestroyLinkAction)
  )
 to
  t : UMLs!DestroyLinkAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   endData <- s.endData,
   inputValue <- s.inputValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyDestroyObjectAction {
 from
  s : UML!DestroyObjectAction
  (
   s.oclIsTypeOf(MM!DestroyObjectAction)
  )
 to
  t : UMLs!DestroyObjectAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   isDestroyLinks <- s.isDestroyLinks,
   isDestroyOwnedObjects <- s.isDestroyOwnedObjects,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyDestructionOccurrenceSpecification {
 from
  s : UML!DestructionOccurrenceSpecification
  (
   s.oclIsTypeOf(MM!DestructionOccurrenceSpecification)
  )
 to
  t : UMLs!DestructionOccurrenceSpecification (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   message <- s.message,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   toAfter <- s.toAfter,
   toBefore <- s.toBefore
  )
}

rule CopyDevice {
 from
  s : UML!Device
  (
   s.oclIsTypeOf(MM!Device)
  )
 to
  t : UMLs!Device (
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   deployedElement <- s.deployedElement,
   deployment <- s.deployment,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   nestedNode <- s.nestedNode,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyDuration {
 from
  s : UML!Duration
  (
   s.oclIsTypeOf(MM!Duration)
  )
 to
  t : UMLs!Duration (
   expr <- s.expr,
   observation <- s.observation,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyDurationConstraint {
 from
  s : UML!DurationConstraint
  (
   s.oclIsTypeOf(MM!DurationConstraint)
  )
 to
  t : UMLs!DurationConstraint (
   constrainedElement <- s.constrainedElement,
   context <- s.context,
   specification <- s.specification,
   firstEvent <- s.firstEvent,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyDurationInterval {
 from
  s : UML!DurationInterval
  (
   s.oclIsTypeOf(MM!DurationInterval)
  )
 to
  t : UMLs!DurationInterval (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   max <- s.max,
   min <- s.min,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyDurationObservation {
 from
  s : UML!DurationObservation
  (
   s.oclIsTypeOf(MM!DurationObservation)
  )
 to
  t : UMLs!DurationObservation (
   event <- s.event,
   firstEvent <- s.firstEvent,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyElementImport {
 from
  s : UML!ElementImport
  (
   s.oclIsTypeOf(MM!ElementImport)
  )
 to
  t : UMLs!ElementImport (
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   alias <- s.alias,
   importedElement <- s.importedElement,
   importingNamespace <- s.importingNamespace,
   visibility <- s.visibility,
   relatedElement <- s.relatedElement
  )
}

rule CopyEnumeration {
 from
  s : UML!Enumeration
  (
   s.oclIsTypeOf(MM!Enumeration)
  )
 to
  t : UMLs!Enumeration (
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedAttribute <- s.ownedAttribute,
   ownedOperation <- s.ownedOperation,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedLiteral <- s.ownedLiteral,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyEnumerationLiteral {
 from
  s : UML!EnumerationLiteral
  (
   s.oclIsTypeOf(MM!EnumerationLiteral)
  )
 to
  t : UMLs!EnumerationLiteral (
   deployedElement <- s.deployedElement,
   deployment <- s.deployment,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   classifier <- s.classifier,
   slot <- s.slot,
   specification <- s.specification,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyExceptionHandler {
 from
  s : UML!ExceptionHandler
  (
   s.oclIsTypeOf(MM!ExceptionHandler)
  )
 to
  t : UMLs!ExceptionHandler (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   exceptionInput <- s.exceptionInput,
   exceptionType <- s.exceptionType,
   handlerBody <- s.handlerBody,
   protectedNode <- s.protectedNode
  )
}

rule CopyExecutionEnvironment {
 from
  s : UML!ExecutionEnvironment
  (
   s.oclIsTypeOf(MM!ExecutionEnvironment)
  )
 to
  t : UMLs!ExecutionEnvironment (
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   deployedElement <- s.deployedElement,
   deployment <- s.deployment,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   nestedNode <- s.nestedNode,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyExecutionOccurrenceSpecification {
 from
  s : UML!ExecutionOccurrenceSpecification
  (
   s.oclIsTypeOf(MM!ExecutionOccurrenceSpecification)
  )
 to
  t : UMLs!ExecutionOccurrenceSpecification (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   execution <- s.execution,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   toAfter <- s.toAfter,
   toBefore <- s.toBefore
  )
}

rule CopyExpansionNode {
 from
  s : UML!ExpansionNode
  (
   s.oclIsTypeOf(MM!ExpansionNode)
  )
 to
  t : UMLs!ExpansionNode (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   regionAsInput <- s.regionAsInput,
   regionAsOutput <- s.regionAsOutput,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   inState <- s.inState,
   isControlType <- s.isControlType,
   ordering <- s.ordering,
   selection <- s.selection,
   upperBound <- s.upperBound,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   type <- s.type
  )
}

rule CopyExpansionRegion {
 from
  s : UML!ExpansionRegion
  (
   s.oclIsTypeOf(MM!ExpansionRegion)
  )
 to
  t : UMLs!ExpansionRegion (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   inActivity <- s.inActivity,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   inputElement <- s.inputElement,
   mode <- s.mode,
   outputElement <- s.outputElement,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   edge <- s.edge,
   mustIsolate <- s.mustIsolate,
   node <- s.node,
   structuredNodeInput <- s.structuredNodeInput,
   structuredNodeOutput <- s.structuredNodeOutput,
   variable <- s.variable
  )
}

rule CopyExpression {
 from
  s : UML!Expression
  (
   s.oclIsTypeOf(MM!Expression)
  )
 to
  t : UMLs!Expression (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   operand <- s.operand,
   symbol <- s.symbol,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyExtend {
 from
  s : UML!Extend
  (
   s.oclIsTypeOf(MM!Extend)
  )
 to
  t : UMLs!Extend (
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   condition <- s.condition,
   extendedCase <- s.extendedCase,
   extension <- s.extension,
   extensionLocation <- s.extensionLocation,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   relatedElement <- s.relatedElement
  )
}

rule CopyExtension {
 from
  s : UML!Extension
  (
   s.oclIsTypeOf(MM!Extension)
  )
 to
  t : UMLs!Extension (
   endType <- s.endType,
   isDerived <- s.isDerived,
   memberEnd <- s.memberEnd,
   navigableOwnedEnd <- s.navigableOwnedEnd,
   ownedEnd <- s.ownedEnd,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   isRequired <- s.isRequired,
   metaclass <- s.metaclass,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   relatedElement <- s.relatedElement,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyExtensionEnd {
 from
  s : UML!ExtensionEnd
  (
   s.oclIsTypeOf(MM!ExtensionEnd)
  )
 to
  t : UMLs!ExtensionEnd (
   end <- s.end,
   deployedElement <- s.deployedElement,
   deployment <- s.deployment,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   featuringClassifier <- s.featuringClassifier,
   isStatic <- s.isStatic,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   lower <- s.lower,
   lowerValue <- s.lowerValue,
   upper <- s.upper,
   upperValue <- s.upperValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   aggregation <- s.aggregation,
   class <- s.class,
   defaultValue <- s.defaultValue,
   isComposite <- s.isComposite,
   isDerived <- s.isDerived,
   isDerivedUnion <- s.isDerivedUnion,
   isID <- s.isID,
   opposite <- s.opposite,
   qualifier <- s.qualifier,
   redefinedProperty <- s.redefinedProperty,
   subsettedProperty <- s.subsettedProperty,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   isReadOnly <- s.isReadOnly,
   type <- s.type
  )
}

rule CopyExtensionPoint {
 from
  s : UML!ExtensionPoint
  (
   s.oclIsTypeOf(MM!ExtensionPoint)
  )
 to
  t : UMLs!ExtensionPoint (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   useCase <- s.useCase,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyFinalState {
 from
  s : UML!FinalState
  (
   s.oclIsTypeOf(MM!FinalState)
  )
 to
  t : UMLs!FinalState (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   connection <- s.connection,
   connectionPoint <- s.connectionPoint,
   deferrableTrigger <- s.deferrableTrigger,
   doActivity <- s.doActivity,
   entry <- s.entry,
   exit <- s.exit,
   isComposite <- s.isComposite,
   isOrthogonal <- s.isOrthogonal,
   isSimple <- s.isSimple,
   isSubmachineState <- s.isSubmachineState,
   redefinedState <- s.redefinedState,
   region <- s.region,
   stateInvariant <- s.stateInvariant,
   submachine <- s.submachine,
   container <- s.container,
   incoming <- s.incoming,
   outgoing <- s.outgoing
  )
}

rule CopyFlowFinalNode {
 from
  s : UML!FlowFinalNode
  (
   s.oclIsTypeOf(MM!FlowFinalNode)
  )
 to
  t : UMLs!FlowFinalNode (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyForkNode {
 from
  s : UML!ForkNode
  (
   s.oclIsTypeOf(MM!ForkNode)
  )
 to
  t : UMLs!ForkNode (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyFunctionBehavior {
 from
  s : UML!FunctionBehavior
  (
   s.oclIsTypeOf(MM!FunctionBehavior)
  )
 to
  t : UMLs!FunctionBehavior (
   context <- s.context,
   isReentrant <- s.isReentrant,
   ownedParameter <- s.ownedParameter,
   ownedParameterSet <- s.ownedParameterSet,
   postcondition <- s.postcondition,
   precondition <- s.precondition,
   redefinedBehavior <- s.redefinedBehavior,
   specification <- s.specification,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   body <- s.body,
   language <- s.language,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyGate {
 from
  s : UML!Gate
  (
   s.oclIsTypeOf(MM!Gate)
  )
 to
  t : UMLs!Gate (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   message <- s.message,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyGeneralOrdering {
 from
  s : UML!GeneralOrdering
  (
   s.oclIsTypeOf(MM!GeneralOrdering)
  )
 to
  t : UMLs!GeneralOrdering (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   after <- s.after,
   before <- s.before,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyGeneralization {
 from
  s : UML!Generalization
  (
   s.oclIsTypeOf(MM!Generalization)
  )
 to
  t : UMLs!Generalization (
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   general <- s.general,
   generalizationSet <- s.generalizationSet,
   isSubstitutable <- s.isSubstitutable,
   specific <- s.specific,
   relatedElement <- s.relatedElement
  )
}

rule CopyGeneralizationSet {
 from
  s : UML!GeneralizationSet
  (
   s.oclIsTypeOf(MM!GeneralizationSet)
  )
 to
  t : UMLs!GeneralizationSet (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   generalization <- s.generalization,
   isCovering <- s.isCovering,
   isDisjoint <- s.isDisjoint,
   powertype <- s.powertype,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyImage {
 from
  s : UML!Image
  (
   s.oclIsTypeOf(MM!Image)
  )
 to
  t : UMLs!Image (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   content <- s.content,
   format <- s.format,
   location <- s.location
  )
}

rule CopyInclude {
 from
  s : UML!Include
  (
   s.oclIsTypeOf(MM!Include)
  )
 to
  t : UMLs!Include (
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   addition <- s.addition,
   includingCase <- s.includingCase,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   relatedElement <- s.relatedElement
  )
}

rule CopyInformationFlow {
 from
  s : UML!InformationFlow
  (
   s.oclIsTypeOf(MM!InformationFlow)
  )
 to
  t : UMLs!InformationFlow (
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   conveyed <- s.conveyed,
   informationSource <- s.informationSource,
   informationTarget <- s.informationTarget,
   realization <- s.realization,
   realizingActivityEdge <- s.realizingActivityEdge,
   realizingConnector <- s.realizingConnector,
   realizingMessage <- s.realizingMessage,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   relatedElement <- s.relatedElement
  )
}

rule CopyInformationItem {
 from
  s : UML!InformationItem
  (
   s.oclIsTypeOf(MM!InformationItem)
  )
 to
  t : UMLs!InformationItem (
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   represented <- s.represented,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyInitialNode {
 from
  s : UML!InitialNode
  (
   s.oclIsTypeOf(MM!InitialNode)
  )
 to
  t : UMLs!InitialNode (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyInputPin {
 from
  s : UML!InputPin
  (
   s.oclIsTypeOf(MM!InputPin)
  )
 to
  t : UMLs!InputPin (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   lower <- s.lower,
   lowerValue <- s.lowerValue,
   upper <- s.upper,
   upperValue <- s.upperValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   inState <- s.inState,
   isControlType <- s.isControlType,
   ordering <- s.ordering,
   selection <- s.selection,
   upperBound <- s.upperBound,
   isControl <- s.isControl,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   type <- s.type
  )
}

rule CopyInstanceSpecification {
 from
  s : UML!InstanceSpecification
  (
   s.oclIsTypeOf(MM!InstanceSpecification)
  )
 to
  t : UMLs!InstanceSpecification (
   deployedElement <- s.deployedElement,
   deployment <- s.deployment,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   classifier <- s.classifier,
   slot <- s.slot,
   specification <- s.specification,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyInstanceValue {
 from
  s : UML!InstanceValue
  (
   s.oclIsTypeOf(MM!InstanceValue)
  )
 to
  t : UMLs!InstanceValue (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   instance <- s.instance,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyInteraction {
 from
  s : UML!Interaction
  (
   s.oclIsTypeOf(MM!Interaction)
  )
 to
  t : UMLs!Interaction (
   context <- s.context,
   isReentrant <- s.isReentrant,
   ownedParameter <- s.ownedParameter,
   ownedParameterSet <- s.ownedParameterSet,
   postcondition <- s.postcondition,
   precondition <- s.precondition,
   redefinedBehavior <- s.redefinedBehavior,
   specification <- s.specification,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   action <- s.action,
   formalGate <- s.formalGate,
   fragment <- s.fragment,
   lifeline <- s.lifeline,
   message <- s.message,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyInteractionConstraint {
 from
  s : UML!InteractionConstraint
  (
   s.oclIsTypeOf(MM!InteractionConstraint)
  )
 to
  t : UMLs!InteractionConstraint (
   constrainedElement <- s.constrainedElement,
   context <- s.context,
   specification <- s.specification,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   maxint <- s.maxint,
   minint <- s.minint,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyInteractionOperand {
 from
  s : UML!InteractionOperand
  (
   s.oclIsTypeOf(MM!InteractionOperand)
  )
 to
  t : UMLs!InteractionOperand (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   fragment <- s.fragment,
   guard <- s.guard,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport
  )
}

rule CopyInteractionUse {
 from
  s : UML!InteractionUse
  (
   s.oclIsTypeOf(MM!InteractionUse)
  )
 to
  t : UMLs!InteractionUse (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   actualGate <- s.actualGate,
   argument <- s.argument,
   refersTo <- s.refersTo,
   returnValue <- s.returnValue,
   returnValueRecipient <- s.returnValueRecipient,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyInterface {
 from
  s : UML!Interface
  (
   s.oclIsTypeOf(MM!Interface)
  )
 to
  t : UMLs!Interface (
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   nestedClassifier <- s.nestedClassifier,
   ownedAttribute <- s.ownedAttribute,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   protocol <- s.protocol,
   redefinedInterface <- s.redefinedInterface,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyInterfaceRealization {
 from
  s : UML!InterfaceRealization
  (
   s.oclIsTypeOf(MM!InterfaceRealization)
  )
 to
  t : UMLs!InterfaceRealization (
   mapping <- s.mapping,
   client <- s.client,
   supplier <- s.supplier,
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   contract <- s.contract,
   implementingClassifier <- s.implementingClassifier,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   relatedElement <- s.relatedElement
  )
}

rule CopyInterruptibleActivityRegion {
 from
  s : UML!InterruptibleActivityRegion
  (
   s.oclIsTypeOf(MM!InterruptibleActivityRegion)
  )
 to
  t : UMLs!InterruptibleActivityRegion (
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   inActivity <- s.inActivity,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   interruptingEdge <- s.interruptingEdge,
   node <- s.node,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyInterval {
 from
  s : UML!Interval
  (
   s.oclIsTypeOf(MM!Interval)
  )
 to
  t : UMLs!Interval (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   max <- s.max,
   min <- s.min,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyIntervalConstraint {
 from
  s : UML!IntervalConstraint
  (
   s.oclIsTypeOf(MM!IntervalConstraint)
  )
 to
  t : UMLs!IntervalConstraint (
   constrainedElement <- s.constrainedElement,
   context <- s.context,
   specification <- s.specification,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter
  )
}

rule CopyJoinNode {
 from
  s : UML!JoinNode
  (
   s.oclIsTypeOf(MM!JoinNode)
  )
 to
  t : UMLs!JoinNode (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   isCombineDuplicate <- s.isCombineDuplicate,
   joinSpec <- s.joinSpec,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyLifeline {
 from
  s : UML!Lifeline
  (
   s.oclIsTypeOf(MM!Lifeline)
  )
 to
  t : UMLs!Lifeline (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   coveredBy <- s.coveredBy,
   decomposedAs <- s.decomposedAs,
   interaction <- s.interaction,
   represents <- s.represents,
   selector <- s.selector,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyLinkEndCreationData {
 from
  s : UML!LinkEndCreationData
  (
   s.oclIsTypeOf(MM!LinkEndCreationData)
  )
 to
  t : UMLs!LinkEndCreationData (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   insertAt <- s.insertAt,
   isReplaceAll <- s.isReplaceAll,
   end <- s.end,
   qualifier <- s.qualifier,
   value <- s.value
  )
}

rule CopyLinkEndData {
 from
  s : UML!LinkEndData
  (
   s.oclIsTypeOf(MM!LinkEndData)
  )
 to
  t : UMLs!LinkEndData (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   end <- s.end,
   qualifier <- s.qualifier,
   value <- s.value
  )
}

rule CopyLinkEndDestructionData {
 from
  s : UML!LinkEndDestructionData
  (
   s.oclIsTypeOf(MM!LinkEndDestructionData)
  )
 to
  t : UMLs!LinkEndDestructionData (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   end <- s.end,
   qualifier <- s.qualifier,
   value <- s.value,
   destroyAt <- s.destroyAt,
   isDestroyDuplicates <- s.isDestroyDuplicates
  )
}

rule CopyLiteralBoolean {
 from
  s : UML!LiteralBoolean
  (
   s.oclIsTypeOf(MM!LiteralBoolean)
  )
 to
  t : UMLs!LiteralBoolean (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   value <- s.value,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyLiteralInteger {
 from
  s : UML!LiteralInteger
  (
   s.oclIsTypeOf(MM!LiteralInteger)
  )
 to
  t : UMLs!LiteralInteger (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   value <- s.value,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyLiteralNull {
 from
  s : UML!LiteralNull
  (
   s.oclIsTypeOf(MM!LiteralNull)
  )
 to
  t : UMLs!LiteralNull (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyLiteralReal {
 from
  s : UML!LiteralReal
  (
   s.oclIsTypeOf(MM!LiteralReal)
  )
 to
  t : UMLs!LiteralReal (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   value <- s.value,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyLiteralString {
 from
  s : UML!LiteralString
  (
   s.oclIsTypeOf(MM!LiteralString)
  )
 to
  t : UMLs!LiteralString (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   value <- s.value,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyLiteralUnlimitedNatural {
 from
  s : UML!LiteralUnlimitedNatural
  (
   s.oclIsTypeOf(MM!LiteralUnlimitedNatural)
  )
 to
  t : UMLs!LiteralUnlimitedNatural (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   value <- s.value,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyLoopNode {
 from
  s : UML!LoopNode
  (
   s.oclIsTypeOf(MM!LoopNode)
  )
 to
  t : UMLs!LoopNode (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   inActivity <- s.inActivity,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   bodyOutput <- s.bodyOutput,
   bodyPart <- s.bodyPart,
   decider <- s.decider,
   isTestedFirst <- s.isTestedFirst,
   loopVariable <- s.loopVariable,
   loopVariableInput <- s.loopVariableInput,
   result <- s.result,
   setupPart <- s.setupPart,
   test <- s.test,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   edge <- s.edge,
   mustIsolate <- s.mustIsolate,
   node <- s.node,
   structuredNodeInput <- s.structuredNodeInput,
   structuredNodeOutput <- s.structuredNodeOutput,
   variable <- s.variable
  )
}

rule CopyManifestation {
 from
  s : UML!Manifestation
  (
   s.oclIsTypeOf(MM!Manifestation)
  )
 to
  t : UMLs!Manifestation (
   mapping <- s.mapping,
   client <- s.client,
   supplier <- s.supplier,
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   utilizedElement <- s.utilizedElement,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   relatedElement <- s.relatedElement
  )
}

rule CopyMergeNode {
 from
  s : UML!MergeNode
  (
   s.oclIsTypeOf(MM!MergeNode)
  )
 to
  t : UMLs!MergeNode (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyMessage {
 from
  s : UML!Message
  (
   s.oclIsTypeOf(MM!Message)
  )
 to
  t : UMLs!Message (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   argument <- s.argument,
   connector <- s.connector,
   interaction <- s.interaction,
   messageKind <- s.messageKind,
   messageSort <- s.messageSort,
   receiveEvent <- s.receiveEvent,
   sendEvent <- s.sendEvent,
   signature <- s.signature,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyMessageOccurrenceSpecification {
 from
  s : UML!MessageOccurrenceSpecification
  (
   s.oclIsTypeOf(MM!MessageOccurrenceSpecification)
  )
 to
  t : UMLs!MessageOccurrenceSpecification (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   message <- s.message,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   toAfter <- s.toAfter,
   toBefore <- s.toBefore
  )
}

rule CopyModel {
 from
  s : UML!Model
  (
   s.oclIsTypeOf(MM!Model)
  )
 to
  t : UMLs!Model (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   viewpoint <- s.viewpoint,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   URI <- s.URI,
   nestedPackage <- s.nestedPackage,
   nestingPackage <- s.nestingPackage,
   ownedStereotype <- s.ownedStereotype,
   ownedType <- s.ownedType,
   packageMerge <- s.packageMerge,
   packagedElement <- s.packagedElement,
   profileApplication <- s.profileApplication,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding
  )
}

rule CopyNode {
 from
  s : UML!Node
  (
   s.oclIsTypeOf(MM!Node)
  )
 to
  t : UMLs!Node (
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   deployedElement <- s.deployedElement,
   deployment <- s.deployment,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   nestedNode <- s.nestedNode,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyObjectFlow {
 from
  s : UML!ObjectFlow
  (
   s.oclIsTypeOf(MM!ObjectFlow)
  )
 to
  t : UMLs!ObjectFlow (
   activity <- s.activity,
   guard <- s.guard,
   inGroup <- s.inGroup,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   interrupts <- s.interrupts,
   redefinedEdge <- s.redefinedEdge,
   source <- s.source,
   target <- s.target,
   weight <- s.weight,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isMulticast <- s.isMulticast,
   isMultireceive <- s.isMultireceive,
   selection <- s.selection,
   transformation <- s.transformation,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyOccurrenceSpecification {
 from
  s : UML!OccurrenceSpecification
  (
   s.oclIsTypeOf(MM!OccurrenceSpecification)
  )
 to
  t : UMLs!OccurrenceSpecification (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   toAfter <- s.toAfter,
   toBefore <- s.toBefore
  )
}

rule CopyOpaqueAction {
 from
  s : UML!OpaqueAction
  (
   s.oclIsTypeOf(MM!OpaqueAction)
  )
 to
  t : UMLs!OpaqueAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   body <- s.body,
   inputValue <- s.inputValue,
   language <- s.language,
   outputValue <- s.outputValue,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyOpaqueBehavior {
 from
  s : UML!OpaqueBehavior
  (
   s.oclIsTypeOf(MM!OpaqueBehavior)
  )
 to
  t : UMLs!OpaqueBehavior (
   context <- s.context,
   isReentrant <- s.isReentrant,
   ownedParameter <- s.ownedParameter,
   ownedParameterSet <- s.ownedParameterSet,
   postcondition <- s.postcondition,
   precondition <- s.precondition,
   redefinedBehavior <- s.redefinedBehavior,
   specification <- s.specification,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   body <- s.body,
   language <- s.language,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyOpaqueExpression {
 from
  s : UML!OpaqueExpression
  (
   s.oclIsTypeOf(MM!OpaqueExpression)
  )
 to
  t : UMLs!OpaqueExpression (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   behavior <- s.behavior,
   body <- s.body,
   language <- s.language,
   result <- s.result,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyOperation {
 from
  s : UML!Operation
  (
   s.oclIsTypeOf(MM!Operation)
  )
 to
  t : UMLs!Operation (
   concurrency <- s.concurrency,
   isAbstract <- s.isAbstract,
   method <- s.method,
   ownedParameter <- s.ownedParameter,
   ownedParameterSet <- s.ownedParameterSet,
   raisedException <- s.raisedException,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   featuringClassifier <- s.featuringClassifier,
   isStatic <- s.isStatic,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   bodyCondition <- s.bodyCondition,
   isOrdered <- s.isOrdered,
   isQuery <- s.isQuery,
   isUnique <- s.isUnique,
   lower <- s.lower,
   postcondition <- s.postcondition,
   precondition <- s.precondition,
   redefinedOperation <- s.redefinedOperation,
   type <- s.type,
   upper <- s.upper,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding
  )
}

rule CopyOperationTemplateParameter {
 from
  s : UML!OperationTemplateParameter
  (
   s.oclIsTypeOf(MM!OperationTemplateParameter)
  )
 to
  t : UMLs!OperationTemplateParameter (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   default <- s.default,
   ownedDefault <- s.ownedDefault,
   ownedParameteredElement <- s.ownedParameteredElement,
   parameteredElement <- s.parameteredElement
  )
}

rule CopyOutputPin {
 from
  s : UML!OutputPin
  (
   s.oclIsTypeOf(MM!OutputPin)
  )
 to
  t : UMLs!OutputPin (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   lower <- s.lower,
   lowerValue <- s.lowerValue,
   upper <- s.upper,
   upperValue <- s.upperValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   inState <- s.inState,
   isControlType <- s.isControlType,
   ordering <- s.ordering,
   selection <- s.selection,
   upperBound <- s.upperBound,
   isControl <- s.isControl,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   type <- s.type
  )
}

rule CopyPackage {
 from
  s : UML!Package
  (
   s.oclIsTypeOf(MM!Package)
  )
 to
  t : UMLs!Package (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   URI <- s.URI,
   nestedPackage <- s.nestedPackage,
   nestingPackage <- s.nestingPackage,
   ownedStereotype <- s.ownedStereotype,
   ownedType <- s.ownedType,
   packageMerge <- s.packageMerge,
   packagedElement <- s.packagedElement,
   profileApplication <- s.profileApplication,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding
  )
}

rule CopyPackageImport {
 from
  s : UML!PackageImport
  (
   s.oclIsTypeOf(MM!PackageImport)
  )
 to
  t : UMLs!PackageImport (
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   importedPackage <- s.importedPackage,
   importingNamespace <- s.importingNamespace,
   visibility <- s.visibility,
   relatedElement <- s.relatedElement
  )
}

rule CopyPackageMerge {
 from
  s : UML!PackageMerge
  (
   s.oclIsTypeOf(MM!PackageMerge)
  )
 to
  t : UMLs!PackageMerge (
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   mergedPackage <- s.mergedPackage,
   receivingPackage <- s.receivingPackage,
   relatedElement <- s.relatedElement
  )
}

rule CopyParameter {
 from
  s : UML!Parameter
  (
   s.oclIsTypeOf(MM!Parameter)
  )
 to
  t : UMLs!Parameter (
   end <- s.end,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   lower <- s.lower,
   lowerValue <- s.lowerValue,
   upper <- s.upper,
   upperValue <- s.upperValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   default <- s.default,
   defaultValue <- s.defaultValue,
   direction <- s.direction,
   effect <- s.effect,
   isException <- s.isException,
   isStream <- s.isStream,
   operation <- s.operation,
   parameterSet <- s.parameterSet,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyParameterSet {
 from
  s : UML!ParameterSet
  (
   s.oclIsTypeOf(MM!ParameterSet)
  )
 to
  t : UMLs!ParameterSet (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   condition <- s.condition,
   parameter <- s.parameter
  )
}

rule CopyPartDecomposition {
 from
  s : UML!PartDecomposition
  (
   s.oclIsTypeOf(MM!PartDecomposition)
  )
 to
  t : UMLs!PartDecomposition (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   actualGate <- s.actualGate,
   argument <- s.argument,
   refersTo <- s.refersTo,
   returnValue <- s.returnValue,
   returnValueRecipient <- s.returnValueRecipient,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility
  )
}

rule CopyPort {
 from
  s : UML!Port
  (
   s.oclIsTypeOf(MM!Port)
  )
 to
  t : UMLs!Port (
   end <- s.end,
   deployedElement <- s.deployedElement,
   deployment <- s.deployment,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   featuringClassifier <- s.featuringClassifier,
   isStatic <- s.isStatic,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   lower <- s.lower,
   lowerValue <- s.lowerValue,
   upper <- s.upper,
   upperValue <- s.upperValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isBehavior <- s.isBehavior,
   isConjugated <- s.isConjugated,
   isService <- s.isService,
   protocol <- s.protocol,
   provided <- s.provided,
   redefinedPort <- s.redefinedPort,
   required <- s.required,
   aggregation <- s.aggregation,
   class <- s.class,
   defaultValue <- s.defaultValue,
   isComposite <- s.isComposite,
   isDerived <- s.isDerived,
   isDerivedUnion <- s.isDerivedUnion,
   isID <- s.isID,
   opposite <- s.opposite,
   qualifier <- s.qualifier,
   redefinedProperty <- s.redefinedProperty,
   subsettedProperty <- s.subsettedProperty,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   isReadOnly <- s.isReadOnly,
   type <- s.type
  )
}

rule CopyPrimitiveType {
 from
  s : UML!PrimitiveType
  (
   s.oclIsTypeOf(MM!PrimitiveType)
  )
 to
  t : UMLs!PrimitiveType (
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedAttribute <- s.ownedAttribute,
   ownedOperation <- s.ownedOperation,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyProfile {
 from
  s : UML!Profile
  (
   s.oclIsTypeOf(MM!Profile)
  )
 to
  t : UMLs!Profile (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   URI <- s.URI,
   nestedPackage <- s.nestedPackage,
   nestingPackage <- s.nestingPackage,
   ownedStereotype <- s.ownedStereotype,
   ownedType <- s.ownedType,
   packageMerge <- s.packageMerge,
   packagedElement <- s.packagedElement,
   profileApplication <- s.profileApplication,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   metaclassReference <- s.metaclassReference,
   metamodelReference <- s.metamodelReference,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding
  )
}

rule CopyProfileApplication {
 from
  s : UML!ProfileApplication
  (
   s.oclIsTypeOf(MM!ProfileApplication)
  )
 to
  t : UMLs!ProfileApplication (
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   appliedProfile <- s.appliedProfile,
   applyingPackage <- s.applyingPackage,
   isStrict <- s.isStrict,
   relatedElement <- s.relatedElement
  )
}

rule CopyProperty {
 from
  s : UML!Property
  (
   s.oclIsTypeOf(MM!Property)
  )
 to
  t : UMLs!Property (
   end <- s.end,
   deployedElement <- s.deployedElement,
   deployment <- s.deployment,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   featuringClassifier <- s.featuringClassifier,
   isStatic <- s.isStatic,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   lower <- s.lower,
   lowerValue <- s.lowerValue,
   upper <- s.upper,
   upperValue <- s.upperValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   aggregation <- s.aggregation,
   class <- s.class,
   defaultValue <- s.defaultValue,
   isComposite <- s.isComposite,
   isDerived <- s.isDerived,
   isDerivedUnion <- s.isDerivedUnion,
   isID <- s.isID,
   opposite <- s.opposite,
   qualifier <- s.qualifier,
   redefinedProperty <- s.redefinedProperty,
   subsettedProperty <- s.subsettedProperty,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   isReadOnly <- s.isReadOnly,
   type <- s.type
  )
}

rule CopyProtocolConformance {
 from
  s : UML!ProtocolConformance
  (
   s.oclIsTypeOf(MM!ProtocolConformance)
  )
 to
  t : UMLs!ProtocolConformance (
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   generalMachine <- s.generalMachine,
   specificMachine <- s.specificMachine,
   relatedElement <- s.relatedElement
  )
}

rule CopyProtocolStateMachine {
 from
  s : UML!ProtocolStateMachine
  (
   s.oclIsTypeOf(MM!ProtocolStateMachine)
  )
 to
  t : UMLs!ProtocolStateMachine (
   context <- s.context,
   isReentrant <- s.isReentrant,
   ownedParameter <- s.ownedParameter,
   ownedParameterSet <- s.ownedParameterSet,
   postcondition <- s.postcondition,
   precondition <- s.precondition,
   redefinedBehavior <- s.redefinedBehavior,
   specification <- s.specification,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   conformance <- s.conformance,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   connectionPoint <- s.connectionPoint,
   extendedStateMachine <- s.extendedStateMachine,
   region <- s.region,
   submachineState <- s.submachineState,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyProtocolTransition {
 from
  s : UML!ProtocolTransition
  (
   s.oclIsTypeOf(MM!ProtocolTransition)
  )
 to
  t : UMLs!ProtocolTransition (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   postCondition <- s.postCondition,
   preCondition <- s.preCondition,
   referred <- s.referred,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   container <- s.container,
   effect <- s.effect,
   guard <- s.guard,
   kind <- s.kind,
   redefinedTransition <- s.redefinedTransition,
   source <- s.source,
   target <- s.target,
   trigger <- s.trigger
  )
}

rule CopyPseudostate {
 from
  s : UML!Pseudostate
  (
   s.oclIsTypeOf(MM!Pseudostate)
  )
 to
  t : UMLs!Pseudostate (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   kind <- s.kind,
   state <- s.state,
   stateMachine <- s.stateMachine,
   container <- s.container,
   incoming <- s.incoming,
   outgoing <- s.outgoing
  )
}

rule CopyQualifierValue {
 from
  s : UML!QualifierValue
  (
   s.oclIsTypeOf(MM!QualifierValue)
  )
 to
  t : UMLs!QualifierValue (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   qualifier <- s.qualifier,
   value <- s.value
  )
}

rule CopyRaiseExceptionAction {
 from
  s : UML!RaiseExceptionAction
  (
   s.oclIsTypeOf(MM!RaiseExceptionAction)
  )
 to
  t : UMLs!RaiseExceptionAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   exception <- s.exception,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyReadExtentAction {
 from
  s : UML!ReadExtentAction
  (
   s.oclIsTypeOf(MM!ReadExtentAction)
  )
 to
  t : UMLs!ReadExtentAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   classifier <- s.classifier,
   result <- s.result,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyReadIsClassifiedObjectAction {
 from
  s : UML!ReadIsClassifiedObjectAction
  (
   s.oclIsTypeOf(MM!ReadIsClassifiedObjectAction)
  )
 to
  t : UMLs!ReadIsClassifiedObjectAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   classifier <- s.classifier,
   isDirect <- s.isDirect,
   object <- s.object,
   result <- s.result,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyReadLinkAction {
 from
  s : UML!ReadLinkAction
  (
   s.oclIsTypeOf(MM!ReadLinkAction)
  )
 to
  t : UMLs!ReadLinkAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   endData <- s.endData,
   inputValue <- s.inputValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   result <- s.result,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyReadLinkObjectEndAction {
 from
  s : UML!ReadLinkObjectEndAction
  (
   s.oclIsTypeOf(MM!ReadLinkObjectEndAction)
  )
 to
  t : UMLs!ReadLinkObjectEndAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   end <- s.end,
   object <- s.object,
   result <- s.result,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyReadLinkObjectEndQualifierAction {
 from
  s : UML!ReadLinkObjectEndQualifierAction
  (
   s.oclIsTypeOf(MM!ReadLinkObjectEndQualifierAction)
  )
 to
  t : UMLs!ReadLinkObjectEndQualifierAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   object <- s.object,
   qualifier <- s.qualifier,
   result <- s.result,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyReadSelfAction {
 from
  s : UML!ReadSelfAction
  (
   s.oclIsTypeOf(MM!ReadSelfAction)
  )
 to
  t : UMLs!ReadSelfAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   result <- s.result,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyReadStructuralFeatureAction {
 from
  s : UML!ReadStructuralFeatureAction
  (
   s.oclIsTypeOf(MM!ReadStructuralFeatureAction)
  )
 to
  t : UMLs!ReadStructuralFeatureAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   result <- s.result,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   object <- s.object,
   structuralFeature <- s.structuralFeature
  )
}

rule CopyReadVariableAction {
 from
  s : UML!ReadVariableAction
  (
   s.oclIsTypeOf(MM!ReadVariableAction)
  )
 to
  t : UMLs!ReadVariableAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   result <- s.result,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   variable <- s.variable
  )
}

rule CopyRealization {
 from
  s : UML!Realization
  (
   s.oclIsTypeOf(MM!Realization)
  )
 to
  t : UMLs!Realization (
   mapping <- s.mapping,
   client <- s.client,
   supplier <- s.supplier,
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   relatedElement <- s.relatedElement
  )
}

rule CopyReception {
 from
  s : UML!Reception
  (
   s.oclIsTypeOf(MM!Reception)
  )
 to
  t : UMLs!Reception (
   concurrency <- s.concurrency,
   isAbstract <- s.isAbstract,
   method <- s.method,
   ownedParameter <- s.ownedParameter,
   ownedParameterSet <- s.ownedParameterSet,
   raisedException <- s.raisedException,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   featuringClassifier <- s.featuringClassifier,
   isStatic <- s.isStatic,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   signal <- s.signal,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyReclassifyObjectAction {
 from
  s : UML!ReclassifyObjectAction
  (
   s.oclIsTypeOf(MM!ReclassifyObjectAction)
  )
 to
  t : UMLs!ReclassifyObjectAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isReplaceAll <- s.isReplaceAll,
   newClassifier <- s.newClassifier,
   object <- s.object,
   oldClassifier <- s.oldClassifier,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext
  )
}

rule CopyRedefinableTemplateSignature {
 from
  s : UML!RedefinableTemplateSignature
  (
   s.oclIsTypeOf(MM!RedefinableTemplateSignature)
  )
 to
  t : UMLs!RedefinableTemplateSignature (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   classifier <- s.classifier,
   extendedSignature <- s.extendedSignature,
   inheritedParameter <- s.inheritedParameter,
   ownedParameter <- s.ownedParameter,
   parameter <- s.parameter,
   template <- s.template
  )
}

rule CopyReduceAction {
 from
  s : UML!ReduceAction
  (
   s.oclIsTypeOf(MM!ReduceAction)
  )
 to
  t : UMLs!ReduceAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   collection <- s.collection,
   isOrdered <- s.isOrdered,
   reducer <- s.reducer,
   result <- s.result
  )
}

rule CopyRegion {
 from
  s : UML!Region
  (
   s.oclIsTypeOf(MM!Region)
  )
 to
  t : UMLs!Region (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   extendedRegion <- s.extendedRegion,
   state <- s.state,
   stateMachine <- s.stateMachine,
   subvertex <- s.subvertex,
   transition <- s.transition
  )
}

rule CopyRemoveStructuralFeatureValueAction {
 from
  s : UML!RemoveStructuralFeatureValueAction
  (
   s.oclIsTypeOf(MM!RemoveStructuralFeatureValueAction)
  )
 to
  t : UMLs!RemoveStructuralFeatureValueAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   isRemoveDuplicates <- s.isRemoveDuplicates,
   removeAt <- s.removeAt,
   object <- s.object,
   structuralFeature <- s.structuralFeature,
   result <- s.result,
   value <- s.value
  )
}

rule CopyRemoveVariableValueAction {
 from
  s : UML!RemoveVariableValueAction
  (
   s.oclIsTypeOf(MM!RemoveVariableValueAction)
  )
 to
  t : UMLs!RemoveVariableValueAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   isRemoveDuplicates <- s.isRemoveDuplicates,
   removeAt <- s.removeAt,
   variable <- s.variable,
   value <- s.value
  )
}

rule CopyReplyAction {
 from
  s : UML!ReplyAction
  (
   s.oclIsTypeOf(MM!ReplyAction)
  )
 to
  t : UMLs!ReplyAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   replyToCall <- s.replyToCall,
   replyValue <- s.replyValue,
   returnInformation <- s.returnInformation
  )
}

rule CopySendObjectAction {
 from
  s : UML!SendObjectAction
  (
   s.oclIsTypeOf(MM!SendObjectAction)
  )
 to
  t : UMLs!SendObjectAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   argument <- s.argument,
   onPort <- s.onPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   request <- s.request,
   target <- s.target
  )
}

rule CopySendSignalAction {
 from
  s : UML!SendSignalAction
  (
   s.oclIsTypeOf(MM!SendSignalAction)
  )
 to
  t : UMLs!SendSignalAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   argument <- s.argument,
   onPort <- s.onPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   signal <- s.signal,
   target <- s.target
  )
}

rule CopySequenceNode {
 from
  s : UML!SequenceNode
  (
   s.oclIsTypeOf(MM!SequenceNode)
  )
 to
  t : UMLs!SequenceNode (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   inActivity <- s.inActivity,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   executableNode <- s.executableNode,
   edge <- s.edge,
   mustIsolate <- s.mustIsolate,
   node <- s.node,
   structuredNodeInput <- s.structuredNodeInput,
   structuredNodeOutput <- s.structuredNodeOutput,
   variable <- s.variable
  )
}

rule CopySignal {
 from
  s : UML!Signal
  (
   s.oclIsTypeOf(MM!Signal)
  )
 to
  t : UMLs!Signal (
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedAttribute <- s.ownedAttribute,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopySignalEvent {
 from
  s : UML!SignalEvent
  (
   s.oclIsTypeOf(MM!SignalEvent)
  )
 to
  t : UMLs!SignalEvent (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   signal <- s.signal
  )
}

rule CopySlot {
 from
  s : UML!Slot
  (
   s.oclIsTypeOf(MM!Slot)
  )
 to
  t : UMLs!Slot (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   definingFeature <- s.definingFeature,
   owningInstance <- s.owningInstance,
   value <- s.value
  )
}

rule CopyStartClassifierBehaviorAction {
 from
  s : UML!StartClassifierBehaviorAction
  (
   s.oclIsTypeOf(MM!StartClassifierBehaviorAction)
  )
 to
  t : UMLs!StartClassifierBehaviorAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   object <- s.object
  )
}

rule CopyStartObjectBehaviorAction {
 from
  s : UML!StartObjectBehaviorAction
  (
   s.oclIsTypeOf(MM!StartObjectBehaviorAction)
  )
 to
  t : UMLs!StartObjectBehaviorAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   isSynchronous <- s.isSynchronous,
   result <- s.result,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   argument <- s.argument,
   onPort <- s.onPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   object <- s.object
  )
}

rule CopyState {
 from
  s : UML!State
  (
   s.oclIsTypeOf(MM!State)
  )
 to
  t : UMLs!State (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   connection <- s.connection,
   connectionPoint <- s.connectionPoint,
   deferrableTrigger <- s.deferrableTrigger,
   doActivity <- s.doActivity,
   entry <- s.entry,
   exit <- s.exit,
   isComposite <- s.isComposite,
   isOrthogonal <- s.isOrthogonal,
   isSimple <- s.isSimple,
   isSubmachineState <- s.isSubmachineState,
   redefinedState <- s.redefinedState,
   region <- s.region,
   stateInvariant <- s.stateInvariant,
   submachine <- s.submachine,
   container <- s.container,
   incoming <- s.incoming,
   outgoing <- s.outgoing
  )
}

rule CopyStateInvariant {
 from
  s : UML!StateInvariant
  (
   s.oclIsTypeOf(MM!StateInvariant)
  )
 to
  t : UMLs!StateInvariant (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   covered <- s.covered,
   generalOrdering <- s.generalOrdering,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   invariant <- s.invariant
  )
}

rule CopyStateMachine {
 from
  s : UML!StateMachine
  (
   s.oclIsTypeOf(MM!StateMachine)
  )
 to
  t : UMLs!StateMachine (
   context <- s.context,
   isReentrant <- s.isReentrant,
   ownedParameter <- s.ownedParameter,
   ownedParameterSet <- s.ownedParameterSet,
   postcondition <- s.postcondition,
   precondition <- s.precondition,
   redefinedBehavior <- s.redefinedBehavior,
   specification <- s.specification,
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   connectionPoint <- s.connectionPoint,
   extendedStateMachine <- s.extendedStateMachine,
   region <- s.region,
   submachineState <- s.submachineState,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyStereotype {
 from
  s : UML!Stereotype
  (
   s.oclIsTypeOf(MM!Stereotype)
  )
 to
  t : UMLs!Stereotype (
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   extension <- s.extension,
   isActive <- s.isActive,
   nestedClassifier <- s.nestedClassifier,
   ownedOperation <- s.ownedOperation,
   ownedReception <- s.ownedReception,
   superClass <- s.superClass,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedPort <- s.ownedPort,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   icon <- s.icon,
   profile <- s.profile,
   ownedAttribute <- s.ownedAttribute,
   ownedConnector <- s.ownedConnector,
   part <- s.part,
   role <- s.role,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package
  )
}

rule CopyStringExpression {
 from
  s : UML!StringExpression
  (
   s.oclIsTypeOf(MM!StringExpression)
  )
 to
  t : UMLs!StringExpression (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   operand <- s.operand,
   symbol <- s.symbol,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   subExpression <- s.subExpression,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   type <- s.type
  )
}

rule CopyStructuredActivityNode {
 from
  s : UML!StructuredActivityNode
  (
   s.oclIsTypeOf(MM!StructuredActivityNode)
  )
 to
  t : UMLs!StructuredActivityNode (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   containedEdge <- s.containedEdge,
   containedNode <- s.containedNode,
   inActivity <- s.inActivity,
   subgroup <- s.subgroup,
   superGroup <- s.superGroup,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   edge <- s.edge,
   mustIsolate <- s.mustIsolate,
   node <- s.node,
   structuredNodeInput <- s.structuredNodeInput,
   structuredNodeOutput <- s.structuredNodeOutput,
   variable <- s.variable
  )
}

rule CopySubstitution {
 from
  s : UML!Substitution
  (
   s.oclIsTypeOf(MM!Substitution)
  )
 to
  t : UMLs!Substitution (
   mapping <- s.mapping,
   client <- s.client,
   supplier <- s.supplier,
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   relatedElement <- s.relatedElement,
   contract <- s.contract,
   substitutingClassifier <- s.substitutingClassifier
  )
}

rule CopyTemplateBinding {
 from
  s : UML!TemplateBinding
  (
   s.oclIsTypeOf(MM!TemplateBinding)
  )
 to
  t : UMLs!TemplateBinding (
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   relatedElement <- s.relatedElement,
   boundElement <- s.boundElement,
   parameterSubstitution <- s.parameterSubstitution,
   signature <- s.signature
  )
}

rule CopyTemplateParameter {
 from
  s : UML!TemplateParameter
  (
   s.oclIsTypeOf(MM!TemplateParameter)
  )
 to
  t : UMLs!TemplateParameter (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   default <- s.default,
   ownedDefault <- s.ownedDefault,
   ownedParameteredElement <- s.ownedParameteredElement,
   parameteredElement <- s.parameteredElement
  )
}

rule CopyTemplateParameterSubstitution {
 from
  s : UML!TemplateParameterSubstitution
  (
   s.oclIsTypeOf(MM!TemplateParameterSubstitution)
  )
 to
  t : UMLs!TemplateParameterSubstitution (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   actual <- s.actual,
   formal <- s.formal,
   ownedActual <- s.ownedActual,
   templateBinding <- s.templateBinding
  )
}

rule CopyTemplateSignature {
 from
  s : UML!TemplateSignature
  (
   s.oclIsTypeOf(MM!TemplateSignature)
  )
 to
  t : UMLs!TemplateSignature (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   ownedParameter <- s.ownedParameter,
   parameter <- s.parameter,
   template <- s.template
  )
}

rule CopyTestIdentityAction {
 from
  s : UML!TestIdentityAction
  (
   s.oclIsTypeOf(MM!TestIdentityAction)
  )
 to
  t : UMLs!TestIdentityAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   first <- s.first,
   result <- s.result,
   second <- s.second
  )
}

rule CopyTimeConstraint {
 from
  s : UML!TimeConstraint
  (
   s.oclIsTypeOf(MM!TimeConstraint)
  )
 to
  t : UMLs!TimeConstraint (
   constrainedElement <- s.constrainedElement,
   context <- s.context,
   specification <- s.specification,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   firstEvent <- s.firstEvent
  )
}

rule CopyTimeEvent {
 from
  s : UML!TimeEvent
  (
   s.oclIsTypeOf(MM!TimeEvent)
  )
 to
  t : UMLs!TimeEvent (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isRelative <- s.isRelative,
   when <- s.when
  )
}

rule CopyTimeExpression {
 from
  s : UML!TimeExpression
  (
   s.oclIsTypeOf(MM!TimeExpression)
  )
 to
  t : UMLs!TimeExpression (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   expr <- s.expr,
   observation <- s.observation,
   type <- s.type
  )
}

rule CopyTimeInterval {
 from
  s : UML!TimeInterval
  (
   s.oclIsTypeOf(MM!TimeInterval)
  )
 to
  t : UMLs!TimeInterval (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   max <- s.max,
   min <- s.min,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type
  )
}

rule CopyTimeObservation {
 from
  s : UML!TimeObservation
  (
   s.oclIsTypeOf(MM!TimeObservation)
  )
 to
  t : UMLs!TimeObservation (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   event <- s.event,
   firstEvent <- s.firstEvent
  )
}

rule CopyTransition {
 from
  s : UML!Transition
  (
   s.oclIsTypeOf(MM!Transition)
  )
 to
  t : UMLs!Transition (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   container <- s.container,
   effect <- s.effect,
   guard <- s.guard,
   kind <- s.kind,
   redefinedTransition <- s.redefinedTransition,
   source <- s.source,
   target <- s.target,
   trigger <- s.trigger
  )
}

rule CopyTrigger {
 from
  s : UML!Trigger
  (
   s.oclIsTypeOf(MM!Trigger)
  )
 to
  t : UMLs!Trigger (
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   event <- s.event,
   port <- s.port
  )
}

rule CopyUnmarshallAction {
 from
  s : UML!UnmarshallAction
  (
   s.oclIsTypeOf(MM!UnmarshallAction)
  )
 to
  t : UMLs!UnmarshallAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   object <- s.object,
   result <- s.result,
   unmarshallType <- s.unmarshallType
  )
}

rule CopyUsage {
 from
  s : UML!Usage
  (
   s.oclIsTypeOf(MM!Usage)
  )
 to
  t : UMLs!Usage (
   client <- s.client,
   supplier <- s.supplier,
   source <- s.source,
   target <- s.target,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   relatedElement <- s.relatedElement
  )
}

rule CopyUseCase {
 from
  s : UML!UseCase
  (
   s.oclIsTypeOf(MM!UseCase)
  )
 to
  t : UMLs!UseCase (
   classifierBehavior <- s.classifierBehavior,
   interfaceRealization <- s.interfaceRealization,
   ownedBehavior <- s.ownedBehavior,
   attribute <- s.attribute,
   collaborationUse <- s.collaborationUse,
   feature <- s.feature,
   general <- s.general,
   generalization <- s.generalization,
   inheritedMember <- s.inheritedMember,
   isAbstract <- s.isAbstract,
   isFinalSpecialization <- s.isFinalSpecialization,
   ownedUseCase <- s.ownedUseCase,
   powertypeExtent <- s.powertypeExtent,
   redefinedClassifier <- s.redefinedClassifier,
   representation <- s.representation,
   substitution <- s.substitution,
   useCase <- s.useCase,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   elementImport <- s.elementImport,
   importedMember <- s.importedMember,
   member <- s.member,
   ownedMember <- s.ownedMember,
   ownedRule <- s.ownedRule,
   packageImport <- s.packageImport,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   ownedTemplateSignature <- s.ownedTemplateSignature,
   templateBinding <- s.templateBinding,
   package <- s.package,
   extend <- s.extend,
   extensionPoint <- s.extensionPoint,
   include <- s.include,
   subject <- s.subject
  )
}

rule CopyValuePin {
 from
  s : UML!ValuePin
  (
   s.oclIsTypeOf(MM!ValuePin)
  )
 to
  t : UMLs!ValuePin (
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   lower <- s.lower,
   lowerValue <- s.lowerValue,
   upper <- s.upper,
   upperValue <- s.upperValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   inState <- s.inState,
   isControlType <- s.isControlType,
   ordering <- s.ordering,
   selection <- s.selection,
   upperBound <- s.upperBound,
   isControl <- s.isControl,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   type <- s.type,
   value <- s.value
  )
}

rule CopyValueSpecificationAction {
 from
  s : UML!ValueSpecificationAction
  (
   s.oclIsTypeOf(MM!ValueSpecificationAction)
  )
 to
  t : UMLs!ValueSpecificationAction (
   context <- s.context,
   input <- s.input,
   isLocallyReentrant <- s.isLocallyReentrant,
   localPostcondition <- s.localPostcondition,
   localPrecondition <- s.localPrecondition,
   output <- s.output,
   activity <- s.activity,
   inGroup <- s.inGroup,
   inInterruptibleRegion <- s.inInterruptibleRegion,
   inPartition <- s.inPartition,
   inStructuredNode <- s.inStructuredNode,
   incoming <- s.incoming,
   outgoing <- s.outgoing,
   redefinedNode <- s.redefinedNode,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   handler <- s.handler,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   isLeaf <- s.isLeaf,
   redefinedElement <- s.redefinedElement,
   redefinitionContext <- s.redefinitionContext,
   result <- s.result,
   value <- s.value
  )
}

rule CopyVariable {
 from
  s : UML!Variable
  (
   s.oclIsTypeOf(MM!Variable)
  )
 to
  t : UMLs!Variable (
   end <- s.end,
   ownedComment <- s.ownedComment,
   ownedElement <- s.ownedElement,
   owner <- s.owner,
   isOrdered <- s.isOrdered,
   isUnique <- s.isUnique,
   lower <- s.lower,
   lowerValue <- s.lowerValue,
   upper <- s.upper,
   upperValue <- s.upperValue,
   clientDependency <- s.clientDependency,
   name <- s.name,
   nameExpression <- s.nameExpression,
   namespace <- s.namespace,
   qualifiedName <- s.qualifiedName,
   visibility <- s.visibility,
   owningTemplateParameter <- s.owningTemplateParameter,
   templateParameter <- s.templateParameter,
   type <- s.type,
   activityScope <- s.activityScope,
   scope <- s.scope
  )
}
