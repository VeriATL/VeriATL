// print classifier const

const unique UMLs$Comment: ClassName extends UMLs$Element complete;
const unique UMLs$Comment.body: Field String;
const unique UMLs$Comment.annotatedElement: Field ref;
const unique UMLs$Element: ClassName extends UMLs$null complete;
const unique UMLs$Element.ownedElement: Field ref;
const unique UMLs$Element.owner: Field ref;
const unique UMLs$Element.ownedComment: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$Element);
const unique UMLs$Package: ClassName extends UMLs$Namespace,UMLs$PackageableElement,UMLs$TemplateableElement complete;
const unique UMLs$Package.ownedType: Field ref;
const unique UMLs$Package.packageMerge: Field ref;
const unique UMLs$Package.packagedElement: Field ref;
const unique UMLs$Package.nestedPackage: Field ref;
const unique UMLs$Package.nestingPackage: Field ref;
const unique UMLs$Package.profileApplication: Field ref;
const unique UMLs$PackageableElement: ClassName extends UMLs$NamedElement,UMLs$ParameterableElement complete;
   axiom (forall r: ref :: dtype(r)!= UMLs$PackageableElement);
const unique UMLs$NamedElement: ClassName extends UMLs$Element complete;
const unique UMLs$NamedElement.name: Field String;
const unique UMLs$NamedElement.visibility: Field VisibilityKind;
const unique UMLs$NamedElement.qualifiedName: Field String;
const unique UMLs$NamedElement.clientDependency: Field ref;
const unique UMLs$NamedElement.namespace: Field ref;
const unique UMLs$NamedElement.nameExpression: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$NamedElement);
const unique UMLs$Dependency: ClassName extends UMLs$PackageableElement,UMLs$DirectedRelationship complete;
const unique UMLs$Dependency.supplier: Field ref;
const unique UMLs$Dependency.client: Field ref;
const unique UMLs$DirectedRelationship: ClassName extends UMLs$Relationship complete;
const unique UMLs$DirectedRelationship.source: Field ref;
const unique UMLs$DirectedRelationship.target: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$DirectedRelationship);
const unique UMLs$Relationship: ClassName extends UMLs$Element complete;
const unique UMLs$Relationship.relatedElement: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$Relationship);
const unique UMLs$Namespace: ClassName extends UMLs$NamedElement complete;
const unique UMLs$Namespace.elementImport: Field ref;
const unique UMLs$Namespace.packageImport: Field ref;
const unique UMLs$Namespace.ownedRule: Field ref;
const unique UMLs$Namespace.member: Field ref;
const unique UMLs$Namespace.importedMember: Field ref;
const unique UMLs$Namespace.ownedMember: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$Namespace);
const unique UMLs$ElementImport: ClassName extends UMLs$DirectedRelationship complete;
const unique UMLs$ElementImport.visibility: Field VisibilityKind;
const unique UMLs$ElementImport.alias: Field String;
const unique UMLs$ElementImport.importedElement: Field ref;
const unique UMLs$ElementImport.importingNamespace: Field ref;
const unique UMLs$PackageImport: ClassName extends UMLs$DirectedRelationship complete;
const unique UMLs$PackageImport.visibility: Field VisibilityKind;
const unique UMLs$PackageImport.importedPackage: Field ref;
const unique UMLs$PackageImport.importingNamespace: Field ref;
const unique UMLs$Constraint: ClassName extends UMLs$PackageableElement complete;
const unique UMLs$Constraint.constrainedElement: Field ref;
const unique UMLs$Constraint.specification: Field ref;
const unique UMLs$Constraint.context: Field ref;
const unique UMLs$ValueSpecification: ClassName extends UMLs$PackageableElement,UMLs$TypedElement complete;
   axiom (forall r: ref :: dtype(r)!= UMLs$ValueSpecification);
const unique UMLs$TypedElement: ClassName extends UMLs$NamedElement complete;
const unique UMLs$TypedElement.type: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$TypedElement);
const unique UMLs$Type: ClassName extends UMLs$PackageableElement complete;
const unique UMLs$Type.package: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$Type);
const unique UMLs$Association: ClassName extends UMLs$Classifier,UMLs$Relationship complete;
const unique UMLs$Association.ownedEnd: Field ref;
const unique UMLs$Association.memberEnd: Field ref;
const unique UMLs$Association.isDerived: Field Boolean;
const unique UMLs$Association.endType: Field ref;
const unique UMLs$Association.navigableOwnedEnd: Field ref;
const unique UMLs$Classifier: ClassName extends UMLs$Namespace,UMLs$RedefinableElement,UMLs$Type,UMLs$TemplateableElement complete;
const unique UMLs$Classifier.isAbstract: Field Boolean;
const unique UMLs$Classifier.generalization: Field ref;
const unique UMLs$Classifier.powertypeExtent: Field ref;
const unique UMLs$Classifier.feature: Field ref;
const unique UMLs$Classifier.inheritedMember: Field ref;
const unique UMLs$Classifier.redefinedClassifier: Field ref;
const unique UMLs$Classifier.general: Field ref;
const unique UMLs$Classifier.substitution: Field ref;
const unique UMLs$Classifier.attribute: Field ref;
const unique UMLs$Classifier.representation: Field ref;
const unique UMLs$Classifier.collaborationUse: Field ref;
const unique UMLs$Classifier.ownedUseCase: Field ref;
const unique UMLs$Classifier.useCase: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$Classifier);
const unique UMLs$RedefinableElement: ClassName extends UMLs$NamedElement complete;
const unique UMLs$RedefinableElement.isLeaf: Field Boolean;
const unique UMLs$RedefinableElement.redefinedElement: Field ref;
const unique UMLs$RedefinableElement.redefinitionContext: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$RedefinableElement);
const unique UMLs$TemplateableElement: ClassName extends UMLs$Element complete;
const unique UMLs$TemplateableElement.templateBinding: Field ref;
const unique UMLs$TemplateableElement.ownedTemplateSignature: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$TemplateableElement);
const unique UMLs$TemplateBinding: ClassName extends UMLs$DirectedRelationship complete;
const unique UMLs$TemplateBinding.signature: Field ref;
const unique UMLs$TemplateBinding.parameterSubstitution: Field ref;
const unique UMLs$TemplateBinding.boundElement: Field ref;
const unique UMLs$TemplateSignature: ClassName extends UMLs$Element complete;
const unique UMLs$TemplateSignature.parameter: Field ref;
const unique UMLs$TemplateSignature.ownedParameter: Field ref;
const unique UMLs$TemplateSignature.template: Field ref;
const unique UMLs$TemplateParameter: ClassName extends UMLs$Element complete;
const unique UMLs$TemplateParameter.signature: Field ref;
const unique UMLs$TemplateParameter.parameteredElement: Field ref;
const unique UMLs$TemplateParameter.ownedParameteredElement: Field ref;
const unique UMLs$TemplateParameter.default: Field ref;
const unique UMLs$TemplateParameter.ownedDefault: Field ref;
const unique UMLs$ParameterableElement: ClassName extends UMLs$Element complete;
const unique UMLs$ParameterableElement.owningTemplateParameter: Field ref;
const unique UMLs$ParameterableElement.templateParameter: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$ParameterableElement);
const unique UMLs$TemplateParameterSubstitution: ClassName extends UMLs$Element complete;
const unique UMLs$TemplateParameterSubstitution.formal: Field ref;
const unique UMLs$TemplateParameterSubstitution.actual: Field ref;
const unique UMLs$TemplateParameterSubstitution.ownedActual: Field ref;
const unique UMLs$TemplateParameterSubstitution.templateBinding: Field ref;
const unique UMLs$Generalization: ClassName extends UMLs$DirectedRelationship complete;
const unique UMLs$Generalization.isSubstitutable: Field Boolean;
const unique UMLs$Generalization.general: Field ref;
const unique UMLs$Generalization.generalizationSet: Field ref;
const unique UMLs$Generalization.specific: Field ref;
const unique UMLs$GeneralizationSet: ClassName extends UMLs$PackageableElement complete;
const unique UMLs$GeneralizationSet.isCovering: Field Boolean;
const unique UMLs$GeneralizationSet.isDisjoint: Field Boolean;
const unique UMLs$GeneralizationSet.powertype: Field ref;
const unique UMLs$GeneralizationSet.generalization: Field ref;
const unique UMLs$Feature: ClassName extends UMLs$RedefinableElement complete;
const unique UMLs$Feature.isStatic: Field Boolean;
const unique UMLs$Feature.featuringClassifier: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$Feature);
const unique UMLs$Substitution: ClassName extends UMLs$Realization complete;
const unique UMLs$Substitution.contract: Field ref;
const unique UMLs$Substitution.substitutingClassifier: Field ref;
const unique UMLs$Realization: ClassName extends UMLs$Abstraction complete;
const unique UMLs$Abstraction: ClassName extends UMLs$Dependency complete;
const unique UMLs$Abstraction.mapping: Field ref;
const unique UMLs$OpaqueExpression: ClassName extends UMLs$ValueSpecification complete;
const unique UMLs$OpaqueExpression.body: Field String;
const unique UMLs$OpaqueExpression.language: Field String;
const unique UMLs$OpaqueExpression.result: Field ref;
const unique UMLs$OpaqueExpression.behavior: Field ref;
const unique UMLs$Parameter: ClassName extends UMLs$ConnectableElement,UMLs$MultiplicityElement complete;
const unique UMLs$Parameter.parameterSet: Field ref;
const unique UMLs$Parameter.operation: Field ref;
const unique UMLs$Parameter.direction: Field ParameterDirectionKind;
const unique UMLs$Parameter.default: Field String;
const unique UMLs$Parameter.defaultValue: Field ref;
const unique UMLs$Parameter.isException: Field Boolean;
const unique UMLs$Parameter.isStream: Field Boolean;
const unique UMLs$Parameter.effect: Field ParameterEffectKind;
const unique UMLs$MultiplicityElement: ClassName extends UMLs$Element complete;
const unique UMLs$MultiplicityElement.isOrdered: Field Boolean;
const unique UMLs$MultiplicityElement.isUnique: Field Boolean;
const unique UMLs$MultiplicityElement.upper: Field UnlimitedNatural;
const unique UMLs$MultiplicityElement.lower: Field Integer;
const unique UMLs$MultiplicityElement.upperValue: Field ref;
const unique UMLs$MultiplicityElement.lowerValue: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$MultiplicityElement);
const unique UMLs$ConnectableElement: ClassName extends UMLs$TypedElement,UMLs$ParameterableElement complete;
const unique UMLs$ConnectableElement.end: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$ConnectableElement);
const unique UMLs$ConnectorEnd: ClassName extends UMLs$MultiplicityElement complete;
const unique UMLs$ConnectorEnd.definingEnd: Field ref;
const unique UMLs$ConnectorEnd.role: Field ref;
const unique UMLs$ConnectorEnd.partWithPort: Field ref;
const unique UMLs$Property: ClassName extends UMLs$StructuralFeature,UMLs$ConnectableElement,UMLs$DeploymentTarget complete;
const unique UMLs$Property.class: Field ref;
const unique UMLs$Property.datatype: Field ref;
const unique UMLs$Property.isDerived: Field Boolean;
const unique UMLs$Property.isDerivedUnion: Field Boolean;
const unique UMLs$Property.default: Field String;
const unique UMLs$Property.aggregation: Field AggregationKind;
const unique UMLs$Property.isComposite: Field Boolean;
const unique UMLs$Property.redefinedProperty: Field ref;
const unique UMLs$Property.owningAssociation: Field ref;
const unique UMLs$Property.defaultValue: Field ref;
const unique UMLs$Property.opposite: Field ref;
const unique UMLs$Property.subsettedProperty: Field ref;
const unique UMLs$Property.association: Field ref;
const unique UMLs$Property.qualifier: Field ref;
const unique UMLs$Property.associationEnd: Field ref;
const unique UMLs$DeploymentTarget: ClassName extends UMLs$NamedElement complete;
const unique UMLs$DeploymentTarget.deployment: Field ref;
const unique UMLs$DeploymentTarget.deployedElement: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$DeploymentTarget);
const unique UMLs$Deployment: ClassName extends UMLs$Dependency complete;
const unique UMLs$Deployment.deployedArtifact: Field ref;
const unique UMLs$Deployment.configuration: Field ref;
const unique UMLs$Deployment.location: Field ref;
const unique UMLs$DeployedArtifact: ClassName extends UMLs$NamedElement complete;
   axiom (forall r: ref :: dtype(r)!= UMLs$DeployedArtifact);
const unique UMLs$DeploymentSpecification: ClassName extends UMLs$Artifact complete;
const unique UMLs$DeploymentSpecification.deploymentLocation: Field String;
const unique UMLs$DeploymentSpecification.executionLocation: Field String;
const unique UMLs$DeploymentSpecification.deployment: Field ref;
const unique UMLs$Artifact: ClassName extends UMLs$Classifier,UMLs$DeployedArtifact complete;
const unique UMLs$Artifact.fileName: Field String;
const unique UMLs$Artifact.nestedArtifact: Field ref;
const unique UMLs$Artifact.manifestation: Field ref;
const unique UMLs$Artifact.ownedOperation: Field ref;
const unique UMLs$Artifact.ownedAttribute: Field ref;
const unique UMLs$Manifestation: ClassName extends UMLs$Abstraction complete;
const unique UMLs$Manifestation.utilizedElement: Field ref;
const unique UMLs$Operation: ClassName extends UMLs$BehavioralFeature,UMLs$ParameterableElement,UMLs$TemplateableElement complete;
const unique UMLs$Operation.interface: Field ref;
const unique UMLs$Operation.class: Field ref;
const unique UMLs$Operation.isQuery: Field Boolean;
const unique UMLs$Operation.isOrdered: Field Boolean;
const unique UMLs$Operation.isUnique: Field Boolean;
const unique UMLs$Operation.lower: Field Integer;
const unique UMLs$Operation.upper: Field UnlimitedNatural;
const unique UMLs$Operation.precondition: Field ref;
const unique UMLs$Operation.postcondition: Field ref;
const unique UMLs$Operation.redefinedOperation: Field ref;
const unique UMLs$Operation.datatype: Field ref;
const unique UMLs$Operation.bodyCondition: Field ref;
const unique UMLs$Operation.type: Field ref;
const unique UMLs$BehavioralFeature: ClassName extends UMLs$Namespace,UMLs$Feature complete;
const unique UMLs$BehavioralFeature.ownedParameter: Field ref;
const unique UMLs$BehavioralFeature.isAbstract: Field Boolean;
const unique UMLs$BehavioralFeature.method: Field ref;
const unique UMLs$BehavioralFeature.concurrency: Field CallConcurrencyKind;
const unique UMLs$BehavioralFeature.raisedException: Field ref;
const unique UMLs$BehavioralFeature.ownedParameterSet: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$BehavioralFeature);
const unique UMLs$Behavior: ClassName extends UMLs$Class complete;
const unique UMLs$Behavior.isReentrant: Field Boolean;
const unique UMLs$Behavior.redefinedBehavior: Field ref;
const unique UMLs$Behavior.ownedParameter: Field ref;
const unique UMLs$Behavior.context: Field ref;
const unique UMLs$Behavior.precondition: Field ref;
const unique UMLs$Behavior.postcondition: Field ref;
const unique UMLs$Behavior.ownedParameterSet: Field ref;
const unique UMLs$Behavior.specification: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$Behavior);
const unique UMLs$Class: ClassName extends UMLs$EncapsulatedClassifier,UMLs$BehavioredClassifier complete;
const unique UMLs$Class.nestedClassifier: Field ref;
const unique UMLs$Class.ownedOperation: Field ref;
const unique UMLs$Class.superClass: Field ref;
const unique UMLs$Class.isActive: Field Boolean;
const unique UMLs$Class.ownedReception: Field ref;
const unique UMLs$Class.extension: Field ref;
const unique UMLs$BehavioredClassifier: ClassName extends UMLs$Classifier complete;
const unique UMLs$BehavioredClassifier.ownedBehavior: Field ref;
const unique UMLs$BehavioredClassifier.classifierBehavior: Field ref;
const unique UMLs$BehavioredClassifier.interfaceRealization: Field ref;
const unique UMLs$BehavioredClassifier.ownedTrigger: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$BehavioredClassifier);
const unique UMLs$InterfaceRealization: ClassName extends UMLs$Realization complete;
const unique UMLs$InterfaceRealization.contract: Field ref;
const unique UMLs$InterfaceRealization.implementingClassifier: Field ref;
const unique UMLs$Interface: ClassName extends UMLs$Classifier complete;
const unique UMLs$Interface.ownedAttribute: Field ref;
const unique UMLs$Interface.ownedOperation: Field ref;
const unique UMLs$Interface.nestedClassifier: Field ref;
const unique UMLs$Interface.redefinedInterface: Field ref;
const unique UMLs$Interface.ownedReception: Field ref;
const unique UMLs$Interface.protocol: Field ref;
const unique UMLs$Reception: ClassName extends UMLs$BehavioralFeature complete;
const unique UMLs$Reception.signal: Field ref;
const unique UMLs$Signal: ClassName extends UMLs$Classifier complete;
const unique UMLs$Signal.ownedAttribute: Field ref;
const unique UMLs$ProtocolStateMachine: ClassName extends UMLs$StateMachine complete;
const unique UMLs$ProtocolStateMachine.conformance: Field ref;
const unique UMLs$StateMachine: ClassName extends UMLs$Behavior complete;
const unique UMLs$StateMachine.region: Field ref;
const unique UMLs$StateMachine.submachineState: Field ref;
const unique UMLs$StateMachine.connectionPoint: Field ref;
const unique UMLs$StateMachine.extendedStateMachine: Field ref;
const unique UMLs$Region: ClassName extends UMLs$Namespace,UMLs$RedefinableElement complete;
const unique UMLs$Region.subvertex: Field ref;
const unique UMLs$Region.transition: Field ref;
const unique UMLs$Region.state: Field ref;
const unique UMLs$Region.extendedRegion: Field ref;
const unique UMLs$Region.stateMachine: Field ref;
const unique UMLs$Vertex: ClassName extends UMLs$NamedElement complete;
const unique UMLs$Vertex.outgoing: Field ref;
const unique UMLs$Vertex.incoming: Field ref;
const unique UMLs$Vertex.container: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$Vertex);
const unique UMLs$Transition: ClassName extends UMLs$Namespace,UMLs$RedefinableElement complete;
const unique UMLs$Transition.kind: Field TransitionKind;
const unique UMLs$Transition.container: Field ref;
const unique UMLs$Transition.source: Field ref;
const unique UMLs$Transition.target: Field ref;
const unique UMLs$Transition.redefinedTransition: Field ref;
const unique UMLs$Transition.guard: Field ref;
const unique UMLs$Transition.effect: Field ref;
const unique UMLs$Transition.trigger: Field ref;
const unique UMLs$Trigger: ClassName extends UMLs$NamedElement complete;
const unique UMLs$Trigger.event: Field ref;
const unique UMLs$Trigger.port: Field ref;
const unique UMLs$Event: ClassName extends UMLs$PackageableElement complete;
   axiom (forall r: ref :: dtype(r)!= UMLs$Event);
const unique UMLs$Port: ClassName extends UMLs$Property complete;
const unique UMLs$Port.isBehavior: Field Boolean;
const unique UMLs$Port.isService: Field Boolean;
const unique UMLs$Port.required: Field ref;
const unique UMLs$Port.redefinedPort: Field ref;
const unique UMLs$Port.provided: Field ref;
const unique UMLs$Port.protocol: Field ref;
const unique UMLs$State: ClassName extends UMLs$Namespace,UMLs$RedefinableElement,UMLs$Vertex complete;
const unique UMLs$State.isComposite: Field Boolean;
const unique UMLs$State.isOrthogonal: Field Boolean;
const unique UMLs$State.isSimple: Field Boolean;
const unique UMLs$State.isSubmachineState: Field Boolean;
const unique UMLs$State.submachine: Field ref;
const unique UMLs$State.connection: Field ref;
const unique UMLs$State.connectionPoint: Field ref;
const unique UMLs$State.redefinedState: Field ref;
const unique UMLs$State.stateInvariant: Field ref;
const unique UMLs$State.entry: Field ref;
const unique UMLs$State.exit: Field ref;
const unique UMLs$State.doActivity: Field ref;
const unique UMLs$State.deferrableTrigger: Field ref;
const unique UMLs$State.region: Field ref;
const unique UMLs$ConnectionPointReference: ClassName extends UMLs$Vertex complete;
const unique UMLs$ConnectionPointReference.entry: Field ref;
const unique UMLs$ConnectionPointReference.exit: Field ref;
const unique UMLs$ConnectionPointReference.state: Field ref;
const unique UMLs$Pseudostate: ClassName extends UMLs$Vertex complete;
const unique UMLs$Pseudostate.kind: Field PseudostateKind;
const unique UMLs$Pseudostate.stateMachine: Field ref;
const unique UMLs$Pseudostate.state: Field ref;
const unique UMLs$ProtocolConformance: ClassName extends UMLs$DirectedRelationship complete;
const unique UMLs$ProtocolConformance.generalMachine: Field ref;
const unique UMLs$ProtocolConformance.specificMachine: Field ref;
const unique UMLs$EncapsulatedClassifier: ClassName extends UMLs$StructuredClassifier complete;
const unique UMLs$EncapsulatedClassifier.ownedPort: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$EncapsulatedClassifier);
const unique UMLs$StructuredClassifier: ClassName extends UMLs$Classifier complete;
const unique UMLs$StructuredClassifier.ownedAttribute: Field ref;
const unique UMLs$StructuredClassifier.part: Field ref;
const unique UMLs$StructuredClassifier.role: Field ref;
const unique UMLs$StructuredClassifier.ownedConnector: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$StructuredClassifier);
const unique UMLs$Connector: ClassName extends UMLs$Feature complete;
const unique UMLs$Connector.type: Field ref;
const unique UMLs$Connector.redefinedConnector: Field ref;
const unique UMLs$Connector.end: Field ref;
const unique UMLs$Connector.kind: Field ConnectorKind;
const unique UMLs$Connector.contract: Field ref;
const unique UMLs$Extension: ClassName extends UMLs$Association complete;
const unique UMLs$Extension.isRequired: Field Boolean;
const unique UMLs$Extension.metaclass: Field ref;
const unique UMLs$ExtensionEnd: ClassName extends UMLs$Property complete;
const unique UMLs$Stereotype: ClassName extends UMLs$Class complete;
const unique UMLs$Stereotype.icon: Field ref;
const unique UMLs$Image: ClassName extends UMLs$Element complete;
const unique UMLs$Image.content: Field String;
const unique UMLs$Image.location: Field String;
const unique UMLs$Image.format: Field String;
const unique UMLs$Profile: ClassName extends UMLs$Package complete;
const unique UMLs$Profile.ownedStereotype: Field ref;
const unique UMLs$Profile.metaclassReference: Field ref;
const unique UMLs$Profile.metamodelReference: Field ref;
const unique UMLs$Model: ClassName extends UMLs$Package complete;
const unique UMLs$Model.viewpoint: Field String;
const unique UMLs$ParameterSet: ClassName extends UMLs$NamedElement complete;
const unique UMLs$ParameterSet.parameter: Field ref;
const unique UMLs$ParameterSet.condition: Field ref;
const unique UMLs$DataType: ClassName extends UMLs$Classifier complete;
const unique UMLs$DataType.ownedAttribute: Field ref;
const unique UMLs$DataType.ownedOperation: Field ref;
const unique UMLs$OperationTemplateParameter: ClassName extends UMLs$TemplateParameter complete;
const unique UMLs$StructuralFeature: ClassName extends UMLs$Feature,UMLs$TypedElement,UMLs$MultiplicityElement complete;
const unique UMLs$StructuralFeature.isReadOnly: Field Boolean;
   axiom (forall r: ref :: dtype(r)!= UMLs$StructuralFeature);
const unique UMLs$ConnectableElementTemplateParameter: ClassName extends UMLs$TemplateParameter complete;
const unique UMLs$CollaborationUse: ClassName extends UMLs$NamedElement complete;
const unique UMLs$CollaborationUse.type: Field ref;
const unique UMLs$CollaborationUse.roleBinding: Field ref;
const unique UMLs$Collaboration: ClassName extends UMLs$BehavioredClassifier,UMLs$StructuredClassifier complete;
const unique UMLs$Collaboration.collaborationRole: Field ref;
const unique UMLs$UseCase: ClassName extends UMLs$BehavioredClassifier complete;
const unique UMLs$UseCase.include: Field ref;
const unique UMLs$UseCase.extend: Field ref;
const unique UMLs$UseCase.extensionPoint: Field ref;
const unique UMLs$UseCase.subject: Field ref;
const unique UMLs$Include: ClassName extends UMLs$NamedElement,UMLs$DirectedRelationship complete;
const unique UMLs$Include.addition: Field ref;
const unique UMLs$Include.includingCase: Field ref;
const unique UMLs$Extend: ClassName extends UMLs$NamedElement,UMLs$DirectedRelationship complete;
const unique UMLs$Extend.extendedCase: Field ref;
const unique UMLs$Extend.condition: Field ref;
const unique UMLs$Extend.extensionLocation: Field ref;
const unique UMLs$Extend.extension: Field ref;
const unique UMLs$ExtensionPoint: ClassName extends UMLs$RedefinableElement complete;
const unique UMLs$ExtensionPoint.useCase: Field ref;
const unique UMLs$RedefinableTemplateSignature: ClassName extends UMLs$RedefinableElement,UMLs$TemplateSignature complete;
const unique UMLs$RedefinableTemplateSignature.extendedSignature: Field ref;
const unique UMLs$RedefinableTemplateSignature.inheritedParameter: Field ref;
const unique UMLs$RedefinableTemplateSignature.classifier: Field ref;
const unique UMLs$ClassifierTemplateParameter: ClassName extends UMLs$TemplateParameter complete;
const unique UMLs$ClassifierTemplateParameter.allowSubstitutable: Field Boolean;
const unique UMLs$ClassifierTemplateParameter.constrainingClassifier: Field ref;
const unique UMLs$StringExpression: ClassName extends UMLs$Expression,UMLs$TemplateableElement complete;
const unique UMLs$StringExpression.subExpression: Field ref;
const unique UMLs$StringExpression.owningExpression: Field ref;
const unique UMLs$Expression: ClassName extends UMLs$ValueSpecification complete;
const unique UMLs$Expression.symbol: Field String;
const unique UMLs$Expression.operand: Field ref;
const unique UMLs$Usage: ClassName extends UMLs$Dependency complete;
const unique UMLs$PackageMerge: ClassName extends UMLs$DirectedRelationship complete;
const unique UMLs$PackageMerge.mergedPackage: Field ref;
const unique UMLs$PackageMerge.receivingPackage: Field ref;
const unique UMLs$ProfileApplication: ClassName extends UMLs$DirectedRelationship complete;
const unique UMLs$ProfileApplication.appliedProfile: Field ref;
const unique UMLs$ProfileApplication.isStrict: Field Boolean;
const unique UMLs$ProfileApplication.applyingPackage: Field ref;
const unique UMLs$Enumeration: ClassName extends UMLs$DataType complete;
const unique UMLs$Enumeration.ownedLiteral: Field ref;
const unique UMLs$EnumerationLiteral: ClassName extends UMLs$InstanceSpecification complete;
const unique UMLs$EnumerationLiteral.enumeration: Field ref;
const unique UMLs$InstanceSpecification: ClassName extends UMLs$DeploymentTarget,UMLs$PackageableElement,UMLs$DeployedArtifact complete;
const unique UMLs$InstanceSpecification.classifier: Field ref;
const unique UMLs$InstanceSpecification.slot: Field ref;
const unique UMLs$InstanceSpecification.specification: Field ref;
const unique UMLs$Slot: ClassName extends UMLs$Element complete;
const unique UMLs$Slot.definingFeature: Field ref;
const unique UMLs$Slot.value: Field ref;
const unique UMLs$Slot.owningInstance: Field ref;
const unique UMLs$PrimitiveType: ClassName extends UMLs$DataType complete;
const unique UMLs$LiteralSpecification: ClassName extends UMLs$ValueSpecification complete;
   axiom (forall r: ref :: dtype(r)!= UMLs$LiteralSpecification);
const unique UMLs$LiteralInteger: ClassName extends UMLs$LiteralSpecification complete;
const unique UMLs$LiteralInteger.value: Field Integer;
const unique UMLs$LiteralString: ClassName extends UMLs$LiteralSpecification complete;
const unique UMLs$LiteralString.value: Field String;
const unique UMLs$LiteralBoolean: ClassName extends UMLs$LiteralSpecification complete;
const unique UMLs$LiteralBoolean.value: Field Boolean;
const unique UMLs$LiteralNull: ClassName extends UMLs$LiteralSpecification complete;
const unique UMLs$InstanceValue: ClassName extends UMLs$ValueSpecification complete;
const unique UMLs$InstanceValue.instance: Field ref;
const unique UMLs$LiteralUnlimitedNatural: ClassName extends UMLs$LiteralSpecification complete;
const unique UMLs$LiteralUnlimitedNatural.value: Field UnlimitedNatural;
const unique UMLs$OpaqueBehavior: ClassName extends UMLs$Behavior complete;
const unique UMLs$OpaqueBehavior.body: Field String;
const unique UMLs$OpaqueBehavior.language: Field String;
const unique UMLs$FunctionBehavior: ClassName extends UMLs$OpaqueBehavior complete;
const unique UMLs$OpaqueAction: ClassName extends UMLs$Action complete;
const unique UMLs$OpaqueAction.body: Field String;
const unique UMLs$OpaqueAction.language: Field String;
const unique UMLs$OpaqueAction.inputValue: Field ref;
const unique UMLs$OpaqueAction.outputValue: Field ref;
const unique UMLs$Action: ClassName extends UMLs$ExecutableNode complete;
const unique UMLs$Action.output: Field ref;
const unique UMLs$Action.input: Field ref;
const unique UMLs$Action.context: Field ref;
const unique UMLs$Action.localPrecondition: Field ref;
const unique UMLs$Action.localPostcondition: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$Action);
const unique UMLs$ExecutableNode: ClassName extends UMLs$ActivityNode complete;
const unique UMLs$ExecutableNode.handler: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$ExecutableNode);
const unique UMLs$ActivityNode: ClassName extends UMLs$RedefinableElement complete;
const unique UMLs$ActivityNode.inStructuredNode: Field ref;
const unique UMLs$ActivityNode.activity: Field ref;
const unique UMLs$ActivityNode.outgoing: Field ref;
const unique UMLs$ActivityNode.incoming: Field ref;
const unique UMLs$ActivityNode.inPartition: Field ref;
const unique UMLs$ActivityNode.inInterruptibleRegion: Field ref;
const unique UMLs$ActivityNode.inGroup: Field ref;
const unique UMLs$ActivityNode.redefinedNode: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$ActivityNode);
const unique UMLs$StructuredActivityNode: ClassName extends UMLs$Action,UMLs$Namespace,UMLs$ActivityGroup complete;
const unique UMLs$StructuredActivityNode.variable: Field ref;
const unique UMLs$StructuredActivityNode.edge: Field ref;
const unique UMLs$StructuredActivityNode.mustIsolate: Field Boolean;
const unique UMLs$StructuredActivityNode.node: Field ref;
const unique UMLs$ActivityGroup: ClassName extends UMLs$Element complete;
const unique UMLs$ActivityGroup.subgroup: Field ref;
const unique UMLs$ActivityGroup.superGroup: Field ref;
const unique UMLs$ActivityGroup.inActivity: Field ref;
const unique UMLs$ActivityGroup.containedEdge: Field ref;
const unique UMLs$ActivityGroup.containedNode: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$ActivityGroup);
const unique UMLs$Activity: ClassName extends UMLs$Behavior complete;
const unique UMLs$Activity.structuredNode: Field ref;
const unique UMLs$Activity.variable: Field ref;
const unique UMLs$Activity.node: Field ref;
const unique UMLs$Activity.isReadOnly: Field Boolean;
const unique UMLs$Activity.edge: Field ref;
const unique UMLs$Activity.partition: Field ref;
const unique UMLs$Activity.isSingleExecution: Field Boolean;
const unique UMLs$Activity.group: Field ref;
const unique UMLs$Variable: ClassName extends UMLs$ConnectableElement,UMLs$MultiplicityElement complete;
const unique UMLs$Variable.scope: Field ref;
const unique UMLs$Variable.activityScope: Field ref;
const unique UMLs$ActivityEdge: ClassName extends UMLs$RedefinableElement complete;
const unique UMLs$ActivityEdge.source: Field ref;
const unique UMLs$ActivityEdge.target: Field ref;
const unique UMLs$ActivityEdge.redefinedEdge: Field ref;
const unique UMLs$ActivityEdge.inPartition: Field ref;
const unique UMLs$ActivityEdge.guard: Field ref;
const unique UMLs$ActivityEdge.weight: Field ref;
const unique UMLs$ActivityEdge.interrupts: Field ref;
const unique UMLs$ActivityEdge.inStructuredNode: Field ref;
const unique UMLs$ActivityEdge.inGroup: Field ref;
const unique UMLs$ActivityEdge.activity: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$ActivityEdge);
const unique UMLs$ActivityPartition: ClassName extends UMLs$NamedElement,UMLs$ActivityGroup complete;
const unique UMLs$ActivityPartition.isDimension: Field Boolean;
const unique UMLs$ActivityPartition.isExternal: Field Boolean;
const unique UMLs$ActivityPartition.node: Field ref;
const unique UMLs$ActivityPartition.subpartition: Field ref;
const unique UMLs$ActivityPartition.superPartition: Field ref;
const unique UMLs$ActivityPartition.represents: Field ref;
const unique UMLs$ActivityPartition.edge: Field ref;
const unique UMLs$InterruptibleActivityRegion: ClassName extends UMLs$ActivityGroup complete;
const unique UMLs$InterruptibleActivityRegion.node: Field ref;
const unique UMLs$InterruptibleActivityRegion.interruptingEdge: Field ref;
const unique UMLs$ExceptionHandler: ClassName extends UMLs$Element complete;
const unique UMLs$ExceptionHandler.handlerBody: Field ref;
const unique UMLs$ExceptionHandler.exceptionInput: Field ref;
const unique UMLs$ExceptionHandler.exceptionType: Field ref;
const unique UMLs$ExceptionHandler.protectedNode: Field ref;
const unique UMLs$ObjectNode: ClassName extends UMLs$ActivityNode,UMLs$TypedElement complete;
const unique UMLs$ObjectNode.ordering: Field ObjectNodeOrderingKind;
const unique UMLs$ObjectNode.isControlType: Field Boolean;
const unique UMLs$ObjectNode.upperBound: Field ref;
const unique UMLs$ObjectNode.inState: Field ref;
const unique UMLs$ObjectNode.selection: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$ObjectNode);
const unique UMLs$OutputPin: ClassName extends UMLs$Pin complete;
const unique UMLs$Pin: ClassName extends UMLs$ObjectNode,UMLs$MultiplicityElement complete;
const unique UMLs$Pin.isControl: Field Boolean;
const unique UMLs$InputPin: ClassName extends UMLs$Pin complete;
const unique UMLs$CallAction: ClassName extends UMLs$InvocationAction complete;
const unique UMLs$CallAction.isSynchronous: Field Boolean;
const unique UMLs$CallAction.result: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$CallAction);
const unique UMLs$InvocationAction: ClassName extends UMLs$Action complete;
const unique UMLs$InvocationAction.argument: Field ref;
const unique UMLs$InvocationAction.onPort: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$InvocationAction);
const unique UMLs$SendSignalAction: ClassName extends UMLs$InvocationAction complete;
const unique UMLs$SendSignalAction.target: Field ref;
const unique UMLs$SendSignalAction.signal: Field ref;
const unique UMLs$CallOperationAction: ClassName extends UMLs$CallAction complete;
const unique UMLs$CallOperationAction.operation: Field ref;
const unique UMLs$CallOperationAction.target: Field ref;
const unique UMLs$CallBehaviorAction: ClassName extends UMLs$CallAction complete;
const unique UMLs$CallBehaviorAction.behavior: Field ref;
const unique UMLs$SequenceNode: ClassName extends UMLs$StructuredActivityNode complete;
const unique UMLs$SequenceNode.executableNode: Field ref;
const unique UMLs$ControlNode: ClassName extends UMLs$ActivityNode complete;
   axiom (forall r: ref :: dtype(r)!= UMLs$ControlNode);
const unique UMLs$ControlFlow: ClassName extends UMLs$ActivityEdge complete;
const unique UMLs$InitialNode: ClassName extends UMLs$ControlNode complete;
const unique UMLs$ActivityParameterNode: ClassName extends UMLs$ObjectNode complete;
const unique UMLs$ActivityParameterNode.parameter: Field ref;
const unique UMLs$ValuePin: ClassName extends UMLs$InputPin complete;
const unique UMLs$ValuePin.value: Field ref;
const unique UMLs$Message: ClassName extends UMLs$NamedElement complete;
const unique UMLs$Message.messageKind: Field MessageKind;
const unique UMLs$Message.messageSort: Field MessageSort;
const unique UMLs$Message.receiveEvent: Field ref;
const unique UMLs$Message.sendEvent: Field ref;
const unique UMLs$Message.connector: Field ref;
const unique UMLs$Message.interaction: Field ref;
const unique UMLs$Message.argument: Field ref;
const unique UMLs$Message.signature: Field ref;
const unique UMLs$MessageEnd: ClassName extends UMLs$NamedElement complete;
const unique UMLs$MessageEnd.message: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$MessageEnd);
const unique UMLs$Interaction: ClassName extends UMLs$Behavior,UMLs$InteractionFragment complete;
const unique UMLs$Interaction.lifeline: Field ref;
const unique UMLs$Interaction.fragment: Field ref;
const unique UMLs$Interaction.action: Field ref;
const unique UMLs$Interaction.formalGate: Field ref;
const unique UMLs$Interaction.message: Field ref;
const unique UMLs$InteractionFragment: ClassName extends UMLs$NamedElement complete;
const unique UMLs$InteractionFragment.covered: Field ref;
const unique UMLs$InteractionFragment.generalOrdering: Field ref;
const unique UMLs$InteractionFragment.enclosingInteraction: Field ref;
const unique UMLs$InteractionFragment.enclosingOperand: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$InteractionFragment);
const unique UMLs$Lifeline: ClassName extends UMLs$NamedElement complete;
const unique UMLs$Lifeline.represents: Field ref;
const unique UMLs$Lifeline.interaction: Field ref;
const unique UMLs$Lifeline.selector: Field ref;
const unique UMLs$Lifeline.decomposedAs: Field ref;
const unique UMLs$Lifeline.coveredBy: Field ref;
const unique UMLs$PartDecomposition: ClassName extends UMLs$InteractionUse complete;
const unique UMLs$InteractionUse: ClassName extends UMLs$InteractionFragment complete;
const unique UMLs$InteractionUse.refersTo: Field ref;
const unique UMLs$InteractionUse.actualGate: Field ref;
const unique UMLs$InteractionUse.argument: Field ref;
const unique UMLs$Gate: ClassName extends UMLs$MessageEnd complete;
const unique UMLs$GeneralOrdering: ClassName extends UMLs$NamedElement complete;
const unique UMLs$GeneralOrdering.before: Field ref;
const unique UMLs$GeneralOrdering.after: Field ref;
const unique UMLs$OccurrenceSpecification: ClassName extends UMLs$InteractionFragment complete;
const unique UMLs$OccurrenceSpecification.toBefore: Field ref;
const unique UMLs$OccurrenceSpecification.event: Field ref;
const unique UMLs$OccurrenceSpecification.toAfter: Field ref;
const unique UMLs$InteractionOperand: ClassName extends UMLs$Namespace,UMLs$InteractionFragment complete;
const unique UMLs$InteractionOperand.guard: Field ref;
const unique UMLs$InteractionOperand.fragment: Field ref;
const unique UMLs$InteractionConstraint: ClassName extends UMLs$Constraint complete;
const unique UMLs$InteractionConstraint.minint: Field ref;
const unique UMLs$InteractionConstraint.maxint: Field ref;
const unique UMLs$ExecutionSpecification: ClassName extends UMLs$InteractionFragment complete;
const unique UMLs$ExecutionSpecification.start: Field ref;
const unique UMLs$ExecutionSpecification.finish: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$ExecutionSpecification);
const unique UMLs$StateInvariant: ClassName extends UMLs$InteractionFragment complete;
const unique UMLs$StateInvariant.invariant: Field ref;
const unique UMLs$ActionExecutionSpecification: ClassName extends UMLs$ExecutionSpecification complete;
const unique UMLs$ActionExecutionSpecification.action: Field ref;
const unique UMLs$BehaviorExecutionSpecification: ClassName extends UMLs$ExecutionSpecification complete;
const unique UMLs$BehaviorExecutionSpecification.behavior: Field ref;
const unique UMLs$ExecutionEvent: ClassName extends UMLs$Event complete;
const unique UMLs$CreationEvent: ClassName extends UMLs$Event complete;
const unique UMLs$DestructionEvent: ClassName extends UMLs$Event complete;
const unique UMLs$SendOperationEvent: ClassName extends UMLs$MessageEvent complete;
const unique UMLs$SendOperationEvent.operation: Field ref;
const unique UMLs$MessageEvent: ClassName extends UMLs$Event complete;
   axiom (forall r: ref :: dtype(r)!= UMLs$MessageEvent);
const unique UMLs$SendSignalEvent: ClassName extends UMLs$MessageEvent complete;
const unique UMLs$SendSignalEvent.signal: Field ref;
const unique UMLs$MessageOccurrenceSpecification: ClassName extends UMLs$OccurrenceSpecification,UMLs$MessageEnd complete;
const unique UMLs$ExecutionOccurrenceSpecification: ClassName extends UMLs$OccurrenceSpecification complete;
const unique UMLs$ExecutionOccurrenceSpecification.execution: Field ref;
const unique UMLs$ReceiveOperationEvent: ClassName extends UMLs$MessageEvent complete;
const unique UMLs$ReceiveOperationEvent.operation: Field ref;
const unique UMLs$ReceiveSignalEvent: ClassName extends UMLs$MessageEvent complete;
const unique UMLs$ReceiveSignalEvent.signal: Field ref;
const unique UMLs$Actor: ClassName extends UMLs$BehavioredClassifier complete;
const unique UMLs$CallEvent: ClassName extends UMLs$MessageEvent complete;
const unique UMLs$CallEvent.operation: Field ref;
const unique UMLs$ChangeEvent: ClassName extends UMLs$Event complete;
const unique UMLs$ChangeEvent.changeExpression: Field ref;
const unique UMLs$SignalEvent: ClassName extends UMLs$MessageEvent complete;
const unique UMLs$SignalEvent.signal: Field ref;
const unique UMLs$AnyReceiveEvent: ClassName extends UMLs$MessageEvent complete;
const unique UMLs$ForkNode: ClassName extends UMLs$ControlNode complete;
const unique UMLs$FlowFinalNode: ClassName extends UMLs$FinalNode complete;
const unique UMLs$FinalNode: ClassName extends UMLs$ControlNode complete;
   axiom (forall r: ref :: dtype(r)!= UMLs$FinalNode);
const unique UMLs$CentralBufferNode: ClassName extends UMLs$ObjectNode complete;
const unique UMLs$MergeNode: ClassName extends UMLs$ControlNode complete;
const unique UMLs$DecisionNode: ClassName extends UMLs$ControlNode complete;
const unique UMLs$DecisionNode.decisionInput: Field ref;
const unique UMLs$DecisionNode.decisionInputFlow: Field ref;
const unique UMLs$ObjectFlow: ClassName extends UMLs$ActivityEdge complete;
const unique UMLs$ObjectFlow.isMulticast: Field Boolean;
const unique UMLs$ObjectFlow.isMultireceive: Field Boolean;
const unique UMLs$ObjectFlow.transformation: Field ref;
const unique UMLs$ObjectFlow.selection: Field ref;
const unique UMLs$ActivityFinalNode: ClassName extends UMLs$FinalNode complete;
const unique UMLs$ComponentRealization: ClassName extends UMLs$Realization complete;
const unique UMLs$ComponentRealization.abstraction: Field ref;
const unique UMLs$ComponentRealization.realizingClassifier: Field ref;
const unique UMLs$Component: ClassName extends UMLs$Class complete;
const unique UMLs$Component.isIndirectlyInstantiated: Field Boolean;
const unique UMLs$Component.required: Field ref;
const unique UMLs$Component.provided: Field ref;
const unique UMLs$Component.packagedElement: Field ref;
const unique UMLs$Component.realization: Field ref;
const unique UMLs$Node: ClassName extends UMLs$Class,UMLs$DeploymentTarget complete;
const unique UMLs$Node.nestedNode: Field ref;
const unique UMLs$CommunicationPath: ClassName extends UMLs$Association complete;
const unique UMLs$Device: ClassName extends UMLs$Node complete;
const unique UMLs$ExecutionEnvironment: ClassName extends UMLs$Node complete;
const unique UMLs$CombinedFragment: ClassName extends UMLs$InteractionFragment complete;
const unique UMLs$CombinedFragment.interactionOperator: Field InteractionOperatorKind;
const unique UMLs$CombinedFragment.operand: Field ref;
const unique UMLs$CombinedFragment.cfragmentGate: Field ref;
const unique UMLs$Continuation: ClassName extends UMLs$InteractionFragment complete;
const unique UMLs$Continuation.setting: Field Boolean;
const unique UMLs$ConsiderIgnoreFragment: ClassName extends UMLs$CombinedFragment complete;
const unique UMLs$ConsiderIgnoreFragment.message: Field ref;
const unique UMLs$CreateObjectAction: ClassName extends UMLs$Action complete;
const unique UMLs$CreateObjectAction.classifier: Field ref;
const unique UMLs$CreateObjectAction.result: Field ref;
const unique UMLs$DestroyObjectAction: ClassName extends UMLs$Action complete;
const unique UMLs$DestroyObjectAction.isDestroyLinks: Field Boolean;
const unique UMLs$DestroyObjectAction.isDestroyOwnedObjects: Field Boolean;
const unique UMLs$DestroyObjectAction.target: Field ref;
const unique UMLs$TestIdentityAction: ClassName extends UMLs$Action complete;
const unique UMLs$TestIdentityAction.first: Field ref;
const unique UMLs$TestIdentityAction.second: Field ref;
const unique UMLs$TestIdentityAction.result: Field ref;
const unique UMLs$ReadSelfAction: ClassName extends UMLs$Action complete;
const unique UMLs$ReadSelfAction.result: Field ref;
const unique UMLs$StructuralFeatureAction: ClassName extends UMLs$Action complete;
const unique UMLs$StructuralFeatureAction.structuralFeature: Field ref;
const unique UMLs$StructuralFeatureAction.object: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$StructuralFeatureAction);
const unique UMLs$ReadStructuralFeatureAction: ClassName extends UMLs$StructuralFeatureAction complete;
const unique UMLs$ReadStructuralFeatureAction.result: Field ref;
const unique UMLs$WriteStructuralFeatureAction: ClassName extends UMLs$StructuralFeatureAction complete;
const unique UMLs$WriteStructuralFeatureAction.value: Field ref;
const unique UMLs$WriteStructuralFeatureAction.result: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$WriteStructuralFeatureAction);
const unique UMLs$ClearStructuralFeatureAction: ClassName extends UMLs$StructuralFeatureAction complete;
const unique UMLs$ClearStructuralFeatureAction.result: Field ref;
const unique UMLs$RemoveStructuralFeatureValueAction: ClassName extends UMLs$WriteStructuralFeatureAction complete;
const unique UMLs$RemoveStructuralFeatureValueAction.isRemoveDuplicates: Field Boolean;
const unique UMLs$RemoveStructuralFeatureValueAction.removeAt: Field ref;
const unique UMLs$AddStructuralFeatureValueAction: ClassName extends UMLs$WriteStructuralFeatureAction complete;
const unique UMLs$AddStructuralFeatureValueAction.isReplaceAll: Field Boolean;
const unique UMLs$AddStructuralFeatureValueAction.insertAt: Field ref;
const unique UMLs$LinkAction: ClassName extends UMLs$Action complete;
const unique UMLs$LinkAction.endData: Field ref;
const unique UMLs$LinkAction.inputValue: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$LinkAction);
const unique UMLs$LinkEndData: ClassName extends UMLs$Element complete;
const unique UMLs$LinkEndData.value: Field ref;
const unique UMLs$LinkEndData.end: Field ref;
const unique UMLs$LinkEndData.qualifier: Field ref;
const unique UMLs$QualifierValue: ClassName extends UMLs$Element complete;
const unique UMLs$QualifierValue.qualifier: Field ref;
const unique UMLs$QualifierValue.value: Field ref;
const unique UMLs$ReadLinkAction: ClassName extends UMLs$LinkAction complete;
const unique UMLs$ReadLinkAction.result: Field ref;
const unique UMLs$LinkEndCreationData: ClassName extends UMLs$LinkEndData complete;
const unique UMLs$LinkEndCreationData.isReplaceAll: Field Boolean;
const unique UMLs$LinkEndCreationData.insertAt: Field ref;
const unique UMLs$CreateLinkAction: ClassName extends UMLs$WriteLinkAction complete;
const unique UMLs$WriteLinkAction: ClassName extends UMLs$LinkAction complete;
   axiom (forall r: ref :: dtype(r)!= UMLs$WriteLinkAction);
const unique UMLs$DestroyLinkAction: ClassName extends UMLs$WriteLinkAction complete;
const unique UMLs$LinkEndDestructionData: ClassName extends UMLs$LinkEndData complete;
const unique UMLs$LinkEndDestructionData.isDestroyDuplicates: Field Boolean;
const unique UMLs$LinkEndDestructionData.destroyAt: Field ref;
const unique UMLs$ClearAssociationAction: ClassName extends UMLs$Action complete;
const unique UMLs$ClearAssociationAction.object: Field ref;
const unique UMLs$ClearAssociationAction.association: Field ref;
const unique UMLs$BroadcastSignalAction: ClassName extends UMLs$InvocationAction complete;
const unique UMLs$BroadcastSignalAction.signal: Field ref;
const unique UMLs$SendObjectAction: ClassName extends UMLs$InvocationAction complete;
const unique UMLs$SendObjectAction.target: Field ref;
const unique UMLs$SendObjectAction.request: Field ref;
const unique UMLs$ValueSpecificationAction: ClassName extends UMLs$Action complete;
const unique UMLs$ValueSpecificationAction.value: Field ref;
const unique UMLs$ValueSpecificationAction.result: Field ref;
const unique UMLs$TimeExpression: ClassName extends UMLs$ValueSpecification complete;
const unique UMLs$TimeExpression.expr: Field ref;
const unique UMLs$TimeExpression.observation: Field ref;
const unique UMLs$Observation: ClassName extends UMLs$PackageableElement complete;
   axiom (forall r: ref :: dtype(r)!= UMLs$Observation);
const unique UMLs$Duration: ClassName extends UMLs$ValueSpecification complete;
const unique UMLs$Duration.expr: Field ref;
const unique UMLs$Duration.observation: Field ref;
const unique UMLs$DurationInterval: ClassName extends UMLs$Interval complete;
const unique UMLs$Interval: ClassName extends UMLs$ValueSpecification complete;
const unique UMLs$Interval.min: Field ref;
const unique UMLs$Interval.max: Field ref;
const unique UMLs$TimeConstraint: ClassName extends UMLs$IntervalConstraint complete;
const unique UMLs$TimeConstraint.firstEvent: Field Boolean;
const unique UMLs$IntervalConstraint: ClassName extends UMLs$Constraint complete;
const unique UMLs$TimeInterval: ClassName extends UMLs$Interval complete;
const unique UMLs$DurationConstraint: ClassName extends UMLs$IntervalConstraint complete;
const unique UMLs$DurationConstraint.firstEvent: Field Boolean;
const unique UMLs$TimeObservation: ClassName extends UMLs$Observation complete;
const unique UMLs$TimeObservation.event: Field ref;
const unique UMLs$TimeObservation.firstEvent: Field Boolean;
const unique UMLs$DurationObservation: ClassName extends UMLs$Observation complete;
const unique UMLs$DurationObservation.event: Field ref;
const unique UMLs$DurationObservation.firstEvent: Field Boolean;
const unique UMLs$FinalState: ClassName extends UMLs$State complete;
const unique UMLs$TimeEvent: ClassName extends UMLs$Event complete;
const unique UMLs$TimeEvent.isRelative: Field Boolean;
const unique UMLs$TimeEvent.when: Field ref;
const unique UMLs$VariableAction: ClassName extends UMLs$Action complete;
const unique UMLs$VariableAction.variable: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$VariableAction);
const unique UMLs$ReadVariableAction: ClassName extends UMLs$VariableAction complete;
const unique UMLs$ReadVariableAction.result: Field ref;
const unique UMLs$WriteVariableAction: ClassName extends UMLs$VariableAction complete;
const unique UMLs$WriteVariableAction.value: Field ref;
   axiom (forall r: ref :: dtype(r)!= UMLs$WriteVariableAction);
const unique UMLs$ClearVariableAction: ClassName extends UMLs$VariableAction complete;
const unique UMLs$AddVariableValueAction: ClassName extends UMLs$WriteVariableAction complete;
const unique UMLs$AddVariableValueAction.isReplaceAll: Field Boolean;
const unique UMLs$AddVariableValueAction.insertAt: Field ref;
const unique UMLs$RemoveVariableValueAction: ClassName extends UMLs$WriteVariableAction complete;
const unique UMLs$RemoveVariableValueAction.isRemoveDuplicates: Field Boolean;
const unique UMLs$RemoveVariableValueAction.removeAt: Field ref;
const unique UMLs$RaiseExceptionAction: ClassName extends UMLs$Action complete;
const unique UMLs$RaiseExceptionAction.exception: Field ref;
const unique UMLs$ActionInputPin: ClassName extends UMLs$InputPin complete;
const unique UMLs$ActionInputPin.fromAction: Field ref;
const unique UMLs$InformationItem: ClassName extends UMLs$Classifier complete;
const unique UMLs$InformationItem.represented: Field ref;
const unique UMLs$InformationFlow: ClassName extends UMLs$PackageableElement,UMLs$DirectedRelationship complete;
const unique UMLs$InformationFlow.realization: Field ref;
const unique UMLs$InformationFlow.conveyed: Field ref;
const unique UMLs$InformationFlow.informationSource: Field ref;
const unique UMLs$InformationFlow.informationTarget: Field ref;
const unique UMLs$InformationFlow.realizingActivityEdge: Field ref;
const unique UMLs$InformationFlow.realizingConnector: Field ref;
const unique UMLs$InformationFlow.realizingMessage: Field ref;
const unique UMLs$ReadExtentAction: ClassName extends UMLs$Action complete;
const unique UMLs$ReadExtentAction.result: Field ref;
const unique UMLs$ReadExtentAction.classifier: Field ref;
const unique UMLs$ReclassifyObjectAction: ClassName extends UMLs$Action complete;
const unique UMLs$ReclassifyObjectAction.isReplaceAll: Field Boolean;
const unique UMLs$ReclassifyObjectAction.oldClassifier: Field ref;
const unique UMLs$ReclassifyObjectAction.newClassifier: Field ref;
const unique UMLs$ReclassifyObjectAction.object: Field ref;
const unique UMLs$ReadIsClassifiedObjectAction: ClassName extends UMLs$Action complete;
const unique UMLs$ReadIsClassifiedObjectAction.isDirect: Field Boolean;
const unique UMLs$ReadIsClassifiedObjectAction.classifier: Field ref;
const unique UMLs$ReadIsClassifiedObjectAction.result: Field ref;
const unique UMLs$ReadIsClassifiedObjectAction.object: Field ref;
const unique UMLs$StartClassifierBehaviorAction: ClassName extends UMLs$Action complete;
const unique UMLs$StartClassifierBehaviorAction.object: Field ref;
const unique UMLs$ReadLinkObjectEndAction: ClassName extends UMLs$Action complete;
const unique UMLs$ReadLinkObjectEndAction.object: Field ref;
const unique UMLs$ReadLinkObjectEndAction.end: Field ref;
const unique UMLs$ReadLinkObjectEndAction.result: Field ref;
const unique UMLs$ReadLinkObjectEndQualifierAction: ClassName extends UMLs$Action complete;
const unique UMLs$ReadLinkObjectEndQualifierAction.object: Field ref;
const unique UMLs$ReadLinkObjectEndQualifierAction.result: Field ref;
const unique UMLs$ReadLinkObjectEndQualifierAction.qualifier: Field ref;
const unique UMLs$CreateLinkObjectAction: ClassName extends UMLs$CreateLinkAction complete;
const unique UMLs$CreateLinkObjectAction.result: Field ref;
const unique UMLs$AcceptEventAction: ClassName extends UMLs$Action complete;
const unique UMLs$AcceptEventAction.isUnmarshall: Field Boolean;
const unique UMLs$AcceptEventAction.result: Field ref;
const unique UMLs$AcceptEventAction.trigger: Field ref;
const unique UMLs$AcceptCallAction: ClassName extends UMLs$AcceptEventAction complete;
const unique UMLs$AcceptCallAction.returnInformation: Field ref;
const unique UMLs$ReplyAction: ClassName extends UMLs$Action complete;
const unique UMLs$ReplyAction.replyToCall: Field ref;
const unique UMLs$ReplyAction.returnInformation: Field ref;
const unique UMLs$ReplyAction.replyValue: Field ref;
const unique UMLs$UnmarshallAction: ClassName extends UMLs$Action complete;
const unique UMLs$UnmarshallAction.result: Field ref;
const unique UMLs$UnmarshallAction.unmarshallType: Field ref;
const unique UMLs$UnmarshallAction.object: Field ref;
const unique UMLs$ReduceAction: ClassName extends UMLs$Action complete;
const unique UMLs$ReduceAction.reducer: Field ref;
const unique UMLs$ReduceAction.result: Field ref;
const unique UMLs$ReduceAction.collection: Field ref;
const unique UMLs$ReduceAction.isOrdered: Field Boolean;
const unique UMLs$StartObjectBehaviorAction: ClassName extends UMLs$CallAction complete;
const unique UMLs$StartObjectBehaviorAction.object: Field ref;
const unique UMLs$JoinNode: ClassName extends UMLs$ControlNode complete;
const unique UMLs$JoinNode.isCombineDuplicate: Field Boolean;
const unique UMLs$JoinNode.joinSpec: Field ref;
const unique UMLs$DataStoreNode: ClassName extends UMLs$CentralBufferNode complete;
const unique UMLs$ConditionalNode: ClassName extends UMLs$StructuredActivityNode complete;
const unique UMLs$ConditionalNode.isDeterminate: Field Boolean;
const unique UMLs$ConditionalNode.isAssured: Field Boolean;
const unique UMLs$ConditionalNode.clause: Field ref;
const unique UMLs$ConditionalNode.result: Field ref;
const unique UMLs$Clause: ClassName extends UMLs$Element complete;
const unique UMLs$Clause.test: Field ref;
const unique UMLs$Clause.body: Field ref;
const unique UMLs$Clause.predecessorClause: Field ref;
const unique UMLs$Clause.successorClause: Field ref;
const unique UMLs$Clause.decider: Field ref;
const unique UMLs$Clause.bodyOutput: Field ref;
const unique UMLs$LoopNode: ClassName extends UMLs$StructuredActivityNode complete;
const unique UMLs$LoopNode.isTestedFirst: Field Boolean;
const unique UMLs$LoopNode.bodyPart: Field ref;
const unique UMLs$LoopNode.setupPart: Field ref;
const unique UMLs$LoopNode.decider: Field ref;
const unique UMLs$LoopNode.test: Field ref;
const unique UMLs$LoopNode.result: Field ref;
const unique UMLs$LoopNode.loopVariable: Field ref;
const unique UMLs$LoopNode.bodyOutput: Field ref;
const unique UMLs$LoopNode.loopVariableInput: Field ref;
const unique UMLs$ExpansionNode: ClassName extends UMLs$ObjectNode complete;
const unique UMLs$ExpansionNode.regionAsOutput: Field ref;
const unique UMLs$ExpansionNode.regionAsInput: Field ref;
const unique UMLs$ExpansionRegion: ClassName extends UMLs$StructuredActivityNode complete;
const unique UMLs$ExpansionRegion.mode: Field ExpansionKind;
const unique UMLs$ExpansionRegion.inputElement: Field ref;
const unique UMLs$ExpansionRegion.outputElement: Field ref;
const unique UMLs$ProtocolTransition: ClassName extends UMLs$Transition complete;
const unique UMLs$ProtocolTransition.postCondition: Field ref;
const unique UMLs$ProtocolTransition.referred: Field ref;
const unique UMLs$ProtocolTransition.preCondition: Field ref;
const unique UMLs$AssociationClass: ClassName extends UMLs$Class,UMLs$Association complete;

// print classifier table
axiom classifierTable[_UMLs, _Comment] == UMLs$Comment;
axiom classifierTable[_UMLs, _Element] == UMLs$Element;
axiom classifierTable[_UMLs, _Package] == UMLs$Package;
axiom classifierTable[_UMLs, _PackageableElement] == UMLs$PackageableElement;
axiom classifierTable[_UMLs, _NamedElement] == UMLs$NamedElement;
axiom classifierTable[_UMLs, _Dependency] == UMLs$Dependency;
axiom classifierTable[_UMLs, _DirectedRelationship] == UMLs$DirectedRelationship;
axiom classifierTable[_UMLs, _Relationship] == UMLs$Relationship;
axiom classifierTable[_UMLs, _Namespace] == UMLs$Namespace;
axiom classifierTable[_UMLs, _ElementImport] == UMLs$ElementImport;
axiom classifierTable[_UMLs, _PackageImport] == UMLs$PackageImport;
axiom classifierTable[_UMLs, _Constraint] == UMLs$Constraint;
axiom classifierTable[_UMLs, _ValueSpecification] == UMLs$ValueSpecification;
axiom classifierTable[_UMLs, _TypedElement] == UMLs$TypedElement;
axiom classifierTable[_UMLs, _Type] == UMLs$Type;
axiom classifierTable[_UMLs, _Association] == UMLs$Association;
axiom classifierTable[_UMLs, _Classifier] == UMLs$Classifier;
axiom classifierTable[_UMLs, _RedefinableElement] == UMLs$RedefinableElement;
axiom classifierTable[_UMLs, _TemplateableElement] == UMLs$TemplateableElement;
axiom classifierTable[_UMLs, _TemplateBinding] == UMLs$TemplateBinding;
axiom classifierTable[_UMLs, _TemplateSignature] == UMLs$TemplateSignature;
axiom classifierTable[_UMLs, _TemplateParameter] == UMLs$TemplateParameter;
axiom classifierTable[_UMLs, _ParameterableElement] == UMLs$ParameterableElement;
axiom classifierTable[_UMLs, _TemplateParameterSubstitution] == UMLs$TemplateParameterSubstitution;
axiom classifierTable[_UMLs, _Generalization] == UMLs$Generalization;
axiom classifierTable[_UMLs, _GeneralizationSet] == UMLs$GeneralizationSet;
axiom classifierTable[_UMLs, _Feature] == UMLs$Feature;
axiom classifierTable[_UMLs, _Substitution] == UMLs$Substitution;
axiom classifierTable[_UMLs, _Realization] == UMLs$Realization;
axiom classifierTable[_UMLs, _Abstraction] == UMLs$Abstraction;
axiom classifierTable[_UMLs, _OpaqueExpression] == UMLs$OpaqueExpression;
axiom classifierTable[_UMLs, _Parameter] == UMLs$Parameter;
axiom classifierTable[_UMLs, _MultiplicityElement] == UMLs$MultiplicityElement;
axiom classifierTable[_UMLs, _ConnectableElement] == UMLs$ConnectableElement;
axiom classifierTable[_UMLs, _ConnectorEnd] == UMLs$ConnectorEnd;
axiom classifierTable[_UMLs, _Property] == UMLs$Property;
axiom classifierTable[_UMLs, _DeploymentTarget] == UMLs$DeploymentTarget;
axiom classifierTable[_UMLs, _Deployment] == UMLs$Deployment;
axiom classifierTable[_UMLs, _DeployedArtifact] == UMLs$DeployedArtifact;
axiom classifierTable[_UMLs, _DeploymentSpecification] == UMLs$DeploymentSpecification;
axiom classifierTable[_UMLs, _Artifact] == UMLs$Artifact;
axiom classifierTable[_UMLs, _Manifestation] == UMLs$Manifestation;
axiom classifierTable[_UMLs, _Operation] == UMLs$Operation;
axiom classifierTable[_UMLs, _BehavioralFeature] == UMLs$BehavioralFeature;
axiom classifierTable[_UMLs, _Behavior] == UMLs$Behavior;
axiom classifierTable[_UMLs, _Class] == UMLs$Class;
axiom classifierTable[_UMLs, _BehavioredClassifier] == UMLs$BehavioredClassifier;
axiom classifierTable[_UMLs, _InterfaceRealization] == UMLs$InterfaceRealization;
axiom classifierTable[_UMLs, _Interface] == UMLs$Interface;
axiom classifierTable[_UMLs, _Reception] == UMLs$Reception;
axiom classifierTable[_UMLs, _Signal] == UMLs$Signal;
axiom classifierTable[_UMLs, _ProtocolStateMachine] == UMLs$ProtocolStateMachine;
axiom classifierTable[_UMLs, _StateMachine] == UMLs$StateMachine;
axiom classifierTable[_UMLs, _Region] == UMLs$Region;
axiom classifierTable[_UMLs, _Vertex] == UMLs$Vertex;
axiom classifierTable[_UMLs, _Transition] == UMLs$Transition;
axiom classifierTable[_UMLs, _Trigger] == UMLs$Trigger;
axiom classifierTable[_UMLs, _Event] == UMLs$Event;
axiom classifierTable[_UMLs, _Port] == UMLs$Port;
axiom classifierTable[_UMLs, _State] == UMLs$State;
axiom classifierTable[_UMLs, _ConnectionPointReference] == UMLs$ConnectionPointReference;
axiom classifierTable[_UMLs, _Pseudostate] == UMLs$Pseudostate;
axiom classifierTable[_UMLs, _ProtocolConformance] == UMLs$ProtocolConformance;
axiom classifierTable[_UMLs, _EncapsulatedClassifier] == UMLs$EncapsulatedClassifier;
axiom classifierTable[_UMLs, _StructuredClassifier] == UMLs$StructuredClassifier;
axiom classifierTable[_UMLs, _Connector] == UMLs$Connector;
axiom classifierTable[_UMLs, _Extension] == UMLs$Extension;
axiom classifierTable[_UMLs, _ExtensionEnd] == UMLs$ExtensionEnd;
axiom classifierTable[_UMLs, _Stereotype] == UMLs$Stereotype;
axiom classifierTable[_UMLs, _Image] == UMLs$Image;
axiom classifierTable[_UMLs, _Profile] == UMLs$Profile;
axiom classifierTable[_UMLs, _Model] == UMLs$Model;
axiom classifierTable[_UMLs, _ParameterSet] == UMLs$ParameterSet;
axiom classifierTable[_UMLs, _DataType] == UMLs$DataType;
axiom classifierTable[_UMLs, _OperationTemplateParameter] == UMLs$OperationTemplateParameter;
axiom classifierTable[_UMLs, _StructuralFeature] == UMLs$StructuralFeature;
axiom classifierTable[_UMLs, _ConnectableElementTemplateParameter] == UMLs$ConnectableElementTemplateParameter;
axiom classifierTable[_UMLs, _CollaborationUse] == UMLs$CollaborationUse;
axiom classifierTable[_UMLs, _Collaboration] == UMLs$Collaboration;
axiom classifierTable[_UMLs, _UseCase] == UMLs$UseCase;
axiom classifierTable[_UMLs, _Include] == UMLs$Include;
axiom classifierTable[_UMLs, _Extend] == UMLs$Extend;
axiom classifierTable[_UMLs, _ExtensionPoint] == UMLs$ExtensionPoint;
axiom classifierTable[_UMLs, _RedefinableTemplateSignature] == UMLs$RedefinableTemplateSignature;
axiom classifierTable[_UMLs, _ClassifierTemplateParameter] == UMLs$ClassifierTemplateParameter;
axiom classifierTable[_UMLs, _StringExpression] == UMLs$StringExpression;
axiom classifierTable[_UMLs, _Expression] == UMLs$Expression;
axiom classifierTable[_UMLs, _Usage] == UMLs$Usage;
axiom classifierTable[_UMLs, _PackageMerge] == UMLs$PackageMerge;
axiom classifierTable[_UMLs, _ProfileApplication] == UMLs$ProfileApplication;
axiom classifierTable[_UMLs, _Enumeration] == UMLs$Enumeration;
axiom classifierTable[_UMLs, _EnumerationLiteral] == UMLs$EnumerationLiteral;
axiom classifierTable[_UMLs, _InstanceSpecification] == UMLs$InstanceSpecification;
axiom classifierTable[_UMLs, _Slot] == UMLs$Slot;
axiom classifierTable[_UMLs, _PrimitiveType] == UMLs$PrimitiveType;
axiom classifierTable[_UMLs, _LiteralSpecification] == UMLs$LiteralSpecification;
axiom classifierTable[_UMLs, _LiteralInteger] == UMLs$LiteralInteger;
axiom classifierTable[_UMLs, _LiteralString] == UMLs$LiteralString;
axiom classifierTable[_UMLs, _LiteralBoolean] == UMLs$LiteralBoolean;
axiom classifierTable[_UMLs, _LiteralNull] == UMLs$LiteralNull;
axiom classifierTable[_UMLs, _InstanceValue] == UMLs$InstanceValue;
axiom classifierTable[_UMLs, _LiteralUnlimitedNatural] == UMLs$LiteralUnlimitedNatural;
axiom classifierTable[_UMLs, _OpaqueBehavior] == UMLs$OpaqueBehavior;
axiom classifierTable[_UMLs, _FunctionBehavior] == UMLs$FunctionBehavior;
axiom classifierTable[_UMLs, _OpaqueAction] == UMLs$OpaqueAction;
axiom classifierTable[_UMLs, _Action] == UMLs$Action;
axiom classifierTable[_UMLs, _ExecutableNode] == UMLs$ExecutableNode;
axiom classifierTable[_UMLs, _ActivityNode] == UMLs$ActivityNode;
axiom classifierTable[_UMLs, _StructuredActivityNode] == UMLs$StructuredActivityNode;
axiom classifierTable[_UMLs, _ActivityGroup] == UMLs$ActivityGroup;
axiom classifierTable[_UMLs, _Activity] == UMLs$Activity;
axiom classifierTable[_UMLs, _Variable] == UMLs$Variable;
axiom classifierTable[_UMLs, _ActivityEdge] == UMLs$ActivityEdge;
axiom classifierTable[_UMLs, _ActivityPartition] == UMLs$ActivityPartition;
axiom classifierTable[_UMLs, _InterruptibleActivityRegion] == UMLs$InterruptibleActivityRegion;
axiom classifierTable[_UMLs, _ExceptionHandler] == UMLs$ExceptionHandler;
axiom classifierTable[_UMLs, _ObjectNode] == UMLs$ObjectNode;
axiom classifierTable[_UMLs, _OutputPin] == UMLs$OutputPin;
axiom classifierTable[_UMLs, _Pin] == UMLs$Pin;
axiom classifierTable[_UMLs, _InputPin] == UMLs$InputPin;
axiom classifierTable[_UMLs, _CallAction] == UMLs$CallAction;
axiom classifierTable[_UMLs, _InvocationAction] == UMLs$InvocationAction;
axiom classifierTable[_UMLs, _SendSignalAction] == UMLs$SendSignalAction;
axiom classifierTable[_UMLs, _CallOperationAction] == UMLs$CallOperationAction;
axiom classifierTable[_UMLs, _CallBehaviorAction] == UMLs$CallBehaviorAction;
axiom classifierTable[_UMLs, _SequenceNode] == UMLs$SequenceNode;
axiom classifierTable[_UMLs, _ControlNode] == UMLs$ControlNode;
axiom classifierTable[_UMLs, _ControlFlow] == UMLs$ControlFlow;
axiom classifierTable[_UMLs, _InitialNode] == UMLs$InitialNode;
axiom classifierTable[_UMLs, _ActivityParameterNode] == UMLs$ActivityParameterNode;
axiom classifierTable[_UMLs, _ValuePin] == UMLs$ValuePin;
axiom classifierTable[_UMLs, _Message] == UMLs$Message;
axiom classifierTable[_UMLs, _MessageEnd] == UMLs$MessageEnd;
axiom classifierTable[_UMLs, _Interaction] == UMLs$Interaction;
axiom classifierTable[_UMLs, _InteractionFragment] == UMLs$InteractionFragment;
axiom classifierTable[_UMLs, _Lifeline] == UMLs$Lifeline;
axiom classifierTable[_UMLs, _PartDecomposition] == UMLs$PartDecomposition;
axiom classifierTable[_UMLs, _InteractionUse] == UMLs$InteractionUse;
axiom classifierTable[_UMLs, _Gate] == UMLs$Gate;
axiom classifierTable[_UMLs, _GeneralOrdering] == UMLs$GeneralOrdering;
axiom classifierTable[_UMLs, _OccurrenceSpecification] == UMLs$OccurrenceSpecification;
axiom classifierTable[_UMLs, _InteractionOperand] == UMLs$InteractionOperand;
axiom classifierTable[_UMLs, _InteractionConstraint] == UMLs$InteractionConstraint;
axiom classifierTable[_UMLs, _ExecutionSpecification] == UMLs$ExecutionSpecification;
axiom classifierTable[_UMLs, _StateInvariant] == UMLs$StateInvariant;
axiom classifierTable[_UMLs, _ActionExecutionSpecification] == UMLs$ActionExecutionSpecification;
axiom classifierTable[_UMLs, _BehaviorExecutionSpecification] == UMLs$BehaviorExecutionSpecification;
axiom classifierTable[_UMLs, _ExecutionEvent] == UMLs$ExecutionEvent;
axiom classifierTable[_UMLs, _CreationEvent] == UMLs$CreationEvent;
axiom classifierTable[_UMLs, _DestructionEvent] == UMLs$DestructionEvent;
axiom classifierTable[_UMLs, _SendOperationEvent] == UMLs$SendOperationEvent;
axiom classifierTable[_UMLs, _MessageEvent] == UMLs$MessageEvent;
axiom classifierTable[_UMLs, _SendSignalEvent] == UMLs$SendSignalEvent;
axiom classifierTable[_UMLs, _MessageOccurrenceSpecification] == UMLs$MessageOccurrenceSpecification;
axiom classifierTable[_UMLs, _ExecutionOccurrenceSpecification] == UMLs$ExecutionOccurrenceSpecification;
axiom classifierTable[_UMLs, _ReceiveOperationEvent] == UMLs$ReceiveOperationEvent;
axiom classifierTable[_UMLs, _ReceiveSignalEvent] == UMLs$ReceiveSignalEvent;
axiom classifierTable[_UMLs, _Actor] == UMLs$Actor;
axiom classifierTable[_UMLs, _CallEvent] == UMLs$CallEvent;
axiom classifierTable[_UMLs, _ChangeEvent] == UMLs$ChangeEvent;
axiom classifierTable[_UMLs, _SignalEvent] == UMLs$SignalEvent;
axiom classifierTable[_UMLs, _AnyReceiveEvent] == UMLs$AnyReceiveEvent;
axiom classifierTable[_UMLs, _ForkNode] == UMLs$ForkNode;
axiom classifierTable[_UMLs, _FlowFinalNode] == UMLs$FlowFinalNode;
axiom classifierTable[_UMLs, _FinalNode] == UMLs$FinalNode;
axiom classifierTable[_UMLs, _CentralBufferNode] == UMLs$CentralBufferNode;
axiom classifierTable[_UMLs, _MergeNode] == UMLs$MergeNode;
axiom classifierTable[_UMLs, _DecisionNode] == UMLs$DecisionNode;
axiom classifierTable[_UMLs, _ObjectFlow] == UMLs$ObjectFlow;
axiom classifierTable[_UMLs, _ActivityFinalNode] == UMLs$ActivityFinalNode;
axiom classifierTable[_UMLs, _ComponentRealization] == UMLs$ComponentRealization;
axiom classifierTable[_UMLs, _Component] == UMLs$Component;
axiom classifierTable[_UMLs, _Node] == UMLs$Node;
axiom classifierTable[_UMLs, _CommunicationPath] == UMLs$CommunicationPath;
axiom classifierTable[_UMLs, _Device] == UMLs$Device;
axiom classifierTable[_UMLs, _ExecutionEnvironment] == UMLs$ExecutionEnvironment;
axiom classifierTable[_UMLs, _CombinedFragment] == UMLs$CombinedFragment;
axiom classifierTable[_UMLs, _Continuation] == UMLs$Continuation;
axiom classifierTable[_UMLs, _ConsiderIgnoreFragment] == UMLs$ConsiderIgnoreFragment;
axiom classifierTable[_UMLs, _CreateObjectAction] == UMLs$CreateObjectAction;
axiom classifierTable[_UMLs, _DestroyObjectAction] == UMLs$DestroyObjectAction;
axiom classifierTable[_UMLs, _TestIdentityAction] == UMLs$TestIdentityAction;
axiom classifierTable[_UMLs, _ReadSelfAction] == UMLs$ReadSelfAction;
axiom classifierTable[_UMLs, _StructuralFeatureAction] == UMLs$StructuralFeatureAction;
axiom classifierTable[_UMLs, _ReadStructuralFeatureAction] == UMLs$ReadStructuralFeatureAction;
axiom classifierTable[_UMLs, _WriteStructuralFeatureAction] == UMLs$WriteStructuralFeatureAction;
axiom classifierTable[_UMLs, _ClearStructuralFeatureAction] == UMLs$ClearStructuralFeatureAction;
axiom classifierTable[_UMLs, _RemoveStructuralFeatureValueAction] == UMLs$RemoveStructuralFeatureValueAction;
axiom classifierTable[_UMLs, _AddStructuralFeatureValueAction] == UMLs$AddStructuralFeatureValueAction;
axiom classifierTable[_UMLs, _LinkAction] == UMLs$LinkAction;
axiom classifierTable[_UMLs, _LinkEndData] == UMLs$LinkEndData;
axiom classifierTable[_UMLs, _QualifierValue] == UMLs$QualifierValue;
axiom classifierTable[_UMLs, _ReadLinkAction] == UMLs$ReadLinkAction;
axiom classifierTable[_UMLs, _LinkEndCreationData] == UMLs$LinkEndCreationData;
axiom classifierTable[_UMLs, _CreateLinkAction] == UMLs$CreateLinkAction;
axiom classifierTable[_UMLs, _WriteLinkAction] == UMLs$WriteLinkAction;
axiom classifierTable[_UMLs, _DestroyLinkAction] == UMLs$DestroyLinkAction;
axiom classifierTable[_UMLs, _LinkEndDestructionData] == UMLs$LinkEndDestructionData;
axiom classifierTable[_UMLs, _ClearAssociationAction] == UMLs$ClearAssociationAction;
axiom classifierTable[_UMLs, _BroadcastSignalAction] == UMLs$BroadcastSignalAction;
axiom classifierTable[_UMLs, _SendObjectAction] == UMLs$SendObjectAction;
axiom classifierTable[_UMLs, _ValueSpecificationAction] == UMLs$ValueSpecificationAction;
axiom classifierTable[_UMLs, _TimeExpression] == UMLs$TimeExpression;
axiom classifierTable[_UMLs, _Observation] == UMLs$Observation;
axiom classifierTable[_UMLs, _Duration] == UMLs$Duration;
axiom classifierTable[_UMLs, _DurationInterval] == UMLs$DurationInterval;
axiom classifierTable[_UMLs, _Interval] == UMLs$Interval;
axiom classifierTable[_UMLs, _TimeConstraint] == UMLs$TimeConstraint;
axiom classifierTable[_UMLs, _IntervalConstraint] == UMLs$IntervalConstraint;
axiom classifierTable[_UMLs, _TimeInterval] == UMLs$TimeInterval;
axiom classifierTable[_UMLs, _DurationConstraint] == UMLs$DurationConstraint;
axiom classifierTable[_UMLs, _TimeObservation] == UMLs$TimeObservation;
axiom classifierTable[_UMLs, _DurationObservation] == UMLs$DurationObservation;
axiom classifierTable[_UMLs, _FinalState] == UMLs$FinalState;
axiom classifierTable[_UMLs, _TimeEvent] == UMLs$TimeEvent;
axiom classifierTable[_UMLs, _VariableAction] == UMLs$VariableAction;
axiom classifierTable[_UMLs, _ReadVariableAction] == UMLs$ReadVariableAction;
axiom classifierTable[_UMLs, _WriteVariableAction] == UMLs$WriteVariableAction;
axiom classifierTable[_UMLs, _ClearVariableAction] == UMLs$ClearVariableAction;
axiom classifierTable[_UMLs, _AddVariableValueAction] == UMLs$AddVariableValueAction;
axiom classifierTable[_UMLs, _RemoveVariableValueAction] == UMLs$RemoveVariableValueAction;
axiom classifierTable[_UMLs, _RaiseExceptionAction] == UMLs$RaiseExceptionAction;
axiom classifierTable[_UMLs, _ActionInputPin] == UMLs$ActionInputPin;
axiom classifierTable[_UMLs, _InformationItem] == UMLs$InformationItem;
axiom classifierTable[_UMLs, _InformationFlow] == UMLs$InformationFlow;
axiom classifierTable[_UMLs, _ReadExtentAction] == UMLs$ReadExtentAction;
axiom classifierTable[_UMLs, _ReclassifyObjectAction] == UMLs$ReclassifyObjectAction;
axiom classifierTable[_UMLs, _ReadIsClassifiedObjectAction] == UMLs$ReadIsClassifiedObjectAction;
axiom classifierTable[_UMLs, _StartClassifierBehaviorAction] == UMLs$StartClassifierBehaviorAction;
axiom classifierTable[_UMLs, _ReadLinkObjectEndAction] == UMLs$ReadLinkObjectEndAction;
axiom classifierTable[_UMLs, _ReadLinkObjectEndQualifierAction] == UMLs$ReadLinkObjectEndQualifierAction;
axiom classifierTable[_UMLs, _CreateLinkObjectAction] == UMLs$CreateLinkObjectAction;
axiom classifierTable[_UMLs, _AcceptEventAction] == UMLs$AcceptEventAction;
axiom classifierTable[_UMLs, _AcceptCallAction] == UMLs$AcceptCallAction;
axiom classifierTable[_UMLs, _ReplyAction] == UMLs$ReplyAction;
axiom classifierTable[_UMLs, _UnmarshallAction] == UMLs$UnmarshallAction;
axiom classifierTable[_UMLs, _ReduceAction] == UMLs$ReduceAction;
axiom classifierTable[_UMLs, _StartObjectBehaviorAction] == UMLs$StartObjectBehaviorAction;
axiom classifierTable[_UMLs, _JoinNode] == UMLs$JoinNode;
axiom classifierTable[_UMLs, _DataStoreNode] == UMLs$DataStoreNode;
axiom classifierTable[_UMLs, _ConditionalNode] == UMLs$ConditionalNode;
axiom classifierTable[_UMLs, _Clause] == UMLs$Clause;
axiom classifierTable[_UMLs, _LoopNode] == UMLs$LoopNode;
axiom classifierTable[_UMLs, _ExpansionNode] == UMLs$ExpansionNode;
axiom classifierTable[_UMLs, _ExpansionRegion] == UMLs$ExpansionRegion;
axiom classifierTable[_UMLs, _ProtocolTransition] == UMLs$ProtocolTransition;
axiom classifierTable[_UMLs, _AssociationClass] == UMLs$AssociationClass;

// if src mm print valid src
