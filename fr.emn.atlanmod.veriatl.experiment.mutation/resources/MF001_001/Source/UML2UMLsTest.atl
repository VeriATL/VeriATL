-- @atlcompiler emftvm

module UML2UMLs;
create OUT: UMLs from IN: UML;
	

rule CopyAbstraction{
	from
	  s : UML!Abstraction
	  (s.oclIsTypeOf(UML!Abstraction))
	to
	  t : UMLs!Abstraction
	  (mapping <- s.mapping,
	  client <- s.client,
	  supplier <- s.supplier,
	  source <- s.source,
	  target <- s.target,
	  ownedComment <- s.ownedComment,
	  ownedElement <- s.ownedElement,
	  owner <- s.owner,
	  clientDependency <- s.clientDependency,
	  name <- s.name,
	  nameExpression <- s.nameExpression,
	  namespace <- s.namespace,
	  qualifiedName <- s.qualifiedName,
	  visibility <- s.visibility,
	  owningTemplateParameter <- s.owningTemplateParameter,
	  templateParameter <- s.templateParameter,
	  relatedElement <- s.relatedElement)
}

rule CopyAcceptCallAction_mutated{
	from
	  s : UML!AcceptCallAction
	  (s.oclIsTypeOf(UML!AcceptCallAction) and s.isLocallyReentrant = false)
	to
	  t : UMLs!AcceptCallAction
	  (returnInformation <- s.returnInformation,
	  isUnmarshall <- s.isUnmarshall,
	  result <- s.result,
	  trigger <- s.trigger,
	  context <- s.context,
	  input <- s.input,
	  isLocallyReentrant <- s.isLocallyReentrant,
	  localPostcondition <- s.localPostcondition,
	  localPrecondition <- s.localPrecondition,
	  output <- s.output,
	  activity <- s.activity,
	  inGroup <- s.inGroup,
	  inInterruptibleRegion <- s.inInterruptibleRegion,
	  inPartition <- s.inPartition,
	  inStructuredNode <- s.inStructuredNode,
	  incoming <- s.incoming,
	  outgoing <- s.outgoing,
	  redefinedNode <- s.redefinedNode,
	  ownedComment <- s.ownedComment,
	  ownedElement <- s.ownedElement,
	  owner <- s.owner,
	  handler <- s.handler,
	  clientDependency <- s.clientDependency,
	  name <- s.name,
	  nameExpression <- s.nameExpression,
	  namespace <- s.namespace,
	  qualifiedName <- s.qualifiedName,
	  visibility <- s.visibility,
	  isLeaf <- s.isLeaf,
	  redefinedElement <- s.redefinedElement,
	  redefinitionContext <- s.redefinitionContext)
}

