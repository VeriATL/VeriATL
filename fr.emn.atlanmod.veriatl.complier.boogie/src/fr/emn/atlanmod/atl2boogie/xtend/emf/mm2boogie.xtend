package fr.emn.atlanmod.atl2boogie.xtend.emf

import fr.emn.atlanmod.atl2boogie.xtend.core.driver
import fr.emn.atlanmod.atl2boogie.xtend.lib.emf
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EClassifier
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import java.text.SimpleDateFormat
import java.util.Date

class mm2boogie {
	
	/* 
	 * Entry point of metamodel to Boogie transformation
	 * */ 
	def static gen_Metamodel(EPackage ePackage) '''
		«{driver.constants.add(ePackage.name);""}»
		«val eClasses = emf.getOrderedClassifiers(ePackage)»
		/********************************************************************
			@name Boogie declarations and axioms for metamodel «ePackage.name»
			@date «new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(new Date)»
			@description Automatically generated by mm2boogie transformation.
		 ********************************************************************/
		
		/* constant declarations for Classifiers */
		«FOR e : eClasses»
			«gen_Classifiers(e)»	
		«ENDFOR»
		
		/* axiom declarations to map to Classifiers */
		«FOR eClass : ePackage.EClassifiers»
			«{driver.constants.add(eClass.name);""}»
			«IF eClass instanceof EClass»
				axiom classifierTable[_«ePackage.name», _«eClass.name»] == «ePackage.name»$«eClass.name»;
			«ENDIF»		
		«ENDFOR»
		
		/* structural axiom declarations for Classifiers */
		«IF ePackage.name == driver.srcmm.name»
			«gen_validSrc(ePackage)»
		«ENDIF»
	'''

	/*
	 * Dispatcher of Classifier, which suppose to do nothing
	 * */
	def static dispatch gen_Classifiers(EClassifier eClass) '''
	'''
		
	/*  
	 * Print Classifier:
	 *	- every classifier map to a constant
	 *  - every structural feature of a classifier map to a constant  
	 *  - every abstract classifier generate an axiom
	 * */
	def static dispatch gen_Classifiers(EClass eClass) '''
		«val ePackageName = eClass.EPackage.name»
		«/* classifier are unique and might have inheritance information */»
		const unique «ePackageName»$«eClass.name»: ClassName extends «
			(0..<eClass.ESuperTypes.size).map(i | ePackageName + "$" + eClass.ESuperTypes.get(i).name).join(",")» complete;
		«FOR eStructuralFeature : eClass.EStructuralFeatures»
			«gen_StructuralFeatures(eClass, eStructuralFeature)»	
		«ENDFOR»
		«/* abstract classifier has NO runtime instances */»
		«IF eClass.abstract»
		  axiom (forall __r: ref :: dtype(__r) != «ePackageName»$«eClass.name»);
		«ENDIF»
	'''
	
	/*
	 * Dispatcher of StructuralFeature, which suppose to do nothing
	 * */
	def static dispatch gen_StructuralFeatures(EClassifier eClass, EStructuralFeature eStructuralFeature) '''
	''' 
	
	/*  
	 * Print Attribute:
	 * 	- every attribute of primitive type is map to a primitive field
	 * 	- otherwise, print error information
	 * TODO:
	 * 	- primitive type is not completely defined
	 *  - print error information
	 * */
	def static dispatch gen_StructuralFeatures(EClassifier eClass, EAttribute eAttribute) '''
		const unique «eClass.EPackage.name»$«eClass.name».«eAttribute.name»: Field «
			IF eAttribute.EType.name == 'EString'»String«
			ELSEIF eAttribute.EType.name == 'EInt'»int«
			ELSEIF eAttribute.EType.name == 'EBoolean'»bool«
			ELSEIF eAttribute.EType.name == 'String'»String«
			ELSEIF eAttribute.EType.name == 'Integer'»int«
			ELSEIF eAttribute.EType.name == 'Boolean'»bool«
			ELSE»ref«ENDIF»;
	'''
	
	/*  
	 * Print Reference:
	 * 	- every reference is map to a reference field
	 * */
	def static dispatch gen_StructuralFeatures(EClassifier eClass, EReference eReference) '''
		const unique «eClass.EPackage.name»$«eClass.name».«eReference.name»: Field ref;
	'''
	
	/*  
	 * Print structural axiom declarations for Classifiers
	 * 
	 * TODO
	 * 	- check whether new added filter works
	 * */
	def static gen_validSrc(EPackage ePackage) '''
		function valid_src_model($h: HeapType): bool{
			«FOR eClass : ePackage.EClassifiers.filter(EClass) SEPARATOR "&&"»
				«gen_constraints_class(eClass)»
			«ENDFOR»
		} 
	'''

	/*  
	 * Core logic of print structural axiom declarations for Classifiers
	 * 
	 * */
	def static gen_constraints_class(EClass cl) '''
		«val bv = "__"+cl.name.toLowerCase»
		«val mmName = cl.EPackage.name»
		(forall «bv» : ref ::
		  («bv»!=null && read($h, «bv», alloc) && dtype(«bv») <: «mmName»$«cl.name» ==> 
		    «IF cl.EStructuralFeatures.size == 0»true«ENDIF»
		    «FOR sf : cl.EStructuralFeatures SEPARATOR "&&"»
		    «IF sf.eClass.name == "EReference" && (sf as EReference).many»
		    (read($h, «bv», «mmName»$«cl.name».«sf.name»)==null || (read($h, read($h, «bv», «mmName»$«cl.name».«sf.name»), alloc) && dtype(read($h, «bv», «mmName»$«cl.name».«sf.name»)) <: class._System.array &&
		       (forall __i: int :: 0<=__i && __i<_System.array.Length(read($h, «bv», «mmName»$«cl.name».«sf.name»)) ==> 
		         ($Unbox(read($h, read($h, «bv», «mmName»$«cl.name».«sf.name»), IndexField(__i))): ref !=null 
		         && read($h, $Unbox(read($h, read($h, «bv», «mmName»$«cl.name».«sf.name»), IndexField(__i))): ref, alloc)
		         && dtype($Unbox(read($h, read($h, «bv», «mmName»$«cl.name».«sf.name»), IndexField(__i))): ref)<:«mmName»$«(sf as EReference).EReferenceType.name») ) ) )
		    «ELSEIF sf.eClass.name == "EReference" && !(sf as EReference).many»
		    (read($h, «bv», «mmName»$«cl.name».«sf.name»)!=null && read($h, read($h, «bv», «mmName»$«cl.name».«sf.name») ,alloc) ==>
		       dtype(read($h, «bv», «mmName»$«cl.name».«sf.name»)) <: «mmName»$«(sf as EReference).EReferenceType.name» ) 
		    «ELSE» true «ENDIF»
		    «ENDFOR»  
		  )
		)
	'''
	
	
	
	
}