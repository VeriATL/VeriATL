-- @atlcompiler emftvm

module IndustrialToAutosar;

create OUT : Autosar from IN : Industrial;

--Matched Rule: Matches any Module in the industrial model
--into a SwCompToEcuMapping_component that references a Component Prototype
rule createComponent{ 
	from m:Industrial!Module 
	to 
	mapComp: Autosar!SwCompToEcuMapping_component(
		-- some problem with set singleton
		-- componentPrototype <- Set{comp} 
		),
	comp: Autosar!ComponentPrototype(
		shortName <-m.name
		)	
}

-- matched rule: matches any PhysicalNode element (and all its attributes/references) 
-- in a industrial model into a System template/PhysicalNode Extract (and all its attributes/references)
-- in its equivalent autosar model

rule initSysTemp{
	from physNode: Industrial!PhysicalNode 	(physNode.partition->exists(part|part.module->notEmpty()))
	to 
	sysmapping: Autosar!SystemMapping(
		shortName <-'SysMapping_' + physNode.name,
		swMapping<- physNode.partition->collect(part|thisModule.resolveTemp(part, 'mapping'))
	),
	sys: Autosar!System (
		shortName<-'SysTemplate_' + physNode.name,
		mapping <-sysmapping,
		softwareComposition <-swCompos
	),
	swCompos: Autosar!SoftwareComposition(
		shortName<-'SoftwareComposition_' + physNode.name,
		softwareComposition <-compostype
	),
	compostype:Autosar!CompositionType(
		shortName <- 'CompositionType_' + physNode.name,
		component <- physNode.partition->collect(part|part.module)->flatten()->collect(d|thisModule.resolveTemp(d, 'comp'))
		,
		port <- physNode.partition->collect(part | part.module)->flatten()->collect(d|d.scheduler)->flatten()->select(e|e.required->notEmpty())->collect(e|Tuple{physNode = physNode, sched = e}),
		port <-	physNode.partition->collect(part | part.module)->flatten()->collect(d|d.scheduler)->flatten()->select(e|e.provided->notEmpty())->collect(e|Tuple{physNode = physNode, sched = e})
	),
	EcuInst :Autosar!EcuInstance (
		shortName<-'EcuInstance_'+physNode.name
	)
}


--LAZY RULE: creates a single PPortPrototype from an Scheduler
-- Uses the 'Name' of the Scheduler to generate the 'shortName'
--     of the PPortPrototype... 
rule createPPort {
   from
     physNode: Industrial!PhysicalNode, sched: Industrial!Scheduler (
     	physNode.partition->exists(part|part.module->notEmpty())  and
     	physNode.partition->collect(part | part.module)->flatten()->collect(d|d.scheduler)->flatten()->select(e|e.provided->notEmpty())->includes(sched)
	 )	  
   to 
     newPport:Autosar!PPortPrototype (
     	shortName <- sched.name+'PROV'
		)
 }


--LAZY RULE: creates a single RPortPrototype from an Scheduler 
--Uses the 'Name' of the Scheduler to generate the 'shortName'
--     of the RPortPrototype... 
rule createRPort {
   from
    physNode: Industrial!PhysicalNode, sched: Industrial!Scheduler (
		physNode.partition->exists(part|part.module->notEmpty()) and 
    	physNode.partition->collect(part | part.module)->flatten()->collect(d|d.scheduler)->flatten()->select(e|e.provided->notEmpty())->includes(sched)
	)
   to 
     newRport:Autosar!RPortPrototype (
     	shortName <- sched.name+'REQ'
		)
 }


-- Matched Rule : maps a Partition to a Swc2EcuMapping 
-- -- uses the 'shortName' of the Partition to produce the 'shortName' of the Swc2EcuMapping
-- -- Sets the 'component' reference using the generateComponents function
-- -- Sets the ecuInstance using resolveTemp on the physNode encapsulating the current Partition being mapped
rule initSingleSwc2EcuMapping {
   from
   	 -- some problem here
     part:Industrial!Partition (true
     	and (Industrial!PhysicalNode.allInstances()->one(physNode|physNode.partition->includes(part)))and(part.module->notEmpty())
	 )
   to 
        -- why did fabian use a different type to map the next step? resolved -> should work
   		mapping:Autosar!SwcToEcuMapping (
     	shortName <- 'Swc2EcuMapping_'+part.name, --was part.ShortName
		component <- part.module -> collect(d|thisModule.resolveTemp(d, 'mapComp')) --,
		-- some problem here
		-- ecuInstance <- thisModule.resolveTemp((Industrial!PhysicalNode.allInstances()->select(pn|pn.partition->includes(part)))->first(),'EcuInst')
		)
}