/********************************************************************
	@name Boogie axioms for transformation surjectivity 
	@date 2017/08/03 10:07:02
	@description Automatically generated by mm2boogie transformation.
 ********************************************************************/
  

  
/* generate signature of getTarsBySrcs0 function and its inverse */
function getTarsBySrcs(Seq ref): ref;
function getTarsBySrcs_inverse(ref): Seq ref;

/* generate axioms of getTarsBySrcs0 function and its inverse */  

// getTarsBySrcs0 function is injective

axiom (forall __refs: Seq ref :: { getTarsBySrcs(__refs) } getTarsBySrcs_inverse(getTarsBySrcs(__refs)) == __refs);

// from s1 to t1,...tn => t1 != t2, .... t1 != tn

// s1 != s2 => getTarsBySrcs0(s1) != getTarsBySrcs0(s2)

// getTarsBySrcs0({null}) == null
axiom getTarsBySrcs( Seq#Singleton(null) ) == null;

// every out pattern element corresponds to a set of input pattern element(s)
function surj_tar_model($s: HeapType, $t: HeapType): bool{		
	
	(forall sm2: ref :: 
	  sm2!=null && read($t, sm2, alloc) && dtype(sm2) == FSM$StateMachine ==>
	    
	    (exists  sm1: ref  ::
	       sm1!=null && read($s, sm1, alloc) && dtype(sm1) <: HSM$StateMachine  &&
	       printGuard_SM2SM($s,  sm1 ) && 
	      	 getTarsBySrcs(Seq#Singleton( sm1  ))  == sm2 )
	)&&
	
	(forall rs2: ref :: 
	  rs2!=null && read($t, rs2, alloc) && dtype(rs2) == FSM$RegularState ==>
	    
	    (exists  rs1: ref  ::
	       rs1!=null && read($s, rs1, alloc) && dtype(rs1) <: HSM$RegularState  &&
	       printGuard_RS2RS($s,  rs1 ) && 
	      	 getTarsBySrcs(Seq#Singleton( rs1  ))  == rs2 )
	    ||
	    (exists  is1: ref  ::
	       is1!=null && read($s, is1, alloc) && dtype(is1) <: HSM$InitialState  &&
	       printGuard_IS2RS($s,  is1 ) && 
	      	 getTarsBySrcs(Seq#Singleton( is1  ))  == rs2 )
	)&&
	
	(forall is2: ref :: 
	  is2!=null && read($t, is2, alloc) && dtype(is2) == FSM$InitialState ==>
	    
	    (exists  is1: ref  ::
	       is1!=null && read($s, is1, alloc) && dtype(is1) <: HSM$InitialState  &&
	       printGuard_IS2IS($s,  is1 ) && 
	      	 getTarsBySrcs(Seq#Singleton( is1  ))  == is2 )
	)&&
	
	true &&
	
	(forall t2: ref :: 
	  t2!=null && read($t, t2, alloc) && dtype(t2) == FSM$Transition ==>
	    
	    (exists  t1: ref , src: ref , trg: ref , c: ref  ::
	       t1!=null && read($s, t1, alloc) && dtype(t1) <: HSM$Transition  &&  src!=null && read($s, src, alloc) && dtype(src) <: HSM$AbstractState  &&  trg!=null && read($s, trg, alloc) && dtype(trg) <: HSM$CompositeState  &&  c!=null && read($s, c, alloc) && dtype(c) <: HSM$InitialState  &&
	       printGuard_T2TC($s,  t1 , src , trg , c ) && 
	      	 getTarsBySrcs(Seq#Build(Seq#Build(Seq#Build(Seq#Singleton( t1 ), src ), trg ), c  ))  == t2 )
	    ||
	    (exists  t1: ref  ::
	       t1!=null && read($s, t1, alloc) && dtype(t1) <: HSM$Transition  &&
	       printGuard_T2TA($s,  t1 ) && 
	      	 getTarsBySrcs(Seq#Singleton( t1  ))  == t2 )
	    ||
	    (exists  t1: ref , src: ref , trg: ref , c: ref  ::
	       t1!=null && read($s, t1, alloc) && dtype(t1) <: HSM$Transition  &&  src!=null && read($s, src, alloc) && dtype(src) <: HSM$CompositeState  &&  trg!=null && read($s, trg, alloc) && dtype(trg) <: HSM$AbstractState  &&  c!=null && read($s, c, alloc) && dtype(c) <: HSM$AbstractState  &&
	       printGuard_T2TB($s,  t1 , src , trg , c ) && 
	      	 getTarsBySrcs(Seq#Build(Seq#Build(Seq#Build(Seq#Singleton( t1 ), src ), trg ), c  ))  == t2 )
	)&&
	
	true &&
	
	true 
}
// We don't understand OclModel
// We don't understand OclModel
